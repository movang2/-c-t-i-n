<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Giao D·ªãch V√†ng (XAU/USD) - Finnhub (Directional Suggestion)</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f8f9fa;
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
            padding: 20px;
        }
        h1 {
            color: #d4af37;
            text-align: center;
            margin-bottom: 30px;
        }
        .panel {
            background: #fafafa;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            border: 1px solid #eee;
        }
        .panel-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 15px;
            color: #333;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }
        .control-group {
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            flex-wrap: wrap; /* Cho ph√©p xu·ªëng d√≤ng tr√™n m√†n h√¨nh nh·ªè */
        }
        label {
            display: inline-block;
            width: 150px;
            margin-bottom: 5px;
            font-weight: 500;
        }
        input[type="file"], input[type="text"], input[type="number"], select {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            width: 200px;
        }
        input[type="checkbox"] {
            width: auto;
            margin-right: 5px;
        }
        .checkbox-label {
            width: 200px; 
            margin-left: 5px;
            margin-right: 20px;
        }
        button {
            background-color: #d4af37;
            color: #1e2026;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            margin-right: 10px;
            transition: all 0.3s;
        }
        button:hover {
            background-color: #e5c046;
        }
        button.danger {
            background-color: #f6465d;
            color: white;
        }
        button.danger:hover {
            background-color: #ff6b81;
        }
        .price-display {
            font-size: 24px;
            font-weight: bold;
            text-align: center;
            margin: 20px 0;
            color: #d4af37;
        }
        .chart-container {
            height: 400px;
            margin-bottom: 30px;
        }
        .trade-info {
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
        }
        .trade-box {
            width: 48%;
            background: #fff;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
            border-left: 4px solid #d4af37;
        }
        .trade-box.sell {
            border-left-color: #f6465d;
        }
        .profit {
            color: #0ecb81;
            font-weight: bold;
        }
        .loss {
            color: #f6465d;
            font-weight: bold;
        }
        #historyList {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #eee;
            border-radius: 4px;
            padding: 10px;
        }
        .history-item {
            padding: 8px 0;
            border-bottom: 1px solid #f5f5f5;
        }
        .status-bar {
            background: #1e2026;
            color: white;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
        }
        .suggestion-box {
            font-size: 16px;
            padding: 10px;
            margin-top: 10px;
            border-radius: 4px;
            font-weight: bold;
            text-align: center;
        }
        .suggest-buy {
            background-color: #d1ffc9;
            color: #0ecb81;
            border: 1px solid #0ecb81;
        }
        .suggest-sell {
            background-color: #ffd4d4;
            color: #f6465d;
            border: 1px solid #f6465d;
        }
        .stats-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            font-size: 14px;
        }
        .stats-table th, .stats-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        .stats-table th {
            background-color: #e9ecef;
        }
        .sound-checkboxes {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 15px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .sound-checkbox-item {
            display: flex;
            align-items: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Giao D·ªãch V√†ng (XAU/USD) - Finnhub</h1>
        
        <div class="status-bar" id="tradingStatus">
            <div>Tr·∫°ng th√°i: <span id="statusText">Ch∆∞a b·∫Øt ƒë·∫ßu</span></div>
            <div>S·ªë d∆∞: <span id="balanceText">1000.00</span> USD</div>
            <div>L·ªánh h√¥m nay: <span id="tradesCount">0</span></div>
        </div>
        
        <div class="price-display">
            Gi√° XAU/USD hi·ªán t·∫°i: <span id="currentPrice">0.00</span>
        </div>
        
        <div class="panel">
            <div class="panel-title">üí∞ C√†i ƒê·∫∑t Giao D·ªãch</div>
            <div class="control-group">
                <label for="virtualBalance">S·ªë d∆∞ ban ƒë·∫ßu (USD):</label>
                <input type="number" id="virtualBalance" value="1000" min="100">
            </div>
            <div class="control-group">
                <label for="leverage">ƒê√≤n b·∫©y:</label>
                <input type="number" id="leverage" value="10" min="1" max="100">
            </div>
            <div class="control-group">
                <label for="lotSize">Kh·ªëi l∆∞·ª£ng (lot):</label>
                <input type="number" id="lotSize" value="0.1" min="0.01" step="0.01">
            </div>
            <div class="control-group">
                <label for="stopLoss">Stop Loss (USD):</label>
                <input type="number" id="stopLoss" value="50" min="1">
            </div>
            <div class="control-group">
                <label for="takeProfit">Take Profit (USD):</label>
                <input type="number" id="takeProfit" value="65" min="1">
            </div>
            <div style="margin-top: 20px;">
                <button onclick="startAutoTrading()">B·∫Øt ƒê·∫ßu Giao D·ªãch</button>
                <button class="danger" onclick="stopAutoTrading()">D·ª´ng Giao D·ªãch</button>
                <button onclick="analyzeBalanceHistory()">Ph√¢n T√≠ch Hi·ªáu Su·∫•t</button>
                <button class="danger" onclick="resetData()">Reset D·ªØ Li·ªáu</button>
            </div>
        </div>

        <div class="panel">
            <div class="panel-title">üéµ C√†i ƒê·∫∑t √Çm Thanh Th√¥ng B√°o</div>
            
            <div class="control-group" style="align-items: flex-start; flex-direction: column;">
                <button onclick="toggleDefaultSounds()" id="defaultSoundToggle" style="margin-bottom: 15px; padding: 10px 15px; background: #f6465d; color: white; border: none; border-radius: 4px; cursor: pointer;">
                    üîá T·∫Øt √Çm Thanh M·∫∑c ƒê·ªãnh
                </button>

                <div class="control-group">
                    <label for="globalNotifySoundInput">T·∫£i File √Çm Thanh (Chung):</label>
                    <input type="file" id="globalNotifySoundInput" accept=".mp3" style="width: 250px;">
                </div>
            </div>
            
            <p>Ch·ªçn c√°c th√¥ng b√°o s·∫Ω s·ª≠ d·ª•ng File √Çm Thanh Chung ƒë√£ t·∫£i l√™n:</p>
            
            <div class="sound-checkboxes">
                <div class="sound-checkbox-item">
                    <input type="checkbox" id="useOpenSound">
                    <label for="useOpenSound" class="checkbox-label" style="width: auto;">M·ªü l·ªánh</label>
                </div>
                
                <div class="sound-checkbox-item">
                    <input type="checkbox" id="useTpSound">
                    <label for="useTpSound" class="checkbox-label" style="width: auto;">Take Profit</label>
                </div>
                
                <div class="sound-checkbox-item">
                    <input type="checkbox" id="useSlSound">
                    <label for="useSlSound" class="checkbox-label" style="width: auto;">Stop Loss</label>
                </div>
                
                <div class="sound-checkbox-item">
                    <input type="checkbox" id="useAlertSound">
                    <label for="useAlertSound" class="checkbox-label" style="width: auto;">C·∫£nh b√°o gi√°</label>
                </div>
                
                <div class="sound-checkbox-item">
                    <input type="checkbox" id="useIntersectionSound">
                    <label for="useIntersectionSound" class="checkbox-label" style="width: auto;">Giao nhau (B/G)</label>
                </div>
                
                <div class="sound-checkbox-item">
                    <input type="checkbox" id="useSuggestionSound">
                    <label for="useSuggestionSound" class="checkbox-label" style="width: auto;">G·ª£i √Ω (Buy/Sell)</label>
                </div>

                <div class="sound-checkbox-item">
                    <input type="checkbox" id="usePriceStagnantSound">
                    <label for="usePriceStagnantSound" class="checkbox-label" style="width: auto;">Gi√° ƒë·ª©ng im</label>
                </div>
                
                <div class="sound-checkbox-item" style="display: none;">
                    <input type="checkbox" id="useGlobalSound">
                    <label for="useGlobalSound" class="checkbox-label" style="width: auto;">S·ª≠ d·ª•ng √¢m chung</label>
                </div>
            </div>

            <div style="margin-top: 20px;">
                <button onclick="saveAllSoundSettings()">L∆∞u C·∫•u H√¨nh √Çm Thanh</button>
            </div>
        </div>

        <div class="panel">
            <div class="panel-title">C·∫£nh B√°o Gi√°</div>
            <div class="control-group">
                <label for="alertPrices">M·ªëc gi√° (c√°ch nhau b·∫±ng ,):</label>
                <input type="text" id="alertPrices" placeholder="V√≠ d·ª•: 3640,3680,3569,3567" style="width: 300px;">
            </div>
            <div style="margin-top: 20px;">
                <button onclick="updateAlertLevels()">L∆∞u M·ªëc Gi√° C·∫£nh B√°o</button>
            </div>
        </div>
        
        <div class="panel">
            <div class="panel-title">‚öôÔ∏è C√†i ƒê·∫∑t G·ª£i √ù Theo H∆∞·ªõng</div>
            
            <div class="control-group">
                <input type="checkbox" id="suggestionByDirectionEnabled" onchange="toggleSuggestionMode()">
                <label for="suggestionByDirectionEnabled" class="checkbox-label" style="width: 250px;">**[B·∫≠t/T·∫Øt] G·ª£i √Ω Theo H∆∞·ªõng**</label>
                <button onclick="saveDirectionalSettings()" style="margin-left: 20px;">L∆∞u C√†i ƒê·∫∑t</button>
            </div>

            <div id="directionalSettingsContainer" style="margin-top: 15px; border-top: 1px solid #eee; padding-top: 15px; display: none;">
                <div class="control-group">
                    <label for="suggestionBaseLine">D·ªØ li·ªáu c∆° s·ªü:</label>
                    <select id="suggestionBaseLine" style="width: 200px;">
                        <option value="balance">ƒê∆∞·ªùng S·ªë D∆∞ (USD)</option>
                        <option value="gold">Gi√° V√†ng (XAU/USD)</option>
                    </select>
                </div>
                <div class="control-group">
                    <label for="suggestionStartIndex">Ch·ªâ s·ªë b·∫Øt ƒë·∫ßu (0-n):</label>
                    <input type="number" id="suggestionStartIndex" value="0" min="0" step="1">
                    <button onclick="updateStartIndexFromTrade()" style="margin-left: 10px; background-color: #0ecb81; color: white;">C·∫≠p nh·∫≠t t·ª´ L·ªánh G·∫ßn nh·∫•t</button>
                </div>
                <div class="control-group">
                    <label for="directionConfirmationPoints">S·ªë ƒëi·ªÉm x√°c nh·∫≠n h∆∞·ªõng:</label>
                    <input type="number" id="directionConfirmationPoints" value="3" min="1" step="1">
                </div>
            </div>
        </div>
        <div class="panel">
            <div class="panel-title">‚öôÔ∏è C√†i ƒê·∫∑t G·ª£i √ù Giao D·ªãch C≈® (Theo Giao Nhau)</div>
            <div class="control-group">
                <input type="checkbox" id="suggestionByIntersectionEnabled" onchange="toggleSuggestionMode()">
                <label for="suggestionByIntersectionEnabled" class="checkbox-label" style="width: 250px;">**[B·∫≠t/T·∫Øt] G·ª£i √Ω Theo Giao Nhau**</label>
            </div>
            <div id="intersectionSettingsContainer" style="margin-top: 15px; border-top: 1px solid #eee; padding-top: 15px; display: none;">
                <div class="control-group">
                    <label for="minSlope">ƒê·ªô d·ªëc t·ªëi thi·ªÉu (Slope):</label>
                    <input type="number" id="minSlope" value="0.2" min="0.01" step="0.01">
                </div>
                <div class="control-group">
                    <label for="minGapPct">Kho·∫£ng c√°ch t·ªëi thi·ªÉu (%):</label>
                    <input type="number" id="minGapPct" value="0.3" min="0.05" step="0.05">
                </div>
                <div class="control-group">
                    <label for="confirmDelay">ƒê·ªô tr·ªÖ x√°c nh·∫≠n (ƒëi·ªÉm):</label>
                    <input type="number" id="confirmDelay" value="1" min="1" step="1">
                </div>
                <div class="control-group">
                    <label for="suggestionMode">Ch·∫ø ƒë·ªô hi·ªÉn th·ªã:</label>
                    <select id="suggestionMode">
                        <option value="all">T·∫•t c·∫£</option>
                        <option value="buy">Ch·ªâ MUA</option>
                        <option value="sell">Ch·ªâ B√ÅN</option>
                    </select>
                </div>
                <div style="margin-top: 20px;">
                    <button onclick="saveIntersectionSettings()">L∆∞u C·∫•u H√¨nh G·ª£i √ù</button>
                </div>
            </div>
        </div>
        <div class="panel">
            <div class="panel-title">üìä G·ª£i √ù Hi·ªán T·∫°i</div>
            <div id="suggestionDisplay">
                Ch∆∞a c√≥ g·ª£i √Ω n√†o.
            </div>
            <table class="stats-table">
                <thead>
                    <tr>
                        <th>G·ª£i √Ω</th>
                        <th>T·ªïng s·ªë</th>
                        <th>L·ªánh ƒë√∫ng (ƒë√≥ng l·ªùi)</th>
                        <th>T·ªâ l·ªá ƒë√∫ng (%)</th>
                    </tr>
                </thead>
                <tbody id="suggestionStatsBody">
                    <tr><td>BUY</td><td id="statBuyTotal">0</td><td id="statBuyCorrect">0</td><td id="statBuyPct">0.00%</td></tr>
                    <tr><td>SELL</td><td id="statSellTotal">0</td><td id="statSellCorrect">0</td><td id="statSellPct">0.00%</td></tr>
                </tbody>
            </table>
            <button class="danger" onclick="resetSuggestionData()" style="margin-top: 10px;">Reset G·ª£i √ù & Th·ªëng k√™</button>
        </div>
        
        <div class="panel">
            <div class="panel-title">Bi·ªÉu ƒê·ªì Gi√°</div>
            <div class="chart-container">
                <canvas id="priceChart"></canvas>
            </div>
        </div>

        <div class="panel">
            <div class="panel-title">Bi·ªÉu ƒê·ªì S·ªë D∆∞ & Gi√° V√†ng</div>
            <div class="chart-container">
                <canvas id="balanceChart" height="300"></canvas>
            </div>
        </div>
        
        <div id="activeTrades" style="display: none;">
            <div class="panel-title">L·ªánh Hi·ªán T·∫°i</div>
            <div class="trade-info" id="currentTradeDetails"></div>
        </div>
        
        <div class="panel">
            <div class="panel-title">L·ªãch S·ª≠ Giao D·ªãch & Log</div>
            <div id="historyList"></div>
            <button style="margin-top: 10px;" onclick="clearHistory()">X√≥a L·ªãch S·ª≠</button>
        </div>
    </div>

    <script>
        // Bi·∫øn to√†n c·ª•c
        const FINNHUB_API_KEY = 'd1l6t99r01qt4thebangd1l6t99r01qt4thebao0';
        let currentPrice = 0;
        let chart;
        let balanceChart;
        let ws;
        let autoTradingActive = false;
        let tradingInterval;
        let virtualBalance = 1000;
        let tradesToday = 0;
        let currentTrades = [];
        let priceHistory = [];
        let balanceHistory = JSON.parse(localStorage.getItem('balanceHistory')) || [];
        let isWaitingNewTrades = false;
        let lastUpdateTime = null;

        // C·∫•u h√¨nh G·ª£i √Ω GIAO NHAU C≈®
        let intersectionSettings = JSON.parse(localStorage.getItem('intersectionSettings')) || {
            minSlope: 0.2,
            minGapPct: 0.3,
            confirmDelay: 1,
            suggestionMode: 'all'
        };
        let suggestionStats = JSON.parse(localStorage.getItem('suggestionStats')) || {
            BUY: { total: 0, correct: 0, lastIndex: -1, lastTime: null, lastTradeIndex: -1 },
            SELL: { total: 0, correct: 0, lastIndex: -1, lastTime: null, lastTradeIndex: -1 }
        };

        // C·∫•u h√¨nh G·ª£i √Ω THEO H∆Ø·ªöNG M·ªöI
        let suggestionByDirectionEnabled = localStorage.getItem('suggestionByDirectionEnabled') === 'true'; 
        let suggestionByIntersectionEnabled = localStorage.getItem('suggestionByIntersectionEnabled') === 'true'; 
        let suggestionBaseLine = localStorage.getItem('suggestionBaseLine') || 'balance'; // 'balance' ho·∫∑c 'gold'
        let suggestionStartIndex = parseInt(localStorage.getItem('suggestionStartIndex')) || 0; // Ch·ªâ s·ªë b·∫Øt ƒë·∫ßu trong balanceHistory
        let directionConfirmationPoints = parseInt(localStorage.getItem('directionConfirmationPoints')) || 3;
        let lastDirectionalSuggestion = localStorage.getItem('lastDirectionalSuggestion') || null; // 'BUY'/'SELL'

        // Bi·∫øn ƒëi·ªÅu khi·ªÉn √¢m thanh m·∫∑c ƒë·ªãnh
        let defaultSoundsEnabled = localStorage.getItem('defaultSoundsEnabled') !== 'false';

        // √Çm thanh m·∫∑c ƒë·ªãnh
        const defaultOpenSound = new Audio('https://www.soundjay.com/buttons/button-21.mp3');
        const defaultTpSound = new Audio('https://www.soundjay.com/buttons/button-09.mp3');
        const defaultSlSound = new Audio('https://www.soundjay.com/buttons/button-10.mp3');
        const defaultAlertSound = new Audio('https://www.soundjay.com/buttons/sounds/beep-07.mp3');
        const defaultIntersectionSound = defaultAlertSound;
        const defaultSuggestionSound = defaultAlertSound;
        const defaultPriceStagnantSound = defaultAlertSound;

        // √Çm thanh ng∆∞·ªùi d√πng (s·∫Ω ƒë∆∞·ª£c t·∫£i t·ª´ localStorage)
        let userGlobalNotifySound = null; 
        
        // L∆∞u tr·∫°ng th√°i t√≠ch ch·ªçn c·ªßa t·ª´ng lo·∫°i √¢m thanh
        let soundUseStatus = JSON.parse(localStorage.getItem('soundUseStatus')) || {};
        
        // Th√™m c√°c bi·∫øn ph√°t hi·ªán gi√° ƒë·ª©ng im
        let lastPriceUpdateTime = null;
        let priceStagnantAlertPlayed = false;
        let priceStagnantThreshold = 10000; // 10 gi√¢y
        
        let alertLevels = [];
        let alertedLevels = new Set();
        let alertedIntersectionIndices = new Set();

        // H√†m b·∫≠t/t·∫Øt √¢m thanh m·∫∑c ƒë·ªãnh
        function toggleDefaultSounds() {
            defaultSoundsEnabled = !defaultSoundsEnabled;
            localStorage.setItem('defaultSoundsEnabled', defaultSoundsEnabled);
            
            const button = document.getElementById('defaultSoundToggle');
            if (defaultSoundsEnabled) {
                button.innerHTML = 'üîá T·∫Øt √Çm Thanh M·∫∑c ƒê·ªãnh';
                button.style.backgroundColor = '#f6465d';
            } else {
                button.innerHTML = 'üîä B·∫≠t √Çm Thanh M·∫∑c ƒê·ªãnh';
                button.style.backgroundColor = '#0ecb81';
            }
            
            logStatus(defaultSoundsEnabled ? 'üîä B·∫≠t √¢m thanh m·∫∑c ƒë·ªãnh' : 'üîá T·∫Øt √¢m thanh m·∫∑c ƒë·ªãnh');
        }
        
        // Ghi log tr·∫°ng th√°i
        function logStatus(message) {
            const now = new Date().toLocaleTimeString('vi-VN');
            console.log(`[${now}] ${message}`);
            addHistory(message);
        }

        // Kh·ªüi t·∫°o bi·ªÉu ƒë·ªì gi√° v√† s·ªë d∆∞
        function initChart() {
            const ctx = document.getElementById('priceChart').getContext('2d');
            chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'XAU/USD',
                        data: [],
                        borderColor: '#d4af37',
                        backgroundColor: 'rgba(212, 175, 55, 0.1)',
                        tension: 0.2,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: { beginAtZero: false }
                    }
                }
            });

            drawBalanceChart();
            updateSuggestionStatsDisplay();
        }

        // K·∫øt n·ªëi WebSocket Finnhub
        function connectWebSocket() {
            try {
                if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) return;
                
                ws = new WebSocket(`wss://ws.finnhub.io?token=${FINNHUB_API_KEY}`);
                
                ws.onopen = () => {
                    logStatus('WS open - subscribing OANDA:XAU_USD');
                    ws.send(JSON.stringify({ type: 'subscribe', symbol: 'OANDA:XAU_USD' }));
                    addHistory('üîå K·∫øt n·ªëi WebSocket');
                };
                
                
                ws.onmessage = (evt) => {
                    let data;
                    try { 
                        data = JSON.parse(evt.data); 
                    } catch(e) { 
                        console.error('WS JSON parse error', e); 
                        return; 
                    }
                    
                    if (data && data.type === 'trade' && Array.isArray(data.data)) {
                        const last = data.data[data.data.length - 1];
                        if (!last || typeof last.p === 'undefined') return;
                        
                        const oldPrice = currentPrice;
                        const newPrice = parseFloat(last.p);
                        if (isNaN(newPrice)) return;
                        
                        // C·∫≠p nh·∫≠t th·ªùi gian gi√° thay ƒë·ªïi
                        lastPriceUpdateTime = new Date().getTime();
                        
                        currentPrice = newPrice;
                        document.getElementById('currentPrice').textContent = newPrice.toFixed(2);
                        lastUpdateTime = new Date();
                        
                        const now = new Date();
                        priceHistory.push({ time: now.toLocaleTimeString('vi-VN'), price: newPrice });
                        if (priceHistory.length > 200) priceHistory.shift();
                        
                        updateChart();
                        drawBalanceChart();
                        checkPriceAlerts(oldPrice, newPrice);
                        
                        if (currentTrades.length > 0) {
                            updateTradeInfo();
                        }
                    }
                };
                
                ws.onerror = (err) => {
                    console.error('WS error', err);
                    addHistory('‚ö†Ô∏è L·ªói WebSocket');
                };
                
                ws.onclose = (ev) => {
                    console.warn('WS closed - reconnect in 3s', ev);
                    addHistory('‚ö†Ô∏è WebSocket ƒë√≥ng, th·ª≠ k·∫øt n·ªëi l·∫°i...');
                    setTimeout(connectWebSocket, 3000);
                };
            } catch(e) {
                console.error('connectWebSocket error', e);
                addHistory('‚ùå L·ªói k·∫øt n·ªëi WebSocket: ' + e.message);
            }
        }

        // C·∫≠p nh·∫≠t bi·ªÉu ƒë·ªì gi√°
        function updateChart() {
            const labels = priceHistory.map(item => item.time);
            const data = priceHistory.map(item => item.price);
            
            chart.data.labels = labels;
            chart.data.datasets[0].data = data;
            chart.update();
        }

        // H√†m ki·ªÉm tra gi√° ƒë·ª©ng im
        function checkPriceStagnation() {
            if (!lastPriceUpdateTime || currentPrice === 0) return;
            
            const now = new Date().getTime();
            const timeDiff = now - lastPriceUpdateTime;
            
            if (timeDiff > priceStagnantThreshold && !priceStagnantAlertPlayed) {
                playNotificationSound('priceStagnant');
                addHistory(`‚ö†Ô∏è C·∫¢NH B√ÅO: Gi√° kh√¥ng thay ƒë·ªïi trong ${priceStagnantThreshold/1000} gi√¢y`);
                priceStagnantAlertPlayed = true;
            } else if (timeDiff <= priceStagnantThreshold) {
                priceStagnantAlertPlayed = false;
            }
        }

        // L∆∞u t·∫•t c·∫£ c·∫•u h√¨nh √¢m thanh
        function saveAllSoundSettings() {
            const globalFileInput = document.getElementById('globalNotifySoundInput');
            
            // 1. X·ª≠ l√Ω file √¢m thanh chung (ch·ªâ t·∫£i 1 l·∫ßn)
            const f = globalFileInput?.files[0];
            let newGlobalUrl = localStorage.getItem('globalSoundUrl');
            
            if (f) {
                // T·∫°o URL t·∫°m th·ªùi v√† l∆∞u
                newGlobalUrl = URL.createObjectURL(f);
                userGlobalNotifySound = new Audio(newGlobalUrl); 
                localStorage.setItem('globalSoundUrl', newGlobalUrl);
            } else if (newGlobalUrl) {
                 // T·∫£i l·∫°i audio t·ª´ URL ƒë√£ l∆∞u n·∫øu kh√¥ng ch·ªçn file m·ªõi
                 userGlobalNotifySound = new Audio(newGlobalUrl); 
            } else {
                userGlobalNotifySound = null;
            }

            // 2. X·ª≠ l√Ω tr·∫°ng th√°i t√≠ch ch·ªçn
            const soundTypes = [
                { id: 'useOpenSound', type: 'open' },
                { id: 'useTpSound', type: 'tp' },
                { id: 'useSlSound', type: 'sl' },
                { id: 'useAlertSound', type: 'alert' },
                { id: 'useIntersectionSound', type: 'intersection' },
                { id: 'useSuggestionSound', type: 'suggestion' },
                { id: 'usePriceStagnantSound', type: 'priceStagnant' },
            ];

            soundTypes.forEach(s => {
                const use = document.getElementById(s.id)?.checked || false;
                soundUseStatus[s.type] = use;
            });

            localStorage.setItem('soundUseStatus', JSON.stringify(soundUseStatus));
            
            alert('‚úÖ ƒê√£ l∆∞u c·∫•u h√¨nh √¢m thanh');
            logStatus('üéµ ƒê√£ l∆∞u c·∫•u h√¨nh √¢m thanh');
        }

        // T·∫£i c·∫•u h√¨nh √¢m thanh t·ª´ localStorage
        function loadSoundSettings() {
            // T·∫£i URL √¢m thanh chung
            const globalUrl = localStorage.getItem('globalSoundUrl');
            if (globalUrl) {
                userGlobalNotifySound = new Audio(globalUrl);
            }

            // T·∫£i tr·∫°ng th√°i t√≠ch ch·ªçn
            soundUseStatus = JSON.parse(localStorage.getItem('soundUseStatus') || '{}');
            
            const soundTypes = [
                { id: 'useOpenSound', type: 'open' },
                { id: 'useTpSound', type: 'tp' },
                { id: 'useSlSound', type: 'sl' },
                { id: 'useAlertSound', type: 'alert' },
                { id: 'useIntersectionSound', type: 'intersection' },
                { id: 'useSuggestionSound', type: 'suggestion' },
                { id: 'usePriceStagnantSound', type: 'priceStagnant' },
            ];

            soundTypes.forEach(s => {
                if (document.getElementById(s.id)) {
                    // Thi·∫øt l·∫≠p tr·∫°ng th√°i t√≠ch ch·ªçn t·ª´ soundUseStatus
                    document.getElementById(s.id).checked = soundUseStatus[s.type] || false;
                }
            });
            
            // C·∫≠p nh·∫≠t tr·∫°ng th√°i n√∫t b·∫≠t/t·∫Øt √¢m m·∫∑c ƒë·ªãnh
            // G·ªçi l·∫°i toggleDefaultSounds() ƒë·ªÉ thi·∫øt l·∫≠p UI cho n√∫t
            if (defaultSoundsEnabled) {
                document.getElementById('defaultSoundToggle').innerHTML = 'üîá T·∫Øt √Çm Thanh M·∫∑c ƒê·ªãnh';
                document.getElementById('defaultSoundToggle').style.backgroundColor = '#f6465d';
            } else {
                document.getElementById('defaultSoundToggle').innerHTML = 'üîä B·∫≠t √Çm Thanh M·∫∑c ƒê·ªãnh';
                document.getElementById('defaultSoundToggle').style.backgroundColor = '#0ecb81';
            }
        }

        // H√†m l·∫•y √¢m thanh theo ∆∞u ti√™n
        function getSound(soundType) {
            
            // ∆Øu ti√™n 1: √Çm thanh chung t√πy ch·ªânh n·∫øu ƒë∆∞·ª£c t√≠ch
            if (soundUseStatus[soundType] && userGlobalNotifySound) {
                return userGlobalNotifySound;
            }
            
            let defaultSoundVar;
            
            switch(soundType) {
                case 'open': defaultSoundVar = defaultOpenSound; break;
                case 'tp': defaultSoundVar = defaultTpSound; break;
                case 'sl': defaultSoundVar = defaultSlSound; break;
                case 'alert': defaultSoundVar = defaultAlertSound; break;
                case 'intersection': defaultSoundVar = defaultIntersectionSound; break;
                case 'suggestion': defaultSoundVar = defaultSuggestionSound; break;
                case 'priceStagnant': defaultSoundVar = defaultPriceStagnantSound; break;
                default: return null;
            }

            // ∆Øu ti√™n 2: √Çm thanh m·∫∑c ƒë·ªãnh n·∫øu ƒë∆∞·ª£c b·∫≠t
            if (defaultSoundsEnabled && defaultSoundVar) {
                return defaultSoundVar;
            }
            
            return null; // Kh√¥ng c√≥ √¢m thanh n√†o
        }

        // H√†m ph√°t √¢m thanh
        function playNotificationSound(soundType) {
            try {
                const soundToPlay = getSound(soundType);
                
                if (soundToPlay) {
                    soundToPlay.currentTime = 0;
                    // L·ªói ·ªü ƒë√¢y (l·ªói Promise) th∆∞·ªùng x·∫£y ra khi tr√¨nh duy·ªát ch·∫∑n autoplay.
                    soundToPlay.play().catch(e => console.log(`L·ªói ph√°t √¢m thanh (${soundType}):`, e));
                }
                
            } catch (e) {
                console.error("L·ªói h·ªá th·ªëng √¢m thanh:", e);
            }
        }
        
        // ********************* C√ÅC H√ÄM GIAO D·ªäCH V√Ä G·ª¢I √ù *********************

        // H√†m b·∫≠t/t·∫Øt ch·∫ø ƒë·ªô g·ª£i √Ω
        function toggleSuggestionMode() {
            suggestionByDirectionEnabled = document.getElementById('suggestionByDirectionEnabled').checked;
            suggestionByIntersectionEnabled = document.getElementById('suggestionByIntersectionEnabled').checked;

            const directionalPanel = document.getElementById('directionalSettingsContainer');
            const intersectionPanel = document.getElementById('intersectionSettingsContainer');
            
            // Ch·ªâ hi·ªÉn th·ªã panel c·ªßa ch·∫ø ƒë·ªô ƒëang b·∫≠t
            directionalPanel.style.display = suggestionByDirectionEnabled ? 'block' : 'none';
            intersectionPanel.style.display = suggestionByIntersectionEnabled ? 'block' : 'none';

            // ƒê·∫£m b·∫£o kh√¥ng b·∫≠t c·∫£ hai c√πng l√∫c (t√πy ch·ªçn)
            if (suggestionByDirectionEnabled && suggestionByIntersectionEnabled) {
                if (confirm("B·∫°n ch·ªâ n√™n b·∫≠t m·ªôt ch·∫ø ƒë·ªô g·ª£i √Ω. T·∫Øt Giao nhau?")) {
                    document.getElementById('suggestionByIntersectionEnabled').checked = false;
                    suggestionByIntersectionEnabled = false;
                    intersectionPanel.style.display = 'none';
                } else {
                    document.getElementById('suggestionByDirectionEnabled').checked = false;
                    suggestionByDirectionEnabled = false;
                    directionalPanel.style.display = 'none';
                }
            } else if (!suggestionByDirectionEnabled && !suggestionByIntersectionEnabled) {
                document.getElementById('suggestionDisplay').innerHTML = 'Ch∆∞a c√≥ ch·∫ø ƒë·ªô g·ª£i √Ω n√†o ƒë∆∞·ª£c b·∫≠t.';
            }

            localStorage.setItem('suggestionByDirectionEnabled', suggestionByDirectionEnabled);
            localStorage.setItem('suggestionByIntersectionEnabled', suggestionByIntersectionEnabled);
            
            logStatus(`G·ª£i √Ω Theo H∆∞·ªõng: ${suggestionByDirectionEnabled ? 'B·∫≠t' : 'T·∫Øt'} | G·ª£i √Ω Giao nhau: ${suggestionByIntersectionEnabled ? 'B·∫≠t' : 'T·∫Øt'}`);
            drawBalanceChart(); // V·∫Ω l·∫°i ƒë·ªÉ k√≠ch ho·∫°t logic g·ª£i √Ω m·ªõi
        }

        // L∆∞u c√†i ƒë·∫∑t G·ª£i √Ω theo H∆∞·ªõng
        function saveDirectionalSettings() {
            suggestionBaseLine = document.getElementById('suggestionBaseLine').value;
            suggestionStartIndex = parseInt(document.getElementById('suggestionStartIndex').value);
            directionConfirmationPoints = parseInt(document.getElementById('directionConfirmationPoints').value);
            
            localStorage.setItem('suggestionBaseLine', suggestionBaseLine);
            localStorage.setItem('suggestionStartIndex', suggestionStartIndex);
            localStorage.setItem('directionConfirmationPoints', directionConfirmationPoints);
            
            logStatus('üíæ ƒê√£ l∆∞u c·∫•u h√¨nh g·ª£i √Ω theo h∆∞·ªõng');
            drawBalanceChart();
            alert('‚úÖ ƒê√£ l∆∞u c·∫•u h√¨nh g·ª£i √Ω theo h∆∞·ªõng!');
        }

        // T·∫£i c√†i ƒë·∫∑t G·ª£i √Ω theo H∆∞·ªõng
        function loadDirectionalSettings() {
            document.getElementById('suggestionByDirectionEnabled').checked = suggestionByDirectionEnabled;
            document.getElementById('suggestionByIntersectionEnabled').checked = suggestionByIntersectionEnabled;
            document.getElementById('suggestionBaseLine').value = suggestionBaseLine;
            document.getElementById('suggestionStartIndex').value = suggestionStartIndex;
            document.getElementById('directionConfirmationPoints').value = directionConfirmationPoints;
            
            // Kh√¥ng g·ªçi toggleSuggestionMode ·ªü ƒë√¢y, ƒë·ªÉ n√≥ ƒë∆∞·ª£c g·ªçi trong window.onload sau khi load settings c≈©
        }
        
        // H√†m c·∫≠p nh·∫≠t ƒëi·ªÉm b·∫Øt ƒë·∫ßu t·ª´ l·ªánh g·∫ßn nh·∫•t
        function updateStartIndexFromTrade() {
            if (balanceHistory.length === 0) {
                alert("Ch∆∞a c√≥ l·ªãch s·ª≠ giao d·ªãch ƒë·ªÉ l·∫•y ƒëi·ªÉm.");
                return;
            }
            // L·∫•y ch·ªâ s·ªë cu·ªëi c√πng (t∆∞∆°ng ƒë∆∞∆°ng l·ªánh ƒë√≥ng g·∫ßn nh·∫•t)
            const newStartIndex = balanceHistory.length - 1; 
            document.getElementById('suggestionStartIndex').value = newStartIndex;
            suggestionStartIndex = newStartIndex;
            localStorage.setItem('suggestionStartIndex', newStartIndex);
            
            lastDirectionalSuggestion = null; // Reset ƒë·ªÉ t√¨m h∆∞·ªõng m·ªõi ngay l·∫≠p t·ª©c
            localStorage.setItem('lastDirectionalSuggestion', null);

            saveDirectionalSettings(); // L∆∞u v√† k√≠ch ho·∫°t
            logStatus(`üîÑ C·∫≠p nh·∫≠t ƒëi·ªÉm b·∫Øt ƒë·∫ßu g·ª£i √Ω theo h∆∞·ªõng sang ƒëi·ªÉm cu·ªëi c√πng: #${newStartIndex}`);
        }

        // L∆∞u c√†i ƒë·∫∑t G·ª£i √Ω Giao nhau (ƒê·ªïi t√™n)
        function saveIntersectionSettings() {
            intersectionSettings.minSlope = parseFloat(document.getElementById('minSlope').value);
            intersectionSettings.minGapPct = parseFloat(document.getElementById('minGapPct').value);
            intersectionSettings.confirmDelay = parseInt(document.getElementById('confirmDelay').value);
            intersectionSettings.suggestionMode = document.getElementById('suggestionMode').value;
            
            localStorage.setItem('intersectionSettings', JSON.stringify(intersectionSettings));
            logStatus('üíæ ƒê√£ l∆∞u c·∫•u h√¨nh g·ª£i √Ω giao d·ªãch (Giao nhau)');
            alert('‚úÖ ƒê√£ l∆∞u c·∫•u h√¨nh g·ª£i √Ω giao nhau!');
        }

        // T·∫£i c√†i ƒë·∫∑t G·ª£i √Ω Giao nhau (ƒê·ªïi t√™n)
        function loadIntersectionSettings() {
            if (intersectionSettings) {
                document.getElementById('minSlope').value = intersectionSettings.minSlope;
                document.getElementById('minGapPct').value = intersectionSettings.minGapPct;
                document.getElementById('confirmDelay').value = intersectionSettings.confirmDelay;
                document.getElementById('suggestionMode').value = intersectionSettings.suggestionMode;
            }
        }
        
        // Reset d·ªØ li·ªáu G·ª£i √Ω v√† th·ªëng k√™
        function resetSuggestionData() {
            if (!confirm('B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën reset d·ªØ li·ªáu G·ª£i √Ω v√† Th·ªëng k√™?')) return;
            suggestionStats = {
                BUY: { total: 0, correct: 0, lastIndex: -1, lastTime: null, lastTradeIndex: -1 },
                SELL: { total: 0, correct: 0, lastIndex: -1, lastTime: null, lastTradeIndex: -1 }
            };
            lastDirectionalSuggestion = null;
            suggestionStartIndex = 0; // Reset index v·ªÅ 0

            localStorage.removeItem('suggestionStats');
            localStorage.removeItem('lastDirectionalSuggestion');
            localStorage.setItem('suggestionStartIndex', 0); // L∆∞u l·∫°i index
            
            document.getElementById('suggestionStartIndex').value = 0; // C·∫≠p nh·∫≠t UI
            document.getElementById('suggestionDisplay').innerHTML = 'Ch∆∞a c√≥ g·ª£i √Ω n√†o.';
            updateSuggestionStatsDisplay();
            logStatus('üîÑ ƒê√£ reset d·ªØ li·ªáu g·ª£i √Ω v√† th·ªëng k√™');
        }

        // L∆∞u c√†i ƒë·∫∑t giao d·ªãch
        function saveTradingSettings() {
            const settings = {
                virtualBalance: parseFloat(document.getElementById('virtualBalance').value),
                leverage: parseInt(document.getElementById('leverage').value),
                lotSize: parseFloat(document.getElementById('lotSize').value),
                stopLoss: parseFloat(document.getElementById('stopLoss').value),
                takeProfit: parseFloat(document.getElementById('takeProfit').value),
                tradesToday: tradesToday
            };
            localStorage.setItem('tradingSettings', JSON.stringify(settings));
            logStatus('üíæ ƒê√£ l∆∞u c√†i ƒë·∫∑t giao d·ªãch');
        }

        // T·∫£i c√†i ƒë·∫∑t giao d·ªãch
        function loadTradingSettings() {
            const settings = JSON.parse(localStorage.getItem('tradingSettings'));
            if (settings) {
                document.getElementById('virtualBalance').value = settings.virtualBalance || 1000;
                document.getElementById('leverage').value = settings.leverage || 10;
                document.getElementById('lotSize').value = settings.lotSize || 0.1;
                document.getElementById('stopLoss').value = settings.stopLoss || 50;
                document.getElementById('takeProfit').value = settings.takeProfit || 65;
                virtualBalance = settings.virtualBalance || 1000;
                tradesToday = settings.tradesToday || 0;
                updateStatus();
                logStatus('üîÑ ƒê√£ t·∫£i c√†i ƒë·∫∑t giao d·ªãch t·ª´ localStorage');
            }
        }

        // Reset d·ªØ li·ªáu v·ªÅ tr·∫°ng th√°i ban ƒë·∫ßu
        function resetData() {
            if (!confirm('B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën reset t·∫•t c·∫£ d·ªØ li·ªáu? M·ªçi c√†i ƒë·∫∑t v√† l·ªãch s·ª≠ s·∫Ω b·ªã x√≥a!')) return;

            // X√≥a c√°c m·ª•c c·∫ßn thi·∫øt trong localStorage
            localStorage.removeItem('tradingSettings');
            localStorage.removeItem('balanceHistory');
            localStorage.removeItem('intersectionSettings');
            localStorage.removeItem('suggestionStats');
            localStorage.removeItem('globalSoundUrl');
            localStorage.removeItem('soundUseStatus');
            localStorage.removeItem('defaultSoundsEnabled');
            // X√≥a c√†i ƒë·∫∑t m·ªõi
            localStorage.removeItem('suggestionByDirectionEnabled');
            localStorage.removeItem('suggestionByIntersectionEnabled');
            localStorage.removeItem('suggestionBaseLine');
            localStorage.removeItem('suggestionStartIndex');
            localStorage.removeItem('directionConfirmationPoints');
            localStorage.removeItem('lastDirectionalSuggestion');


            // Kh·ªüi t·∫°o l·∫°i c√°c bi·∫øn
            virtualBalance = 1000;
            tradesToday = 0;
            balanceHistory = [];
            currentTrades = [];
            alertLevels = [];
            alertedLevels.clear();
            alertedIntersectionIndices.clear();
            userGlobalNotifySound = null; 
            soundUseStatus = {};
            defaultSoundsEnabled = true;
            // Kh·ªüi t·∫°o l·∫°i bi·∫øn g·ª£i √Ω
            suggestionByDirectionEnabled = false;
            suggestionByIntersectionEnabled = false;
            suggestionBaseLine = 'balance';
            suggestionStartIndex = 0;
            directionConfirmationPoints = 3;
            lastDirectionalSuggestion = null;
            suggestionStats = {
                BUY: { total: 0, correct: 0, lastIndex: -1, lastTime: null, lastTradeIndex: -1 },
                SELL: { total: 0, correct: 0, lastIndex: -1, lastTime: null, lastTradeIndex: -1 }
            };

            // Reset UI
            loadTradingSettings(); // C√†i ƒë·∫∑t giao d·ªãch (s·∫Ω load gi√° tr·ªã m·∫∑c ƒë·ªãnh)
            loadIntersectionSettings(); // C√†i ƒë·∫∑t g·ª£i √Ω c≈© (s·∫Ω load gi√° tr·ªã m·∫∑c ƒë·ªãnh)
            loadDirectionalSettings(); // C√†i ƒë·∫∑t g·ª£i √Ω m·ªõi (s·∫Ω load gi√° tr·ªã m·∫∑c ƒë·ªãnh)

            document.getElementById('alertPrices').value = '';
            
            // Reset UI cho Sound Settings
            const checkboxes = document.querySelectorAll('.sound-checkboxes input[type="checkbox"]');
            checkboxes.forEach(cb => cb.checked = false);
            document.getElementById('globalNotifySoundInput').value = ''; // X√≥a file ƒë√£ ch·ªçn
            
            document.getElementById('historyList').innerHTML = '';
            document.getElementById('activeTrades').style.display = 'none';
            document.getElementById('currentTradeDetails').innerHTML = '';
            
            // Reset Sound Toggle
            loadSoundSettings(); // C·∫≠p nh·∫≠t l·∫°i n√∫t
            
            resetSuggestionData(); // Reset th·ªëng k√™ UI
            toggleSuggestionMode(); // C·∫≠p nh·∫≠t UI panel settings
            
            updateStatus();
            drawBalanceChart();
            logStatus('üîÑ ƒê√£ reset d·ªØ li·ªáu v·ªÅ tr·∫°ng th√°i ban ƒë·∫ßu');
        }

        // B·∫Øt ƒë·∫ßu giao d·ªãch t·ª± ƒë·ªông
        function startAutoTrading() {
            if (autoTradingActive) return;
            
            virtualBalance = parseFloat(document.getElementById('virtualBalance').value);
            autoTradingActive = true;
            saveTradingSettings();
            
            updateStatus();
            
            // QUAN TR·ªåNG: Th√™m d√≤ng n√†y ƒë·ªÉ ki·ªÉm tra l·ªánh m·ªói gi√¢y
            tradingInterval = setInterval(() => {
                checkTrades();
                checkPriceStagnation();
            }, 1000); 
            
            if (currentTrades.length === 0) {
                const waitForPrice = setInterval(() => {
                    if (currentPrice > 0) {
                        clearInterval(waitForPrice);
                        createNewTrades();
                    }
                }, 500);
            }
            
            logStatus('üöÄ B·∫Øt ƒë·∫ßu giao d·ªãch t·ª± ƒë·ªông');
        }

        function stopAutoTrading() {
            autoTradingActive = false;
            clearInterval(tradingInterval);
            saveTradingSettings();
            updateStatus();
            logStatus('üõë D·ª´ng giao d·ªãch t·ª± ƒë·ªông');
        }

        // T·∫°o l·ªánh m·ªõi (LOGIC G·ªêC M·ªû 2 L·ªÜNH BUY/SELL)
        function createNewTrades() {
             if (!autoTradingActive || currentPrice === 0 || virtualBalance < 100) {
                stopAutoTrading();
                return;
            }
            
            const price = currentPrice;
            const sl = parseFloat(document.getElementById('stopLoss').value);
            const tp = parseFloat(document.getElementById('takeProfit').value);
            const lotSize = parseFloat(document.getElementById('lotSize').value);
            const leverage = parseInt(document.getElementById('leverage').value);
            
            // TƒÉng tradesToday hai l·∫ßn ƒë·ªÉ c√≥ hai ch·ªâ s·ªë l·ªánh
            tradesToday++; 
            const tradeIndex1 = tradesToday;
            tradesToday++;
            const tradeIndex2 = tradesToday;

            currentTrades = [
                {
                    type: 'BUY',
                    entryPrice: price,
                    entryTime: new Date().toLocaleString('vi-VN'),
                    stopLoss: price - sl,
                    takeProfit: price + tp,
                    lotSize,
                    leverage,
                    closed: false,
                    tradeIndex: tradeIndex1
                },
                {
                    type: 'SELL',
                    entryPrice: price,
                    entryTime: new Date().toLocaleString('vi-VN'),
                    stopLoss: price + sl, // SELL: SL n·∫±m tr√™n gi√° v√†o
                    takeProfit: price - tp, // SELL: TP n·∫±m d∆∞·ªõi gi√° v√†o
                    lotSize,
                    leverage,
                    closed: false,
                    tradeIndex: tradeIndex2
                }
            ];
            
            document.getElementById('activeTrades').style.display = 'block';
            updateTradeInfo();
            
            playNotificationSound('open');
            addHistory(`M·ªü l·ªánh BUY #${tradeIndex1} @ ${price.toFixed(2)} | SL: ${(price - sl).toFixed(2)} | TP: ${(price + tp).toFixed(2)}`);
            addHistory(`M·ªü l·ªánh SELL #${tradeIndex2} @ ${price.toFixed(2)} | SL: ${(price + sl).toFixed(2)} | TP: ${(price - tp).toFixed(2)}`);
            
            logStatus(`üìà M·ªü 2 l·ªánh m·ªõi (BUY/SELL) @ ${price.toFixed(2)}`);
            saveTradingSettings();
        }
        
        // H√†m ki·ªÉm tra l·ªánh
        function checkTrades() {
            if (!autoTradingActive || currentTrades.length === 0 || isWaitingNewTrades) return;
            
            let allClosed = true;
            
            currentTrades.forEach(trade => {
                if (trade.closed) return;
                
                allClosed = false;
                let closeReason = '';
                
                // Ki·ªÉm tra SL
                if ((trade.type === 'BUY' && currentPrice <= trade.stopLoss) || 
                    (trade.type === 'SELL' && currentPrice >= trade.stopLoss)) {
                    closeReason = 'STOP LOSS';
                } 
                // Ki·ªÉm tra TP
                else if ((trade.type === 'BUY' && currentPrice >= trade.takeProfit) || 
                         (trade.type === 'SELL' && currentPrice <= trade.takeProfit)) {
                    closeReason = 'TAKE PROFIT';
                }
                
                if (closeReason) {
                    closeTrade(trade, currentPrice, closeReason);
                }
            });
            
            // N·∫øu c·∫£ hai l·ªánh ƒë·ªÅu ƒë√£ ƒë√≥ng, t·∫°o l·ªánh m·ªõi sau 3 gi√¢y
            if (allClosed && autoTradingActive) {
                currentTrades = []; // X√≥a c√°c l·ªánh ƒë√£ ƒë√≥ng
                isWaitingNewTrades = true;
                document.getElementById('activeTrades').style.display = 'none';
                updateStatus("ƒêang ch·ªù t·∫°o l·ªánh m·ªõi...");
                logStatus('‚è≥ ƒêang ch·ªù t·∫°o l·ªánh m·ªõi (3s)');
                
                setTimeout(() => {
                    createNewTrades();
                    isWaitingNewTrades = false;
                    updateStatus();
                }, 3000);
            }
        }

        // H√†m c·∫≠p nh·∫≠t m·ªëc c·∫£nh b√°o 
        function updateAlertLevels() {
            const input = document.getElementById('alertPrices').value;
            alertLevels = input.split(',')
                .map(p => parseFloat(p.trim()))
                .filter(p => !isNaN(p))
                .sort((a, b) => a - b); // S·∫Øp x·∫øp ƒë·ªÉ d·ªÖ ki·ªÉm tra
            alertedLevels.clear();
            logStatus('C·∫≠p nh·∫≠t m·ªëc c·∫£nh b√°o: ' + alertLevels.join(', '));
            alert('‚úÖ ƒê√£ l∆∞u m·ªëc gi√° c·∫£nh b√°o!');
        }

        // H√†m ki·ªÉm tra c·∫£nh b√°o gi√° 
        function checkPriceAlerts(oldPrice, newPrice) {
            if (alertLevels.length === 0 || oldPrice === 0 || oldPrice === newPrice) return;

            alertLevels.forEach(level => {
                // Ki·ªÉm tra gi√° c·∫Øt qua m·ªëc
                if ((oldPrice < level && newPrice >= level) ||
                    (oldPrice > level && newPrice <= level)) {
                    
                    addHistory(`üì¢ Gi√° ƒë√£ c·∫Øt qua m·ªëc ${level.toFixed(2)} (hi·ªán t·∫°i: ${newPrice.toFixed(2)})`);
                    playNotificationSound('alert');
                }
            });
        }
        
        // H√†m x√≥a l·ªãch s·ª≠ 
        function clearHistory() {
            document.getElementById('historyList').innerHTML = '';
            logStatus('üßπ ƒê√£ x√≥a l·ªãch s·ª≠ hi·ªÉn th·ªã');
        }

        // H√†m ph√¢n t√≠ch hi·ªáu su·∫•t (Gi·ªØ nguy√™n)
        function analyzeBalanceHistory() {
            if (!balanceHistory || balanceHistory.length === 0) {
                alert("Kh√¥ng c√≥ d·ªØ li·ªáu giao d·ªãch!");
                return;
            }

            let max = balanceHistory[0];
            let min = balanceHistory[0];
            let totalProfit = 0;
            let totalGoldPrice = 0;
            const closedTrades = balanceHistory;
            const tradesCount = closedTrades.length;

            if(tradesCount === 0) {
                 alert("Ch∆∞a c√≥ l·ªánh n√†o ƒë∆∞·ª£c ƒë√≥ng ƒë·ªÉ ph√¢n t√≠ch!");
                 return;
            }

            max = closedTrades[0];
            min = closedTrades[0];

            closedTrades.forEach(item => {
                if (item.balance > max.balance) max = item;
                if (item.balance < min.balance) min = item;
                totalProfit += item.profit;
                totalGoldPrice += item.goldPrice;
            });

            const maxIndex = closedTrades.findIndex(item => item === max) + 1;
            const minIndex = closedTrades.findIndex(item => item === min) + 1;
            
            const avgProfit = (totalProfit / tradesCount).toFixed(2);
            const avgGoldPrice = (totalGoldPrice / tradesCount).toFixed(2);
            const profitToGoldRatio = tradesCount > 0 ? ((totalProfit / tradesCount) / avgGoldPrice * 100).toFixed(2) : '0.00';

            alert(
                `üìà S·ªë d∆∞ cao nh·∫•t: ${max.balance.toFixed(2)} USD (L·ªánh #${max.tradeIndex}) (Gi√° V√†ng: ${max.goldPrice.toFixed(2)} USD)\n` +
                `üìâ S·ªë d∆∞ th·∫•p nh·∫•t: ${min.balance.toFixed(2)} USD (L·ªánh #${minIndex}) (Gi√° V√†ng: ${min.goldPrice.toFixed(2)} USD)\n\n` +
                `üí∞ L·ª£i nhu·∫≠n trung b√¨nh m·ªói l·ªánh: ${avgProfit} USD\n` +
                `üåü Gi√° V√†ng trung b√¨nh: ${avgGoldPrice} USD\n` +
                `üìä T·ª∑ l·ªá l·ª£i nhu·∫≠n so v·ªõi gi√° v√†ng (trung b√¨nh): ${profitToGoldRatio}%`
            );
        }
        
        // H√†m t√¨m ƒëi·ªÉm ƒë·∫£o chi·ªÅu g·∫ßn nh·∫•t sau khi trade ƒë√≥ng (d√πng l√†m suggestionStartIndex m·ªõi)
        function findNearestDirectionChangeIndex(dataArray, closeIndex, tradeType) {
            if (closeIndex < 2) return 0;
            
            // H∆∞·ªõng k·ª≥ v·ªçng c·ªßa trade v·ª´a ƒë√≥ng
            const currentDirection = tradeType; 

            // T√¨m ƒëi·ªÉm (i) m√† h∆∞·ªõng ƒëi c·ªßa dataArray[i-1] ƒë·∫øn dataArray[i] NG∆Ø·ª¢C v·ªõi currentDirection
            for (let i = closeIndex - 1; i >= 1; i--) {
                const diff = dataArray[i] - dataArray[i-1];
                
                let direction = diff >= 0 ? 'BUY' : 'SELL';
                
                // N·∫øu h∆∞·ªõng ƒë·ªïi ng∆∞·ª£c l·∫°i so v·ªõi l·ªánh v·ª´a ƒë√≥ng
                if (direction !== currentDirection) {
                    // Tr·∫£ v·ªÅ ƒëi·ªÉm ƒë·∫£o chi·ªÅu (i-1 l√† ƒëi·ªÉm tr∆∞·ªõc khi ƒë·∫£o chi·ªÅu)
                    // C·∫≠p nh·∫≠t ƒëi·ªÉm b·∫Øt ƒë·∫ßu l√† ƒëi·ªÉm ngay sau ƒëi·ªÉm ƒë·∫£o chi·ªÅu (t·ª©c l√† i)
                    return i; 
                }
            }
            // N·∫øu kh√¥ng t√¨m th·∫•y, tr·∫£ v·ªÅ 0 (b·∫Øt ƒë·∫ßu l·∫°i)
            return 0;
        }

        // ƒê√≥ng l·ªánh 
        function closeTrade(trade, closePrice, reason) {
            const profit = trade.type === 'BUY'
                ? (closePrice - trade.entryPrice) * trade.lotSize * trade.leverage
                : (trade.entryPrice - closePrice) * trade.lotSize * trade.leverage;
            
            trade.closed = true;
            trade.exitPrice = closePrice;
            trade.exitTime = new Date().toLocaleString('vi-VN');
            trade.profit = profit;
            trade.closeReason = reason;
            virtualBalance += profit;
            // tradesToday ƒë√£ ƒë∆∞·ª£c tƒÉng trong createNewTrades, kh√¥ng c·∫ßn tƒÉng ·ªü ƒë√¢y n·ªØa.

            // C·∫≠p nh·∫≠t th·ªëng k√™ g·ª£i √Ω d·ª±a tr√™n tradeIndex
            updateSuggestionStats(trade, profit);
            
            balanceHistory.push({
                time: new Date(),
                balance: virtualBalance,
                profit: profit,
                reason: reason,
                type: trade.type,
                entryPrice: trade.entryPrice,
                closePrice: closePrice,
                goldPrice: currentPrice,
                lotSize: trade.lotSize,
                tradeIndex: trade.tradeIndex // Th√™m index ƒë·ªÉ tham chi·∫øu
            });
            
            // ************* LOGIC C·∫¨P NH·∫¨T G·ª¢I √ù THEO H∆Ø·ªöNG *************
            if (suggestionByDirectionEnabled) {
                const dsBalance = balanceHistory.map(item => item.balance);
                const dsGold = balanceHistory.map(item => item.goldPrice);
                const dataArray = (suggestionBaseLine === 'balance' ? dsBalance : dsGold);
                
                // Index c·ªßa ƒëi·ªÉm g·∫ßn nh·∫•t (ƒëi·ªÉm ƒë√≥ng l·ªánh) trong balanceHistory
                const closeIndex = balanceHistory.length - 1; 
                
                // T√¨m ƒëi·ªÉm ƒë·∫£o chi·ªÅu m·ªõi
                const newStartIndex = findNearestDirectionChangeIndex(dataArray, closeIndex, trade.type);
                
                suggestionStartIndex = newStartIndex; // C·∫≠p nh·∫≠t ch·ªâ s·ªë m·ªõi
                lastDirectionalSuggestion = null; // Reset g·ª£i √Ω ƒë·ªÉ t√¨m h∆∞·ªõng m·ªõi
                
                // L∆∞u l·∫°i
                localStorage.setItem('suggestionStartIndex', suggestionStartIndex);
                localStorage.setItem('lastDirectionalSuggestion', null);
                
                logStatus(`üîÑ G·ª£i √Ω Theo H∆∞·ªõng: L·ªánh ${trade.type} ƒë√≥ng. C·∫≠p nh·∫≠t ƒëi·ªÉm b·∫Øt ƒë·∫ßu sang #${newStartIndex}`);
            }
            // *************************************************************

            localStorage.setItem('balanceHistory', JSON.stringify(balanceHistory));
            saveTradingSettings();

            drawBalanceChart();

            if (reason === 'TAKE PROFIT') {
                playNotificationSound('tp');
            } else if (reason === 'STOP LOSS') {
                playNotificationSound('sl');
            }
            
            addHistory(
                `ƒê√≥ng l·ªánh ${trade.type} #${trade.tradeIndex} @ ${closePrice.toFixed(2)} (${reason}) | ` +
                `L·ª£i nhu·∫≠n: <span class="${profit >= 0 ? 'profit' : 'loss'}">${profit.toFixed(2)} USD</span> | ` +
                `S·ªë d∆∞: ${virtualBalance.toFixed(2)} USD`
            );
            
            updateTradeInfo();
            updateStatus();
            
            logStatus(
                `üìâ ƒê√≥ng l·ªánh ${trade.type} #${trade.tradeIndex} (${reason}) | ` +
                `L·ª£i nhu·∫≠n: ${profit.toFixed(2)} USD | ` +
                `S·ªë d∆∞ m·ªõi: ${virtualBalance.toFixed(2)} USD`
            );
        }

        // C·∫≠p nh·∫≠t th·ªëng k√™ g·ª£i √Ω 
        function updateSuggestionStats(trade, profit) {
            const currentTradeIndex = trade.tradeIndex;
            const type = trade.type; 

            // Ki·ªÉm tra ch·ªâ khi tradeIndex l·ªõn h∆°n lastTradeIndex c·ªßa g·ª£i √Ω c√πng lo·∫°i
            // Ho·∫∑c l√† trade ƒë·∫ßu ti√™n (lastTradeIndex = -1)
            if (suggestionStats[type].lastTradeIndex === -1 || currentTradeIndex > suggestionStats[type].lastTradeIndex) {
                 // N·∫øu ƒë√¢y l√† trade ƒë·∫ßu ti√™n sau khi c√≥ g·ª£i √Ω (ho·∫∑c trade ƒë·∫ßu ti√™n sau reset)
                 if (currentTradeIndex > suggestionStats[type].lastTradeIndex) {
                     suggestionStats[type].total++;
                     if (profit > 0) {
                         suggestionStats[type].correct++;
                     }
                 }
                suggestionStats[type].lastTradeIndex = currentTradeIndex;
            } 
            
            localStorage.setItem('suggestionStats', JSON.stringify(suggestionStats));
            updateSuggestionStatsDisplay();
        }

        // C·∫≠p nh·∫≠t hi·ªÉn th·ªã th·ªëng k√™ g·ª£i √Ω 
        function updateSuggestionStatsDisplay() {
            const buyTotal = suggestionStats.BUY.total;
            const buyCorrect = suggestionStats.BUY.correct;
            const sellTotal = suggestionStats.SELL.total;
            const sellCorrect = suggestionStats.SELL.correct;

            const buyPct = buyTotal > 0 ? ((buyCorrect / buyTotal) * 100).toFixed(2) : '0.00';
            const sellPct = sellTotal > 0 ? ((sellCorrect / sellTotal) * 100).toFixed(2) : '0.00';

            document.getElementById('statBuyTotal').textContent = buyTotal;
            document.getElementById('statBuyCorrect').textContent = buyCorrect;
            document.getElementById('statBuyPct').textContent = buyPct + '%';

            document.getElementById('statSellTotal').textContent = sellTotal;
            document.getElementById('statSellCorrect').textContent = sellCorrect;
            document.getElementById('statSellPct').textContent = sellPct + '%';
        }

        // V·∫Ω bi·ªÉu ƒë·ªì s·ªë d∆∞ v√† gi√° v√†ng 
        function drawBalanceChart() {
            if (!balanceHistory || balanceHistory.length === 0) {
                if (balanceChart) balanceChart.destroy();
                return;
            }
            const ctx = document.getElementById('balanceChart').getContext('2d');
            const labels = balanceHistory.map(item => new Date(item.time).toLocaleTimeString('vi-VN'));
            const balances = balanceHistory.map(item => item.balance);
            const goldPrices = balanceHistory.map(item => item.goldPrice);

            if (balanceChart) balanceChart.destroy();

            balanceChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'S·ªë D∆∞ (USD)',
                            data: balances,
                            borderColor: '#0ecb81',
                            backgroundColor: 'rgba(14, 203, 129, 0.1)',
                            tension: 0.2,
                            fill: true,
                            yAxisID: 'y'
                        },
                        {
                            label: 'Gi√° V√†ng (XAU/USD)',
                            data: goldPrices,
                            borderColor: '#d4af37',
                            backgroundColor: 'rgba(212, 175, 55, 0.1)',
                            tension: 0.2,
                            fill: false,
                            yAxisID: 'y1'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            title: {
                                display: true,
                                text: 'S·ªë D∆∞ (USD)'
                            }
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            title: {
                                display: true,
                                text: 'Gi√° V√†ng (USD)'
                            },
                            grid: {
                                drawOnChartArea: false
                            }
                        }
                    }
                }
            });

            setTimeout(() => {
                detectBalanceGoldIntersections();
                
                if (suggestionByDirectionEnabled) {
                    checkDirectionalSuggestion(); // K√≠ch ho·∫°t g·ª£i √Ω theo h∆∞·ªõng M·ªöI
                } else if (suggestionByIntersectionEnabled) {
                     checkIntersectionSuggestion(); // K√≠ch ho·∫°t g·ª£i √Ω theo giao nhau C≈®
                } else {
                     document.getElementById('suggestionDisplay').innerHTML = 'Ch∆∞a c√≥ ch·∫ø ƒë·ªô g·ª£i √Ω n√†o ƒë∆∞·ª£c b·∫≠t.';
                }
            }, 100);
        }

        // Logic G·ª£i √Ω giao d·ªãch GIAO NHAU C≈® (ƒê√£ ƒë·ªïi t√™n)
        function checkIntersectionSuggestion() {
            if (!balanceChart || !suggestionByIntersectionEnabled) return;

            const dsBalance = balanceChart.data.datasets[0].data;
            const dsGold = balanceChart.data.datasets[1].data;
            const len = Math.min(dsBalance.length, dsGold.length);
            const { minSlope, minGapPct, confirmDelay, suggestionMode } = intersectionSettings;

            if (len < confirmDelay + 1) return;

            // L·∫•y d·ªØ li·ªáu g·∫ßn nh·∫•t (ch√∫ √Ω: ƒë√¢y l√† d·ªØ li·ªáu t·ª´ Balance History, kh√¥ng ph·∫£i real-time)
            const i = len - 1;
            const balanceNow = dsBalance[i];
            const goldNow = dsGold[i];
            const balancePrev = dsBalance[i - confirmDelay];
            const goldPrev = dsGold[i - confirmDelay];
            
            const timeLabel = balanceChart.data.labels[i];
            
            let suggestion = null;
            let reason = '';
            
            // T√≠nh to√°n ƒë·ªô d·ªëc (Slope) trung b√¨nh trong kho·∫£ng confirmDelay
            const balanceSlope = (balanceNow - balancePrev) / confirmDelay;
            const goldSlope = (goldNow - goldPrev) / confirmDelay;

            // T√≠nh kho·∫£ng c√°ch ph·∫ßn trƒÉm (Gap Percentage)
            const gapPct = ((balanceNow - goldNow) / goldNow) * 100;
            const prevGapPct = ((balancePrev - goldPrev) / goldPrev) * 100;

            const isCrossoverUp = (prevGapPct < 0 && gapPct >= 0); // V√†ng c·∫Øt l√™n S·ªë d∆∞
            const isCrossoverDown = (prevGapPct > 0 && gapPct <= 0); // V√†ng c·∫Øt xu·ªëng S·ªë d∆∞

            // 1. Logic C·∫Øt L√™n/Xu·ªëng & Xu h∆∞·ªõng (G·ª£i √Ω MUA/B√ÅN)
            if (isCrossoverUp) {
                if (goldSlope > minSlope) {
                    suggestion = 'BUY';
                    reason = 'Gi√° V√†ng c·∫Øt l√™n S·ªë D∆∞ v√† tƒÉng m·∫°nh.';
                } else if (goldSlope > 0) {
                    suggestion = 'BUY';
                    reason = 'Gi√° V√†ng c·∫Øt l√™n S·ªë D∆∞ (xu h∆∞·ªõng tƒÉng).';
                }
            } else if (isCrossoverDown) {
                if (goldSlope < -minSlope) {
                    suggestion = 'SELL';
                    reason = 'Gi√° V√†ng c·∫Øt xu·ªëng S·ªë D∆∞ v√† gi·∫£m m·∫°nh.';
                } else if (goldSlope < 0) {
                    suggestion = 'SELL';
                    reason = 'Gi√° V√†ng c·∫Øt xu·ªëng S·ªë D∆∞ (xu h∆∞·ªõng gi·∫£m).';
                }
            }
            
            // 2. Logic ƒê·∫£o Chi·ªÅu (G·ª£i √Ω MUA/B√ÅN M·∫°nh)
            if (!suggestion) {
                // ƒê·∫£o chi·ªÅu MUA: V√†ng ƒë√£ n·∫±m d∆∞·ªõi S·ªë d∆∞, nh∆∞ng ƒëang tƒÉng m·∫°nh
                if (gapPct < -minGapPct && goldSlope > minSlope * 2) { 
                    suggestion = 'STRONG BUY';
                    reason = 'Gi√° V√†ng gi·∫£m s√¢u d∆∞·ªõi S·ªë D∆∞, kh·∫£ nƒÉng b·∫≠t tƒÉng m·∫°nh.';
                }
                // ƒê·∫£o chi·ªÅu B√ÅN: V√†ng ƒë√£ n·∫±m tr√™n S·ªë d∆∞, nh∆∞ng ƒëang gi·∫£m m·∫°nh
                else if (gapPct > minGapPct && goldSlope < -minSlope * 2) {
                    suggestion = 'STRONG SELL';
                    reason = 'Gi√° V√†ng tƒÉng cao tr√™n S·ªë D∆∞, kh·∫£ nƒÉng ƒë·∫£o chi·ªÅu gi·∫£m m·∫°nh.';
                }
            }

            // L·ªçc theo Ch·∫ø ƒë·ªô hi·ªÉn th·ªã
            if (suggestionMode !== 'all') {
                if (suggestion && !suggestion.includes(suggestionMode.toUpperCase())) {
                    suggestion = null;
                }
            }

            // C·∫≠p nh·∫≠t m√†n h√¨nh & Th·ªëng k√™
            if (suggestion && suggestionStats[suggestion.replace('STRONG ', '')].lastIndex !== i) {
                const type = suggestion.includes('BUY') ? 'BUY' : 'SELL';
                
                // C·∫≠p nh·∫≠t th·ªëng k√™ v√† ƒë√°nh d·∫•u ƒë√£ g·ª£i √Ω t·∫°i ƒëi·ªÉm n√†y
                suggestionStats[type].lastIndex = i;
                suggestionStats[type].lastTime = timeLabel;
                
                localStorage.setItem('suggestionStats', JSON.stringify(suggestionStats));
                
                // Hi·ªÉn th·ªã
                const display = document.getElementById('suggestionDisplay');
                const className = suggestion.includes('BUY') ? 'suggest-buy' : 'suggest-sell';
                display.innerHTML = `<div class="${className}">${timeLabel} | **${suggestion}** | L√Ω do: ${reason} (Ch·∫ø ƒë·ªô Giao nhau)</div>`;
                
                logStatus(`üì¢ ${suggestion} G·ª£i √Ω | L√Ω do: ${reason}`);
                playNotificationSound('suggestion');
                
                // C·∫≠p nh·∫≠t ch·ªâ s·ªë l·ªánh g·∫ßn nh·∫•t
                suggestionStats[type].lastTradeIndex = tradesToday; 
            } else if (suggestion === null && !suggestionByDirectionEnabled) {
                 document.getElementById('suggestionDisplay').innerHTML = 'Ch∆∞a c√≥ g·ª£i √Ω n√†o.';
            }
        }
        
        // Logic G·ª£i √Ω giao d·ªãch THEO H∆Ø·ªöNG M·ªöI
        function checkDirectionalSuggestion() {
            if (!balanceChart || !suggestionByDirectionEnabled) return;
            
            const dsBalance = balanceChart.data.datasets[0].data;
            const dsGold = balanceChart.data.datasets[1].data;
            const dataArray = (suggestionBaseLine === 'balance' ? dsBalance : dsGold);
            const len = dataArray.length;
            
            // Ki·ªÉm tra ƒë·ªß ƒëi·ªÉm d·ªØ li·ªáu
            if (len <= suggestionStartIndex + directionConfirmationPoints) {
                document.getElementById('suggestionDisplay').innerHTML = 'Ch∆∞a ƒë·ªß d·ªØ li·ªáu ƒë·ªÉ t√≠nh h∆∞·ªõng t·ª´ ƒëi·ªÉm b·∫Øt ƒë·∫ßu.';
                return;
            }
            
            const startIndex = suggestionStartIndex;
            const endIndex = len - 1; // ƒêi·ªÉm cu·ªëi c√πng trong m·∫£ng
            const confirmPoints = directionConfirmationPoints;
            
            // 1. T√≠nh to√°n H∆Ø·ªöNG
            // L·∫•y gi√° tr·ªã t·∫°i ƒëi·ªÉm b·∫Øt ƒë·∫ßu
            const startValue = dataArray[startIndex];
            
            // L·∫•y gi√° tr·ªã t·∫°i ƒëi·ªÉm x√°c nh·∫≠n (c√°ch ƒëi·ªÉm cu·ªëi c√πng 1 kho·∫£ng confirmPoints)
            const confirmationIndex = endIndex - confirmPoints;
            if (confirmationIndex < startIndex) {
                document.getElementById('suggestionDisplay').innerHTML = 'Ch∆∞a ƒë·ªß ƒëi·ªÉm x√°c nh·∫≠n h∆∞·ªõng.';
                return;
            }
            const confirmationValue = dataArray[confirmationIndex];
            
            let currentSuggestion = null;
            let reason = '';
            
            if (confirmationValue > startValue) {
                currentSuggestion = 'BUY';
                reason = `ƒê∆∞·ªùng **${suggestionBaseLine === 'balance' ? 'S·ªë D∆∞' : 'Gi√° V√†ng'}** ƒëang ƒëi l√™n t·ª´ ƒëi·ªÉm #${startIndex} (${startValue.toFixed(2)} -> ${confirmationValue.toFixed(2)})`;
            } else if (confirmationValue < startValue) {
                currentSuggestion = 'SELL';
                reason = `ƒê∆∞·ªùng **${suggestionBaseLine === 'balance' ? 'S·ªë D∆∞' : 'Gi√° V√†ng'}** ƒëang ƒëi xu·ªëng t·ª´ ƒëi·ªÉm #${startIndex} (${startValue.toFixed(2)} -> ${confirmationValue.toFixed(2)})`;
            } else {
                document.getElementById('suggestionDisplay').innerHTML = 'ƒê∆∞·ªùng c∆° s·ªü ch∆∞a thay ƒë·ªïi h∆∞·ªõng r√µ r·ªát.';
                return;
            }
            
            // 2. C·∫≠p nh·∫≠t M√†n h√¨nh & Th·ªëng k√™ n·∫øu G·ª£i √Ω KH√ÅC g·ª£i √Ω tr∆∞·ªõc ƒë√≥
            if (currentSuggestion && currentSuggestion !== lastDirectionalSuggestion) {
                const type = currentSuggestion;
                const timeLabel = balanceChart.data.labels[endIndex];
                
                // C·∫≠p nh·∫≠t th·ªëng k√™ v√† ƒë√°nh d·∫•u ƒë√£ g·ª£i √Ω t·∫°i ƒëi·ªÉm n√†y (ch·ªâ c·∫ßn c·∫≠p nh·∫≠t n·∫øu h∆∞·ªõng ƒë·ªïi)
                suggestionStats[type].lastIndex = endIndex;
                suggestionStats[type].lastTime = timeLabel;
                
                localStorage.setItem('suggestionStats', JSON.stringify(suggestionStats));
                
                // Hi·ªÉn th·ªã
                const display = document.getElementById('suggestionDisplay');
                const className = type === 'BUY' ? 'suggest-buy' : 'suggest-sell';
                display.innerHTML = `<div class="${className}">${timeLabel} | **${currentSuggestion}** | L√Ω do: ${reason} (Ch·∫ø ƒë·ªô Theo H∆∞·ªõng)</div>`;
                
                logStatus(`üì¢ **${currentSuggestion}** G·ª£i √Ω Theo H∆∞·ªõng | ${reason}`);
                playNotificationSound('suggestion');
                
                // C·∫≠p nh·∫≠t bi·∫øn tr·∫°ng th√°i v√† l∆∞u localStorage
                lastDirectionalSuggestion = currentSuggestion;
                localStorage.setItem('lastDirectionalSuggestion', lastDirectionalSuggestion);
                
                // C·∫≠p nh·∫≠t ch·ªâ s·ªë l·ªánh g·∫ßn nh·∫•t (ƒë·ªÉ th·ªëng k√™ l·ªánh th√†nh c√¥ng/th·∫•t b·∫°i)
                suggestionStats[type].lastTradeIndex = tradesToday; 
            } else if (currentSuggestion === lastDirectionalSuggestion) {
                // C·∫≠p nh·∫≠t hi·ªÉn th·ªã ƒë·ªÉ ng∆∞·ªùi d√πng bi·∫øt g·ª£i √Ω v·∫´n ƒëang ho·∫°t ƒë·ªông (kh√¥ng c·∫ßn √¢m thanh)
                const display = document.getElementById('suggestionDisplay');
                const className = currentSuggestion === 'BUY' ? 'suggest-buy' : 'suggest-sell';
                display.innerHTML = `<div class="${className}">${balanceChart.data.labels[endIndex]} | **${currentSuggestion}** | L√Ω do: ${reason} (V·∫´n gi·ªØ h∆∞·ªõng)</div>`;
            }
        }


        // Ph√°t hi·ªán giao nhau gi·ªØa s·ªë d∆∞ v√† gi√° v√†ng 
        function detectBalanceGoldIntersections() {
            if (!balanceChart) return;
            
            const dsBalance = balanceChart.data.datasets[0].data;
            const dsGold = balanceChart.data.datasets[1].data;
            const len = Math.min(dsBalance.length, dsGold.length);
            
            for (let i = 1; i < len; i++) {
                try {
                    const prevDiff = dsBalance[i-1] - dsGold[i-1];
                    const curDiff = dsBalance[i] - dsGold[i];
                    
                    if ((prevDiff <= 0 && curDiff > 0) || // S·ªë d∆∞ c·∫Øt l√™n V√†ng (prevDiff √¢m, curDiff d∆∞∆°ng)
                        (prevDiff >= 0 && curDiff < 0)) { // S·ªë d∆∞ c·∫Øt xu·ªëng V√†ng (prevDiff d∆∞∆°ng, curDiff √¢m)
                        
                        if (!alertedIntersectionIndices.has(i)) {
                            alertedIntersectionIndices.add(i);
                            addHistory(`üîî Giao nhau S·ªë D∆∞ & Gi√° V√†ng t·∫°i ${balanceChart.data.labels[i] || ''}`);
                            playNotificationSound('intersection');
                        }
                    }
                } catch(e) {
                    console.error("L·ªói khi ph√°t hi·ªán giao nhau:", e);
                }
            }
        }

        // C·∫≠p nh·∫≠t th√¥ng tin l·ªánh 
        function updateTradeInfo() {
            const container = document.getElementById('currentTradeDetails');
            if (!container) return;
            
            container.innerHTML = '';
            
            // L·ªçc ra c√°c l·ªánh ƒëang m·ªü (closed: false)
            const activeTrades = currentTrades.filter(trade => !trade.closed);
            
            // Ch·ªâ hi·ªÉn th·ªã c√°c l·ªánh ƒëang m·ªü
            const tradesToDisplay = activeTrades;

            if (tradesToDisplay.length === 0) {
                 document.getElementById('activeTrades').style.display = 'none';
                 return;
            }

             document.getElementById('activeTrades').style.display = 'block';
            
            tradesToDisplay.forEach(trade => {
                const price = currentPrice; // ƒê·∫£m b·∫£o d√πng currentPrice m·ªõi nh·∫•t
                let profit = 0;
                
                if (!trade.closed) {
                    // T√≠nh l·ª£i nhu·∫≠n hi·ªán t·∫°i
                    profit = trade.type === 'BUY'
                        ? (price - trade.entryPrice) * trade.lotSize * trade.leverage
                        : (trade.entryPrice - price) * trade.lotSize * trade.leverage;
                } else {
                    profit = trade.profit || 0;
                }
                
                const profitClass = profit >= 0 ? 'profit' : 'loss';

                const tradeBox = document.createElement('div');
                tradeBox.className = `trade-box ${trade.type.toLowerCase()}`;
                tradeBox.innerHTML = `
                    <h3>${trade.type} #${trade.tradeIndex} ${trade.closed ? `(ƒê√É ƒê√ìNG - ${trade.closeReason})` : '(ƒêANG M·ªû)'}</h3>
                    <p>Gi√° v√†o: ${trade.entryPrice.toFixed(2)}</p>
                    <p>Gi√° hi·ªán t·∫°i: ${trade.closed ? trade.exitPrice.toFixed(2) : price.toFixed(2)}</p>
                    <p>L·ª£i nhu·∫≠n: <span class="${profitClass}">${profit.toFixed(2)} USD</span></p>
                    <p>SL: ${trade.stopLoss.toFixed(2)} | TP: ${trade.takeProfit.toFixed(2)}</p>
                    ${trade.closed ? `<p>Th·ªùi gian ƒë√≥ng: ${trade.exitTime}</p>` : ''}
                `;
                
                container.appendChild(tradeBox);
            });
        }
        
        // C·∫≠p nh·∫≠t tr·∫°ng th√°i 
        function updateStatus(extra = "") {
            let status = autoTradingActive ? "ƒêang giao d·ªãch t·ª± ƒë·ªông" : "ƒê√£ d·ª´ng";
            if (extra) status += " | " + extra;
            
            document.getElementById('statusText').textContent = status;
            document.getElementById('balanceText').textContent = virtualBalance.toFixed(2);
            document.getElementById('tradesCount').textContent = tradesToday;
        }

        // Th√™m v√†o l·ªãch s·ª≠ 
        function addHistory(message) {
            const now = new Date();
            const timeString = now.toLocaleTimeString('vi-VN');
            
            const historyList = document.getElementById('historyList');
            const historyItem = document.createElement('div');
            historyItem.className = 'history-item';
            historyItem.innerHTML = `<strong>${timeString}:</strong> ${message}`;
            
            // Ch·ªâ gi·ªØ l·∫°i 50 m·ª•c l·ªãch s·ª≠ g·∫ßn nh·∫•t
            if (historyList.children.length >= 50) {
                 historyList.removeChild(historyList.lastChild);
            }
            historyList.insertBefore(historyItem, historyList.firstChild);
        }

        // Kh·ªüi ƒë·ªông ·ª©ng d·ª•ng
        window.onload = function() {
            loadTradingSettings();
            loadSoundSettings();
            loadIntersectionSettings(); // T·∫£i c√†i ƒë·∫∑t giao nhau C≈®
            loadDirectionalSettings(); // T·∫£i c√†i ƒë·∫∑t theo h∆∞·ªõng M·ªöI
            
            initChart();
            connectWebSocket();
            updateAlertLevels(); // G·ªåI H√ÄM C·∫¨P NH·∫¨T M·ªêC C·∫¢NH B√ÅO
            updateStatus();
            addHistory('üîÑ ·ª®ng d·ª•ng kh·ªüi ƒë·ªông');
            
            // Listeners cho C√†i ƒë·∫∑t giao d·ªãch
            ['virtualBalance', 'leverage', 'lotSize', 'stopLoss', 'takeProfit'].forEach(id => {
                document.getElementById(id).addEventListener('change', saveTradingSettings);
            });
            
            // Listener cho M·ªëc c·∫£nh b√°o
            document.getElementById('alertPrices').addEventListener('change', updateAlertLevels);
            
            // Listeners cho C√†i ƒë·∫∑t G·ª£i √Ω Giao nhau (C≈®)
            ['minSlope', 'minGapPct', 'confirmDelay', 'suggestionMode'].forEach(id => {
                document.getElementById(id).addEventListener('change', saveIntersectionSettings);
            });
            
            // Listeners cho C√†i ƒë·∫∑t G·ª£i √Ω Theo H∆∞·ªõng (M·ªöI)
             ['suggestionBaseLine', 'suggestionStartIndex', 'directionConfirmationPoints'].forEach(id => {
                document.getElementById(id).addEventListener('change', saveDirectionalSettings);
            });
            
            // Listener cho File Input ƒë·ªÉ l∆∞u file ngay sau khi ch·ªçn (tr∆∞·ªõc khi nh·∫•n L∆∞u C·∫•u H√¨nh)
            document.getElementById('globalNotifySoundInput').addEventListener('change', function() {
                // L∆∞u file ngay sau khi ch·ªçn (tr√°nh m·∫•t file khi refresh)
                saveAllSoundSettings(); 
            });
            
            // G·ªçi l·∫°i toggleSuggestionMode ƒë·ªÉ thi·∫øt l·∫≠p UI/logic ƒë√∫ng ngay khi t·∫£i
            toggleSuggestionMode();
        };
    </script>
</body>
</html>
