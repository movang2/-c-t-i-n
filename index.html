<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Pro Gold Combo</title>
<style>
body {
  font-family: 'Arial', sans-serif;
  margin: 0;
  padding: 0;
  background: #f8f9fa;
}
header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  background: #1e2026;
  color: white;
  padding: 10px 20px;
}
.tab-buttons {
  display: flex;
  gap: 10px;
}
.tab-buttons button {
  background: #d4af37;
  color: #1e2026;
  border: none;
  padding: 10px 15px;
  border-radius: 6px;
  cursor: pointer;
  font-weight: bold;
}
.tab-buttons button.active {
  background: #0ecb81;
  color: white;
}
.tab-content {
  display: none;
  padding: 0;
}
.tab-content.active {
  display: block;
}
#transferDataBtn {
  background: #0ecb81;
  color: white;
  border: none;
  padding: 8px 12px;
  border-radius: 5px;
  cursor: pointer;
  font-weight: bold;
}
</style>
</head>
<body>

<header>
  <div class="tab-buttons">
    <button id="liveTabBtn" class="active">üü° Giao d·ªãch tr·ª±c ti·∫øp</button>
    <button id="replayTabBtn">üü¢ Ph√°t l·∫°i bi·ªÉu ƒë·ªì</button>
  </div>
  <button id="transferDataBtn">Chuy·ªÉn d·ªØ li·ªáu sang ph√°t l·∫°i</button>
</header>

<div id="liveTab" class="tab-content active">
<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Giao D·ªãch V√†ng (XAU/USD) - Finnhub (Directional Suggestion)</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f8f9fa;
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
            padding: 20px;
        }
        h1 {
            color: #d4af37;
            text-align: center;
            margin-bottom: 30px;
        }
        .panel {
            background: #fafafa;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            border: 1px solid #eee;
        }
        .panel-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 15px;
            color: #333;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }
        .control-group {
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            flex-wrap: wrap; /* Cho ph√©p xu·ªëng d√≤ng tr√™n m√†n h√¨nh nh·ªè */
        }
        label {
            display: inline-block;
            width: 150px;
            margin-bottom: 5px;
            font-weight: 500;
        }
        input[type="file"], input[type="text"], input[type="number"], select {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            width: 200px;
        }
        input[type="checkbox"] {
            width: auto;
            margin-right: 5px;
        }
        .checkbox-label {
            width: 200px; 
            margin-left: 5px;
            margin-right: 20px;
        }
        button {
            background-color: #d4af37;
            color: #1e2026;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            margin-right: 10px;
            transition: all 0.3s;
        }
        button:hover {
            background-color: #e5c046;
        }
        button.danger {
            background-color: #f6465d;
            color: white;
        }
        button.danger:hover {
            background-color: #ff6b81;
        }
        .price-display {
            font-size: 24px;
            font-weight: bold;
            text-align: center;
            margin: 20px 0;
            color: #d4af37;
        }
        .chart-container {
            height: 400px;
            margin-bottom: 30px;
        }
        .trade-info {
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
        }
        .trade-box {
            width: 48%;
            background: #fff;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
            border-left: 4px solid #d4af37;
        }
        .trade-box.sell {
            border-left-color: #f6465d;
        }
        .profit {
            color: #0ecb81;
            font-weight: bold;
        }
        .loss {
            color: #f6465d;
            font-weight: bold;
        }
        #historyList {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #eee;
            border-radius: 4px;
            padding: 10px;
        }
        .history-item {
            padding: 8px 0;
            border-bottom: 1px solid #f5f5f5;
        }
        .status-bar {
            background: #1e2026;
            color: white;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
        }
        .suggestion-box {
            font-size: 16px;
            padding: 10px;
            margin-top: 10px;
            border-radius: 4px;
            font-weight: bold;
            text-align: center;
        }
        .suggest-buy {
            background-color: #d1ffc9;
            color: #0ecb81;
            border: 1px solid #0ecb81;
        }
        .suggest-sell {
            background-color: #ffd4d4;
            color: #f6465d;
            border: 1px solid #f6465d;
        }
        .stats-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            font-size: 14px;
        }
        .stats-table th, .stats-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        .stats-table th {
            background-color: #e9ecef;
        }
        .sound-checkboxes {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 15px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .sound-checkbox-item {
            display: flex;
            align-items: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Giao D·ªãch V√†ng (XAU/USD) - Finnhub</h1>
        
        <div class="status-bar" id="tradingStatus">
            <div>Tr·∫°ng th√°i: <span id="statusText">Ch∆∞a b·∫Øt ƒë·∫ßu</span></div>
            <div>S·ªë d∆∞: <span id="balanceText">1000.00</span> USD</div>
            <div>L·ªánh h√¥m nay: <span id="tradesCount">0</span></div>
        </div>
        
        <div class="price-display">
            Gi√° XAU/USD hi·ªán t·∫°i: <span id="currentPrice">0.00</span>
        </div>
        
        <div class="panel">
            <div class="panel-title">üí∞ C√†i ƒê·∫∑t Giao D·ªãch</div>
            <div class="control-group">
                <label for="virtualBalance">S·ªë d∆∞ ban ƒë·∫ßu (USD):</label>
                <input type="number" id="virtualBalance" value="1000" min="100">
            </div>
            <div class="control-group">
                <label for="leverage">ƒê√≤n b·∫©y:</label>
                <input type="number" id="leverage" value="10" min="1" max="100">
            </div>
            <div class="control-group">
                <label for="lotSize">Kh·ªëi l∆∞·ª£ng (lot):</label>
                <input type="number" id="lotSize" value="0.1" min="0.01" step="0.01">
            </div>
            <div class="control-group">
                <label for="stopLoss">Stop Loss (USD):</label>
                <input type="number" id="stopLoss" value="50" min="1">
            </div>
            <div class="control-group">
                <label for="takeProfit">Take Profit (USD):</label>
                <input type="number" id="takeProfit" value="65" min="1">
            </div>
            <div style="margin-top: 20px;">
                <button onclick="startAutoTrading()">B·∫Øt ƒê·∫ßu Giao D·ªãch</button>
                <button class="danger" onclick="stopAutoTrading()">D·ª´ng Giao D·ªãch</button>
                <button onclick="analyzeBalanceHistory()">Ph√¢n T√≠ch Hi·ªáu Su·∫•t</button>
                <button class="danger" onclick="resetData()">Reset D·ªØ Li·ªáu</button>
            </div>
        </div>

        <div class="panel">
            <div class="panel-title">üéµ C√†i ƒê·∫∑t √Çm Thanh Th√¥ng B√°o</div>
<div class="control-group">
    <input type="checkbox" id="enableTTSSound">
    <label for="enableTTSSound" class="checkbox-label">D√πng TTS ti·∫øng Vi·ªát (song song √¢m thanh)</label>
</div>
</div> <div class="control-group" style="align-items: flex-start; flex-direction: column;">
                <button onclick="toggleDefaultSounds()" id="defaultSoundToggle" style="margin-bottom: 15px; padding: 10px 15px; background: #f6465d; color: white; border: none; border-radius: 4px; cursor: pointer;">
                    üîá T·∫Øt √Çm Thanh M·∫∑c ƒê·ªãnh
                </button>

                <div class="control-group">
                    <label for="globalNotifySoundInput">T·∫£i File √Çm Thanh (Chung):</label>
                    <input type="file" id="globalNotifySoundInput" accept=".mp3" style="width: 250px;">
                </div>
            </div>
            
            <p>Ch·ªçn c√°c th√¥ng b√°o s·∫Ω s·ª≠ d·ª•ng File √Çm Thanh Chung ƒë√£ t·∫£i l√™n:</p>
            
            <div class="sound-checkboxes">
                <div class="sound-checkbox-item">
                    <input type="checkbox" id="useOpenSound">
                    <label for="useOpenSound" class="checkbox-label" style="width: auto;">M·ªü l·ªánh</label>
                </div>
                
                <div class="sound-checkbox-item">
                    <input type="checkbox" id="useTpSound">
                    <label for="useTpSound" class="checkbox-label" style="width: auto;">Take Profit</label>
                </div>
                
                <div class="sound-checkbox-item">
                    <input type="checkbox" id="useSlSound">
                    <label for="useSlSound" class="checkbox-label" style="width: auto;">Stop Loss</label>
                </div>
                
                <div class="sound-checkbox-item">
                    <input type="checkbox" id="useAlertSound">
                    <label for="useAlertSound" class="checkbox-label" style="width: auto;">C·∫£nh b√°o gi√°</label>
                </div>
                
                <div class="sound-checkbox-item">
                    <input type="checkbox" id="useIntersectionSound">
                    <label for="useIntersectionSound" class="checkbox-label" style="width: auto;">Giao nhau (B/G)</label>
                </div>
                
                <div class="sound-checkbox-item">
                    <input type="checkbox" id="useSuggestionSound">
                    <label for="useSuggestionSound" class="checkbox-label" style="width: auto;">G·ª£i √Ω (Buy/Sell)</label>
                </div>

                <div class="sound-checkbox-item">
                    <input type="checkbox" id="usePriceStagnantSound">
                    <label for="usePriceStagnantSound" class="checkbox-label" style="width: auto;">Gi√° ƒë·ª©ng im</label>
                </div>
                
                <div class="sound-checkbox-item" style="display: none;">
                    <input type="checkbox" id="useGlobalSound">
                    <label for="useGlobalSound" class="checkbox-label" style="width: auto;">S·ª≠ d·ª•ng √¢m chung</label>
                </div>
            </div>

            <div style="margin-top: 20px;">
                <button onclick="saveAllSoundSettings()">L∆∞u C·∫•u H√¨nh √Çm Thanh</button>
            </div>
        </div>

        <div class="panel">
            <div class="panel-title">C·∫£nh B√°o Gi√°</div>
            <div class="control-group">
                <label for="alertPrices">M·ªëc gi√° (c√°ch nhau b·∫±ng ,):</label>
                <input type="text" id="alertPrices" placeholder="V√≠ d·ª•: 3640,3680,3569,3567" style="width: 300px;">
            </div>
            <div style="margin-top: 20px;">
                <button onclick="updateAlertLevels()">L∆∞u M·ªëc Gi√° C·∫£nh B√°o</button>
            </div>
        </div>
        
        <div class="panel">
            <div class="panel-title">‚öôÔ∏è C√†i ƒê·∫∑t G·ª£i √ù Theo H∆∞·ªõng (N√¢ng Cao)</div>
            
            <div class="control-group">
                <input type="checkbox" id="suggestionByDirectionEnabled" onchange="toggleSuggestionMode()">
                <label for="suggestionByDirectionEnabled" class="checkbox-label" style="width: 250px;">**[B·∫≠t/T·∫Øt] G·ª£i √Ω Theo H∆∞·ªõng**</label>
                <button onclick="saveDirectionalSettings()" style="margin-left: 20px;">L∆∞u C√†i ƒê·∫∑t</button>
            </div>

            <div id="directionalSettingsContainer" style="margin-top: 15px; border-top: 1px solid #eee; padding-top: 15px; display: none;">
                <div class="control-group">
                    <label for="suggestionBaseLine">D·ªØ li·ªáu c∆° s·ªü:</label>
                    <select id="suggestionBaseLine" style="width: 200px;">
                        <option value="balance">ƒê∆∞·ªùng S·ªë D∆∞ (USD)</option>
                        <option value="gold">Gi√° V√†ng (XAU/USD)</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label for="nextPointMode">Ch·∫ø ƒë·ªô ƒëi·ªÉm ti·∫øp theo:</label>
                    <select id="nextPointMode" style="width: 200px;" onchange="togglePointModeSettings()">
                        <option value="fixed">Kho·∫£ng c·ªë ƒë·ªãnh</option>
                        <option value="custom">Danh s√°ch t√πy ch·ªânh</option>
                    </select>
                </div>
                
                <div id="fixedIntervalSettings" style="margin-left: 150px; padding: 10px; background: #f5f5f5; border-radius: 4px; margin-bottom: 10px; display: none;">
                    <div class="control-group">
                        <label for="fixedInterval" style="width: 120px;">Kho·∫£ng ƒëi·ªÉm:</label>
                        <input type="number" id="fixedInterval" value="5" min="1" step="1" onchange="saveDirectionalSettings()">
                        <span style="margin-left: 10px;">ƒëi·ªÉm</span>
                    </div>
                </div>
                
                <div id="customPointsSettings" style="margin-left: 150px; padding: 10px; background: #f5f5f5; border-radius: 4px; margin-bottom: 10px; display: none;">
                    <div class="control-group">
                        <label for="customPoints" style="width: 120px;">Danh s√°ch ƒëi·ªÉm:</label>
                        <input type="text" id="customPoints" placeholder="0,5,10,15,20,25" style="width: 250px;" onchange="saveDirectionalSettings()">
                    </div>
                    <div style="font-size: 12px; color: #666; margin-top: 5px;">
                        V√≠ d·ª•: 0,5,10,15,20,25 (c√°ch nhau b·∫±ng d·∫•u ph·∫©y)
                    </div>
                </div>
                <div class="control-group" style="display: none;"> <label for="suggestionStartIndex">Ch·ªâ s·ªë b·∫Øt ƒë·∫ßu (0-n):</label>
                    <input type="number" id="suggestionStartIndex" value="0" min="0" step="1">
                    <button onclick="updateStartIndexFromTrade()" style="margin-left: 10px; background-color: #0ecb81; color: white;">C·∫≠p nh·∫≠t t·ª´ L·ªánh G·∫ßn nh·∫•t</button>
                </div>
                
                <div class="control-group">
                    <label for="directionConfirmationPoints">S·ªë ƒëi·ªÉm x√°c nh·∫≠n h∆∞·ªõng:</label>
                    <input type="number" id="directionConfirmationPoints" value="3" min="1" step="1">
                </div>
                
                <div class="control-group">
                    <label style="width: 150px;">ƒêi·ªÉm hi·ªán t·∫°i:</label>
                    <span id="currentPointDisplay" style="font-weight: bold; color: #d4af37;">0</span>
                    <button onclick="manualAdvancePoint()" style="margin-left: 10px; background-color: #0ecb81; color: white;">Chuy·ªÉn ƒëi·ªÉm ti·∫øp theo</button>
                </div>
                
                <div class="control-group">
                    <label for="manualPointInput" style="width: 150px;">ƒê·∫∑t ƒëi·ªÉm hi·ªán t·∫°i:</label>
                    <input type="number" id="manualPointInput" min="0" style="width: 100px;">
                    <button onclick="setManualPoint()" style="margin-left: 10px; background-color: #d4af37; color: #1e2026;">√Åp d·ª•ng</button>
                </div>
                </div>
        </div>
        <div class="panel">
            <div class="panel-title">‚öôÔ∏è C√†i ƒê·∫∑t G·ª£i √ù Giao D·ªãch C≈® (Theo Giao Nhau)</div>
            <div class="control-group">
                <input type="checkbox" id="suggestionByIntersectionEnabled" onchange="toggleSuggestionMode()">
                <label for="suggestionByIntersectionEnabled" class="checkbox-label" style="width: 250px;">**[B·∫≠t/T·∫Øt] G·ª£i √Ω Theo Giao Nhau**</label>
            </div>
            <div id="intersectionSettingsContainer" style="margin-top: 15px; border-top: 1px solid #eee; padding-top: 15px; display: none;">
                <div class="control-group">
                    <label for="minSlope">ƒê·ªô d·ªëc t·ªëi thi·ªÉu (Slope):</label>
                    <input type="number" id="minSlope" value="0.2" min="0.01" step="0.01">
                </div>
                <div class="control-group">
                    <label for="minGapPct">Kho·∫£ng c√°ch t·ªëi thi·ªÉu (%):</label>
                    <input type="number" id="minGapPct" value="0.3" min="0.05" step="0.05">
                </div>
                <div class="control-group">
                    <label for="confirmDelay">ƒê·ªô tr·ªÖ x√°c nh·∫≠n (ƒëi·ªÉm):</label>
                    <input type="number" id="confirmDelay" value="1" min="1" step="1">
                </div>
                <div class="control-group">
                    <label for="suggestionMode">Ch·∫ø ƒë·ªô hi·ªÉn th·ªã:</label>
                    <select id="suggestionMode">
                        <option value="all">T·∫•t c·∫£</option>
                        <option value="buy">Ch·ªâ MUA</option>
                        <option value="sell">Ch·ªâ B√ÅN</option>
                    </select>
                </div>
                <div style="margin-top: 20px;">
                    <button onclick="saveIntersectionSettings()">L∆∞u C·∫•u H√¨nh G·ª£i √ù</button>
                </div>
            </div>
        </div>
        <div class="panel">
            <div class="panel-title">üìä G·ª£i √ù Hi·ªán T·∫°i</div>
            <div id="suggestionDisplay">
                Ch∆∞a c√≥ g·ª£i √Ω n√†o.
            </div>
            <table class="stats-table">
                <thead>
                    <tr>
                        <th>G·ª£i √Ω</th>
                        <th>T·ªïng s·ªë</th>
                        <th>L·ªánh ƒë√∫ng (ƒë√≥ng l·ªùi)</th>
                        <th>T·ªâ l·ªá ƒë√∫ng (%)</th>
                    </tr>
                </thead>
                <tbody id="suggestionStatsBody">
                    <tr><td>BUY</td><td id="statBuyTotal">0</td><td id="statBuyCorrect">0</td><td id="statBuyPct">0.00%</td></tr>
                    <tr><td>SELL</td><td id="statSellTotal">0</td><td id="statSellCorrect">0</td><td id="statSellPct">0.00%</td></tr>
                </tbody>
            </table>
            <button class="danger" onclick="resetSuggestionData()" style="margin-top: 10px;">Reset G·ª£i √ù & Th·ªëng k√™</button>
        </div>
        
        <div class="panel">
            <div class="panel-title">Bi·ªÉu ƒê·ªì Gi√°</div>
            <div class="chart-container">
                <canvas id="priceChart"></canvas>
            </div>
        </div>

        <div class="panel">
            <div class="panel-title">Bi·ªÉu ƒê·ªì S·ªë D∆∞ & Gi√° V√†ng</div>
            <div class="chart-container">
                <canvas id="balanceChart" height="300"></canvas>
            </div>
        </div>
        
        <div id="activeTrades" style="display: none;">
            <div class="panel-title">L·ªánh Hi·ªán T·∫°i</div>
            <div class="trade-info" id="currentTradeDetails"></div>
        </div>
        
        <div class="panel">
            <div class="panel-title">L·ªãch S·ª≠ Giao D·ªãch & Log</div>
            <div id="historyList"></div>
            <button style="margin-top: 10px;" onclick="clearHistory()">X√≥a L·ªãch S·ª≠</button>
        </div>
    </div>

    <script>
        // Bi·∫øn to√†n c·ª•c
        const FINNHUB_API_KEY = 'd1l6t99r01qt4thebangd1l6t99r01qt4thebao0';
        let currentPrice = 0;
        let chart;
        let balanceChart;
        let ws;
        let autoTradingActive = false;
        let tradingInterval;
        let virtualBalance = 1000;
        let tradesToday = 0;
        let currentTrades = [];
        let priceHistory = [];
        let balanceHistory = JSON.parse(localStorage.getItem('balanceHistory')) || [];
        let isWaitingNewTrades = false;
        let lastUpdateTime = null;

        // C·∫•u h√¨nh G·ª£i √Ω GIAO NHAU C≈®
        let intersectionSettings = JSON.parse(localStorage.getItem('intersectionSettings')) || {
            minSlope: 0.2,
            minGapPct: 0.3,
            confirmDelay: 1,
            suggestionMode: 'all'
        };
        let suggestionStats = JSON.parse(localStorage.getItem('suggestionStats')) || {
            BUY: { total: 0, correct: 0, lastIndex: -1, lastTime: null, lastTradeIndex: -1 },
            SELL: { total: 0, correct: 0, lastIndex: -1, lastTime: null, lastTradeIndex: -1 }
        };

        // C·∫•u h√¨nh G·ª£i √Ω THEO H∆Ø·ªöNG M·ªöI
        let suggestionByDirectionEnabled = localStorage.getItem('suggestionByDirectionEnabled') === 'true'; 
        let suggestionByIntersectionEnabled = localStorage.getItem('suggestionByIntersectionEnabled') === 'true'; 
        let suggestionBaseLine = localStorage.getItem('suggestionBaseLine') || 'balance'; // 'balance' ho·∫∑c 'gold'
        let suggestionStartIndex = parseInt(localStorage.getItem('suggestionStartIndex')) || 0; // Ch·ªâ s·ªë b·∫Øt ƒë·∫ßu trong balanceHistory
        let directionConfirmationPoints = parseInt(localStorage.getItem('directionConfirmationPoints')) || 3;
        let lastDirectionalSuggestion = localStorage.getItem('lastDirectionalSuggestion') || null; // 'BUY'/'SELL'
        
        // ********** KHAI B√ÅO BI·∫æN ƒêI·ªÇM TI·∫æP THEO **********
        let nextPointMode = localStorage.getItem('nextPointMode') || 'fixed';
        let fixedInterval = parseInt(localStorage.getItem('fixedInterval')) || 5;
        let customPoints = JSON.parse(localStorage.getItem('customPoints')) || [0, 5, 10, 15, 20, 25];
        let currentPointIndex = parseInt(localStorage.getItem('currentPointIndex')) || 0;
        // *****************************************************

        // Bi·∫øn ƒëi·ªÅu khi·ªÉn √¢m thanh m·∫∑c ƒë·ªãnh
        let ttsEnabled = localStorage.getItem('enableTTSSound') === 'true';
let defaultSoundsEnabled = localStorage.getItem('defaultSoundsEnabled') !== 'false';

        // √Çm thanh m·∫∑c ƒë·ªãnh
        const defaultOpenSound = new Audio('https://www.soundjay.com/buttons/button-21.mp3');
        const defaultTpSound = new Audio('https://www.soundjay.com/buttons/button-09.mp3');
        const defaultSlSound = new Audio('https://www.soundjay.com/buttons/button-10.mp3');
        const defaultAlertSound = new Audio('https://www.soundjay.com/buttons/sounds/beep-07.mp3');
        const defaultIntersectionSound = defaultAlertSound;
        const defaultSuggestionSound = defaultAlertSound;
        const defaultPriceStagnantSound = defaultAlertSound;

        // √Çm thanh ng∆∞·ªùi d√πng (s·∫Ω ƒë∆∞·ª£c t·∫£i t·ª´ localStorage)
        let userGlobalNotifySound = null; 
        
        // L∆∞u tr·∫°ng th√°i t√≠ch ch·ªçn c·ªßa t·ª´ng lo·∫°i √¢m thanh
        let soundUseStatus = JSON.parse(localStorage.getItem('soundUseStatus')) || {};
        
        // Th√™m c√°c bi·∫øn ph√°t hi·ªán gi√° ƒë·ª©ng im
        let lastPriceUpdateTime = null;
        let priceStagnantAlertPlayed = false;
        let priceStagnantThreshold = 10000; // 10 gi√¢y
        
        let alertLevels = [];
        let alertedLevels = new Set();
        let alertedIntersectionIndices = new Set();

        // H√†m b·∫≠t/t·∫Øt √¢m thanh m·∫∑c ƒë·ªãnh
        function toggleDefaultSounds() {
            defaultSoundsEnabled = !defaultSoundsEnabled;
            localStorage.setItem('defaultSoundsEnabled', defaultSoundsEnabled);
            
            const button = document.getElementById('defaultSoundToggle');
            if (defaultSoundsEnabled) {
                button.innerHTML = 'üîá T·∫Øt √Çm Thanh M·∫∑c ƒê·ªãnh';
                button.style.backgroundColor = '#f6465d';
            } else {
                button.innerHTML = 'üîä B·∫≠t √Çm Thanh M·∫∑c ƒê·ªãnh';
                button.style.backgroundColor = '#0ecb81';
            }
            
            logStatus(defaultSoundsEnabled ? 'üîä B·∫≠t √¢m thanh m·∫∑c ƒë·ªãnh' : 'üîá T·∫Øt √¢m thanh m·∫∑c ƒë·ªãnh');
        }
        
        // Ghi log tr·∫°ng th√°i
        function logStatus(message) {
            const now = new Date().toLocaleTimeString('vi-VN');
            console.log(`[${now}] ${message}`);
            addHistory(message);
        }

        // Kh·ªüi t·∫°o bi·ªÉu ƒë·ªì gi√° v√† s·ªë d∆∞
        function initChart() {
            const ctx = document.getElementById('priceChart').getContext('2d');
            chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'XAU/USD',
                        data: [],
                        borderColor: '#d4af37',
                        backgroundColor: 'rgba(212, 175, 55, 0.1)',
                        tension: 0.2,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: { beginAtZero: false }
                    }
                }
            });

            drawBalanceChart();
            updateSuggestionStatsDisplay();
        }

        // K·∫øt n·ªëi WebSocket Finnhub
        function connectWebSocket() {
            try {
                if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) return;
                
                ws = new WebSocket(`wss://ws.finnhub.io?token=${FINNHUB_API_KEY}`);
                
                ws.onopen = () => {
                    logStatus('WS open - subscribing OANDA:XAU_USD');
                    ws.send(JSON.stringify({ type: 'subscribe', symbol: 'OANDA:XAU_USD' }));
                    addHistory('üîå K·∫øt n·ªëi WebSocket');
                };
                
                
                ws.onmessage = (evt) => {
                    let data;
                    try { 
                        data = JSON.parse(evt.data); 
                    } catch(e) { 
                        console.error('WS JSON parse error', e); 
                        return; 
                    }
                    
                    if (data && data.type === 'trade' && Array.isArray(data.data)) {
                        const last = data.data[data.data.length - 1];
                        if (!last || typeof last.p === 'undefined') return;
                        
                        const oldPrice = currentPrice;
                        const newPrice = parseFloat(last.p);
                        if (isNaN(newPrice)) return;
                        
                        // C·∫≠p nh·∫≠t th·ªùi gian gi√° thay ƒë·ªïi
                        lastPriceUpdateTime = new Date().getTime();
                        
                        currentPrice = newPrice;
                        document.getElementById('currentPrice').textContent = newPrice.toFixed(2);
                        lastUpdateTime = new Date();
                        
                        const now = new Date();
                        priceHistory.push({ time: now.toLocaleTimeString('vi-VN'), price: newPrice });
                        if (priceHistory.length > 200) priceHistory.shift();
                        
                        updateChart();
                        drawBalanceChart();
                        checkPriceAlerts(oldPrice, newPrice);
                        
                        if (currentTrades.length > 0) {
                            updateTradeInfo();
                            checkTrades(); // Th√™m checkTrades ·ªü ƒë√¢y ƒë·ªÉ ki·ªÉm tra l·ªánh ngay khi c√≥ gi√° m·ªõi
                        }
                    }
                };
                
                ws.onerror = (err) => {
                    console.error('WS error', err);
                    addHistory('‚ö†Ô∏è L·ªói WebSocket');
                };
                
                ws.onclose = (ev) => {
                    console.warn('WS closed - reconnect in 3s', ev);
                    addHistory('‚ö†Ô∏è WebSocket ƒë√≥ng, th·ª≠ k·∫øt n·ªëi l·∫°i...');
                    setTimeout(connectWebSocket, 3000);
                };
            } catch(e) {
                console.error('connectWebSocket error', e);
                addHistory('‚ùå L·ªói k·∫øt n·ªëi WebSocket: ' + e.message);
            }
        }

        // C·∫≠p nh·∫≠t bi·ªÉu ƒë·ªì gi√°
        function updateChart() {
            const labels = priceHistory.map(item => item.time);
            const data = priceHistory.map(item => item.price);
            
            chart.data.labels = labels;
            chart.data.datasets[0].data = data;
            chart.update();
        }

        // H√†m ki·ªÉm tra gi√° ƒë·ª©ng im
        function checkPriceStagnation() {
            if (!lastPriceUpdateTime || currentPrice === 0) return;
            
            const now = new Date().getTime();
            const timeDiff = now - lastPriceUpdateTime;
            
            if (timeDiff > priceStagnantThreshold && !priceStagnantAlertPlayed) {
                playNotificationSound('priceStagnant');
                addHistory(`‚ö†Ô∏è C·∫¢NH B√ÅO: Gi√° kh√¥ng thay ƒë·ªïi trong ${priceStagnantThreshold/1000} gi√¢y`);
                priceStagnantAlertPlayed = true;
            } else if (timeDiff <= priceStagnantThreshold) {
                priceStagnantAlertPlayed = false;
            }
        }

        // H√†m ph√°t √¢m thanh (Gi·ªØ nguy√™n)
        
// *** START FIX 3: REPLACE playTTSMessage ***
function playTTSMessage(soundType, info = null) {
    // Ki·ªÉm tra tr√¨nh duy·ªát c√≥ h·ªó tr·ª£ TTS kh√¥ng
    if (!('speechSynthesis' in window)) {
        console.warn("Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ Text-to-Speech");
        return;
    }
    
    const synth = window.speechSynthesis;
    
    // D·ª´ng c√°c speech ƒëang ch·∫°y
    synth.cancel();
    
    let message = "";
    switch (soundType) {
        case 'open': 
            message = "ƒê√£ m·ªü l·ªánh m·ªõi"; 
            break;
        case 'tp':
            if (info) {
                const dir = info.type === 'BUY' ? 'mua' : 'b√°n';
                const profit = info.profit.toFixed(2);
                message = `Ch·ªët l·ªùi l·ªánh ${dir}. L·ª£i nhu·∫≠n ${profit} ƒë√¥ la`;
            } else {
                message = "Ch·ªët l·ªùi th√†nh c√¥ng";
            }
            break;
        case 'sl':
            if (info) {
                const dir = info.type === 'BUY' ? 'mua' : 'b√°n';
                const loss = Math.abs(info.profit).toFixed(2);
                message = `D·ª´ng l·ªó l·ªánh ${dir}. L·ªó ${loss} ƒë√¥ la`;
            } else {
                message = "D·ª´ng l·ªó k√≠ch ho·∫°t";
            }
            break;
        case 'alert':
            if (info && info.level) {
                const dirText = info.direction === 'up' ? 'v∆∞·ª£t l√™n' : 't·ª•t xu·ªëng';
                message = `Gi√° v√†ng v·ª´a ${dirText} m·ªëc ${info.level}`;
            } else {
                message = "C√≥ c·∫£nh b√°o gi√° m·ªõi";
            }
            break;
        case 'intersection':
            if (info && info.suggestion) {
                message = info.suggestion === 'BUY'
                    ? "T√≠n hi·ªáu mua: ƒë∆∞·ªùng s·ªë d∆∞ v∆∞·ª£t l√™n"
                    : "T√≠n hi·ªáu b√°n: ƒë∆∞·ªùng gi√° v√†ng v∆∞·ª£t l√™n";
            } else {
                message = "Ph√°t hi·ªán giao nhau gi·ªØa hai ƒë∆∞·ªùng";
            }
            break;
        case 'suggestion':
            if (info && info.suggestion) {
                message = `G·ª£i √Ω ${info.suggestion === 'BUY' ? 'mua' : 'b√°n'} t·ª´ h·ªá th·ªëng`;
            } else {
                message = "C√≥ g·ª£i √Ω giao d·ªãch m·ªõi";
            }
            break;
        case 'priceStagnant': 
            message = "C·∫£nh b√°o: gi√° v√†ng ƒëang ƒë·ª©ng im"; 
            break;
        default: 
            message = "C√≥ th√¥ng b√°o m·ªõi";
    }

    try {
        const utter = new SpeechSynthesisUtterance(message);
        utter.lang = "vi-VN";
        utter.rate = 1.0;
        utter.pitch = 1.0;
        utter.volume = 1.0;
        
        // Th√™m x·ª≠ l√Ω l·ªói
        utter.onerror = function(event) {
            console.error('L·ªói TTS:', event.error);
        };
        
        utter.onend = function() {
            console.log('TTS finished');
        };
        
        synth.speak(utter);
    } catch (error) {
        console.error('L·ªói khi ph√°t TTS:', error);
    }
}
// *** END FIX 3 ***

// *** START FIX 4: REPLACE playNotificationSound ***
function playNotificationSound(soundType, data = null) {
    try {
        // KI·ªÇM TRA TTS TR∆Ø·ªöC KHI PH√ÅT
        if (ttsEnabled) {
            console.log(`Ph√°t TTS: ${soundType}`, data);
            playTTSMessage(soundType, data);
        } else {
            console.log(`TTS ƒë√£ t·∫Øt, b·ªè qua: ${soundType}`);
        }
        
        // Ph√°t √¢m thanh th√¥ng th∆∞·ªùng
        const soundToPlay = getSound(soundType);
        if (soundToPlay) {
            soundToPlay.currentTime = 0;
            soundToPlay.play().catch(e => console.log(`L·ªói ph√°t √¢m thanh (${soundType}):`, e));
        }
    } catch (e) {
        console.error("L·ªói h·ªá th·ªëng √¢m thanh:", e);
    }
}
// *** END FIX 4 ***
        
        // H√†m l·∫•y √¢m thanh theo ∆∞u ti√™n (Gi·ªØ nguy√™n)
        function getSound(soundType) {
            
            // ∆Øu ti√™n 1: √Çm thanh chung t√πy ch·ªânh n·∫øu ƒë∆∞·ª£c t√≠ch
            if (soundUseStatus[soundType] && userGlobalNotifySound) {
                return userGlobalNotifySound;
            }
            
            let defaultSoundVar;
            
            switch(soundType) {
                case 'open': defaultSoundVar = defaultOpenSound; break;
                case 'tp': defaultSoundVar = defaultTpSound; break;
                case 'sl': defaultSoundVar = defaultSlSound; break;
                case 'alert': defaultSoundVar = defaultAlertSound; break;
                case 'intersection': defaultSoundVar = defaultIntersectionSound; break;
                case 'suggestion': defaultSoundVar = defaultSuggestionSound; break;
                case 'priceStagnant': defaultSoundVar = defaultPriceStagnantSound; break;
                default: return null;
            }

            // ∆Øu ti√™n 2: √Çm thanh m·∫∑c ƒë·ªãnh n·∫øu ƒë∆∞·ª£c b·∫≠t
            if (defaultSoundsEnabled && defaultSoundVar) {
                return defaultSoundVar;
            }
            
            return null; // Kh√¥ng c√≥ √¢m thanh n√†o
        }

        // L∆∞u t·∫•t c·∫£ c·∫•u h√¨nh √¢m thanh (Gi·ªØ nguy√™n)
        function saveAllSoundSettings() {
             const globalFileInput = document.getElementById('globalNotifySoundInput');
            const file = globalFileInput.files[0];
            
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const url = e.target.result;
                    userGlobalNotifySound = new Audio(url);
                    localStorage.setItem('globalSoundUrl', url);
                    logStatus('üéµ ƒê√£ t·∫£i file √¢m thanh chung th√†nh c√¥ng');
                };
                reader.readAsDataURL(file);
            }

            // L∆∞u tr·∫°ng th√°i t√≠ch ch·ªçn c·ªßa t·ª´ng lo·∫°i √¢m thanh
            const soundTypes = [
                { id: 'useOpenSound', type: 'open' },
                { id: 'useTpSound', type: 'tp' },
                { id: 'useSlSound', type: 'sl' },
                { id: 'useAlertSound', type: 'alert' },
                { id: 'useIntersectionSound', type: 'intersection' },
                { id: 'useSuggestionSound', type: 'suggestion' },
                { id: 'usePriceStagnantSound', type: 'priceStagnant' },
            ];
            soundTypes.forEach(s => {
                const use = document.getElementById(s.id)?.checked || false;
                soundUseStatus[s.type] = use;
            });
            localStorage.setItem('soundUseStatus', JSON.stringify(soundUseStatus));
            
            // *** START FIX 1: ADD TTS SAVE ***
            ttsEnabled = document.getElementById('enableTTSSound').checked;
            localStorage.setItem('enableTTSSound', ttsEnabled);
            // *** END FIX 1 ***
            
            alert('‚úÖ ƒê√£ l∆∞u c·∫•u h√¨nh √¢m thanh');
            logStatus('üéµ ƒê√£ l∆∞u c·∫•u h√¨nh √¢m thanh');
        }

        // T·∫£i c·∫•u h√¨nh √¢m thanh t·ª´ localStorage (Gi·ªØ nguy√™n)
        function loadSoundSettings() {
            // T·∫£i URL √¢m thanh chung
            const globalUrl = localStorage.getItem('globalSoundUrl');
            if (globalUrl) {
                userGlobalNotifySound = new Audio(globalUrl);
            }

            // *** START FIX 2: ADD TTS LOAD ***
            ttsEnabled = localStorage.getItem('enableTTSSound') === 'true';
            if (document.getElementById('enableTTSSound')) {
                document.getElementById('enableTTSSound').checked = ttsEnabled;
            }
            // *** END FIX 2 ***

            // T·∫£i tr·∫°ng th√°i t√≠ch ch·ªçn
            soundUseStatus = JSON.parse(localStorage.getItem('soundUseStatus') || '{}');
            const soundTypes = [
                { id: 'useOpenSound', type: 'open' },
                { id: 'useTpSound', type: 'tp' },
                { id: 'useSlSound', type: 'sl' },
                { id: 'useAlertSound', type: 'alert' },
                { id: 'useIntersectionSound', type: 'intersection' },
                { id: 'useSuggestionSound', type: 'suggestion' },
                { id: 'usePriceStagnantSound', type: 'priceStagnant' },
            ];
            soundTypes.forEach(s => {
                if (document.getElementById(s.id)) {
                    // Thi·∫øt l·∫≠p tr·∫°ng th√°i t√≠ch ch·ªçn t·ª´ soundUseStatus
                    document.getElementById(s.id).checked = soundUseStatus[s.type] || false;
                }
            });

            // C·∫≠p nh·∫≠t tr·∫°ng th√°i n√∫t b·∫≠t/t·∫Øt √¢m m·∫∑c ƒë·ªãnh
            // G·ªçi l·∫°i toggleDefaultSounds() ƒë·ªÉ thi·∫øt l·∫≠p UI cho n√∫t
            defaultSoundsEnabled = localStorage.getItem('defaultSoundsEnabled') !== 'false';
            const button = document.getElementById('defaultSoundToggle');
            if (button) {
                if (defaultSoundsEnabled) {
                    button.innerHTML = 'üîá T·∫Øt √Çm Thanh M·∫∑c ƒê·ªãnh';
                    button.style.backgroundColor = '#f6465d';
                } else {
                    button.innerHTML = 'üîä B·∫≠t √Çm Thanh M·∫∑c ƒê·ªãnh';
                    button.style.backgroundColor = '#0ecb81';
                }
            }
        }
        
        // H√†m c·∫≠p nh·∫≠t tr·∫°ng th√°i hi·ªÉn th·ªã
        function updateStatus() {
            document.getElementById('balanceText').textContent = virtualBalance.toFixed(2) + ' USD';
            document.getElementById('tradesCount').textContent = tradesToday;
            document.getElementById('statusText').textContent = autoTradingActive ? 'ƒêang giao d·ªãch' : 'ƒê√£ d·ª´ng';
            
            const tradesContainer = document.getElementById('currentTradeDetails');
            if (currentTrades.filter(t => !t.closed).length > 0) {
                document.getElementById('activeTrades').style.display = 'block';
            } else if (tradesContainer) {
                document.getElementById('activeTrades').style.display = 'none';
            }
        }

        // B·∫Øt ƒë·∫ßu giao d·ªãch
        function startAutoTrading() {
            if (autoTradingActive) return;
            
            // C·∫≠p nh·∫≠t gi√° tr·ªã ban ƒë·∫ßu n·∫øu ch∆∞a c√≥
            if (balanceHistory.length === 0) {
                virtualBalance = parseFloat(document.getElementById('virtualBalance').value);
                balanceHistory.push({ 
                    time: new Date().toISOString(), 
                    balance: virtualBalance, 
                    profit: 0, 
                    reason: 'INIT', 
                    type: 'INIT',
                    goldPrice: currentPrice, // L∆∞u gi√° v√†ng ban ƒë·∫ßu
                });
            } else {
                 // C·∫≠p nh·∫≠t s·ªë d∆∞ n·∫øu ƒë√£ c√≥ l·ªãch s·ª≠
                virtualBalance = balanceHistory[balanceHistory.length - 1].balance;
            }
            
            autoTradingActive = true;
            tradesToday = 0; // Reset s·ªë l·ªánh trong ng√†y
            
            // X√≥a c√°c l·ªánh ƒë√£ ƒë√≥ng
            currentTrades = currentTrades.filter(t => !t.closed); 
            
            // Thi·∫øt l·∫≠p interval ki·ªÉm tra l·ªánh m·ªõi
            tradingInterval = setInterval(createNewTrades, 3000); // T·∫°o l·ªánh m·ªõi m·ªói 3 gi√¢y
            
            logStatus('üöÄ B·∫Øt ƒë·∫ßu giao d·ªãch t·ª± ƒë·ªông. S·ªë d∆∞: ' + virtualBalance.toFixed(2));
            updateStatus();
            saveTradingSettings();
        }

        // D·ª´ng giao d·ªãch
        function stopAutoTrading() {
            if (!autoTradingActive) return;
            autoTradingActive = false;
            if (tradingInterval) {
                clearInterval(tradingInterval);
                tradingInterval = null;
            }
            logStatus('‚è∏Ô∏è D·ª´ng giao d·ªãch t·ª± ƒë·ªông');
            updateStatus();
        }
        
        // ********** B·ªî SUNG H√ÄM createNewTrades **********
        function createNewTrades() {
            if (!autoTradingActive || currentPrice === 0 || virtualBalance < 100) {
                stopAutoTrading();
                return;
            }

            // ƒê·∫£m b·∫£o kh√¥ng t·∫°o l·ªánh m·ªõi n·∫øu ƒëang c√≥ l·ªánh m·ªü
            if (currentTrades.length > 0) {
                logStatus('‚ö†Ô∏è ƒêang c√≥ l·ªánh m·ªü, kh√¥ng t·∫°o l·ªánh m·ªõi.');
                return;
            }

            // ƒê·∫£m b·∫£o kh√¥ng t·∫°o l·ªánh m·ªõi n·∫øu ƒëang ch·ªù l·ªánh m·ªü
            if (isWaitingNewTrades) {
                return; 
            }
            
            let suggestionType = null;
            if (suggestionByDirectionEnabled) {
                const suggestion = checkDirectionalSuggestion(true);
                if (suggestion) {
                    suggestionType = suggestion;
                }
            } else if (suggestionByIntersectionEnabled) {
                const suggestion = checkIntersectionSuggestion(true);
                if (suggestion) {
                    suggestionType = suggestion;
                }
            }

            if (!suggestionType) {
                logStatus('ü§î Kh√¥ng c√≥ g·ª£i √Ω giao d·ªãch n√†o ƒë·ªß ƒëi·ªÅu ki·ªán ƒë·ªÉ m·ªü l·ªánh.');
                return;
            }
            
            // C√†i ƒë·∫∑t l·ªánh
            const leverage = parseFloat(document.getElementById('leverage').value);
            const lotSize = parseFloat(document.getElementById('lotSize').value);
            const stopLoss = parseFloat(document.getElementById('stopLoss').value);
            const takeProfit = parseFloat(document.getElementById('takeProfit').value);
            
            const tradeIndex = Date.now();
            const newTrade = {
                tradeIndex: tradesToday + 1,
                type: suggestionType, // BUY ho·∫∑c SELL
                entryPrice: currentPrice,
                lotSize: lotSize,
                leverage: leverage,
                stopLossLevel: suggestionType === 'BUY' ? currentPrice - (stopLoss / lotSize / leverage) : currentPrice + (stopLoss / lotSize / leverage),
                takeProfitLevel: suggestionType === 'BUY' ? currentPrice + (takeProfit / lotSize / leverage) : currentPrice - (takeProfit / lotSize / leverage),
                openTime: new Date().toISOString(),
                closed: false,
                suggestionSource: suggestionByDirectionEnabled ? 'Direction' : 'Intersection',
            };

            currentTrades.push(newTrade);
            tradesToday++;
            isWaitingNewTrades = true; // ƒê·∫∑t c·ªù ch·ªù
            
            playNotificationSound('open');

            addHistory(
                `üî• M·ªü l·ªánh ${newTrade.type} #${newTrade.tradeIndex} @ ${newTrade.entryPrice.toFixed(2)} | KL: ${lotSize} | SL: ${stopLoss} | TP: ${takeProfit}`
            );
            updateTradeInfo();
            updateStatus();
            logStatus(`üìà M·ªü l·ªánh ${newTrade.type} #${newTrade.tradeIndex}`);
            
            // X√≥a c·ªù ch·ªù sau 1 gi√¢y (ƒë·ªÉ tr√°nh spam l·ªánh)
            setTimeout(() => {
                isWaitingNewTrades = false;
            }, 1000);
        }
        // *********************************************************

        // Ki·ªÉm tra l·ªánh (TP/SL)
        function checkTrades() {
            if (currentTrades.length === 0) return;

            const tradesToClose = [];

            currentTrades.forEach((trade, index) => {
                if (trade.closed) return;

                // T√≠nh to√°n P&L theo gi√° hi·ªán t·∫°i
                const direction = trade.type === 'BUY' ? 1 : -1;
                const priceDiff = (currentPrice - trade.entryPrice) * direction;
                const profit = priceDiff * trade.lotSize * 100000; // 1 pip = 0.01

                // Ki·ªÉm tra Take Profit
                if (trade.type === 'BUY' && currentPrice >= trade.takeProfitLevel) {
                    tradesToClose.push({ index, reason: 'TAKE PROFIT', closePrice: currentPrice, profit: profit });
                } else if (trade.type === 'SELL' && currentPrice <= trade.takeProfitLevel) {
                    tradesToClose.push({ index, reason: 'TAKE PROFIT', closePrice: currentPrice, profit: profit });
                }
                // Ki·ªÉm tra Stop Loss
                else if (trade.type === 'BUY' && currentPrice <= trade.stopLossLevel) {
                    tradesToClose.push({ index, reason: 'STOP LOSS', closePrice: currentPrice, profit: profit });
                } else if (trade.type === 'SELL' && currentPrice >= trade.stopLossLevel) {
                    tradesToClose.push({ index, reason: 'STOP LOSS', closePrice: currentPrice, profit: profit });
                }
            });

            tradesToClose.forEach(item => {
                closeTrade(item.index, item.reason, item.closePrice, item.profit);
            });
        }
        
        // *********************************************************
        // ********** B·ªî SUNG H√ÄM closeTrade **********
        function closeTrade(index, reason, closePrice, profit) {
            const trade = currentTrades[index];
            if (!trade || trade.closed) return;

            trade.closed = true;
            trade.closeTime = new Date().toISOString();
            trade.reason = reason;
            trade.closePrice = closePrice;
            trade.profit = profit;

            // C·∫≠p nh·∫≠t s·ªë d∆∞
            virtualBalance += profit;

            // C·∫≠p nh·∫≠t th·ªëng k√™ g·ª£i √Ω (M·ªöI)
            updateSuggestionStats(trade, profit);

            // L∆∞u l·ªãch s·ª≠ s·ªë d∆∞
            balanceHistory.push({
                time: new Date().toISOString(),
                balance: virtualBalance,
                profit: profit,
                reason: reason,
                type: trade.type,
                entryPrice: trade.entryPrice,
                closePrice: closePrice,
                goldPrice: currentPrice, // ƒê√É S·ª¨A: L∆ØU GI√Å V√ÄNG HI·ªÜN T·∫†I
                lotSize: trade.lotSize,
                tradeIndex: trade.tradeIndex
            });

            // Logic chuy·ªÉn ƒëi·ªÉm ti·∫øp theo
            if (suggestionByDirectionEnabled) {
                advanceToNextPoint();
            }

            localStorage.setItem('balanceHistory', JSON.stringify(balanceHistory));
            saveTradingSettings();
            drawBalanceChart();

            if (reason === 'TAKE PROFIT') {
                playNotificationSound('tp', { type: trade.type, profit: profit }); // TH√äM data cho TTS
            } else if (reason === 'STOP LOSS') {
                playNotificationSound('sl', { type: trade.type, profit: profit }); // TH√äM data cho TTS
            }

            addHistory(
                `ƒê√≥ng l·ªánh ${trade.type} #${trade.tradeIndex} @ ${closePrice.toFixed(2)} (${reason}) | ` +
                `L·ª£i nhu·∫≠n: <span class="${profit >= 0 ? 'profit' : 'loss'}">${profit.toFixed(2)} USD</span> | ` +
                `S·ªë d∆∞: ${virtualBalance.toFixed(2)} USD`
            );
            updateTradeInfo();
            updateStatus();
            logStatus(
                `üìâ ƒê√≥ng l·ªánh ${trade.type} #${trade.tradeIndex} (${reason}) | ` +
                `L·ª£i nhu·∫≠n: ${profit.toFixed(2)} USD | ` +
                `S·ªë d∆∞ m·ªõi: ${virtualBalance.toFixed(2)} USD`
            );
        }
        // *********************************************************
        // ********** B·ªî SUNG H√ÄM updateTradeInfo **********
        function updateTradeInfo() {
            const container = document.getElementById('currentTradeDetails');
            if (!container) return;
            container.innerHTML = '';

            // L·ªçc ra c√°c l·ªánh ƒëang m·ªü (closed: false)
            const activeTrades = currentTrades.filter(trade => !trade.closed);

            if (activeTrades.length === 0) {
                document.getElementById('activeTrades').style.display = 'none';
                return;
            }

            document.getElementById('activeTrades').style.display = 'block';

            activeTrades.forEach(trade => {
                const direction = trade.type === 'BUY' ? 1 : -1;
                const priceDiff = (currentPrice - trade.entryPrice) * direction;
                const profit = priceDiff * trade.lotSize * 100000;

                const tradeBox = document.createElement('div');
                tradeBox.className = `trade-box ${trade.type.toLowerCase()}`;
                tradeBox.innerHTML = `
                    <p style="font-size: 16px; margin-bottom: 5px;">
                        <strong>${trade.type} #${trade.tradeIndex}</strong> | 
                        Gi√° v√†o: ${trade.entryPrice.toFixed(2)} | 
                        Gi√° hi·ªán t·∫°i: ${currentPrice.toFixed(2)}
                    </p>
                    <p style="margin-bottom: 5px;">
                        KL: ${trade.lotSize} | 
                        SL: ${trade.stopLossLevel.toFixed(2)} | 
                        TP: ${trade.takeProfitLevel.toFixed(2)}
                    </p>
                    <p style="margin-bottom: 0;">
                        L·ª£i nhu·∫≠n hi·ªán t·∫°i: 
                        <span class="${profit >= 0 ? 'profit' : 'loss'}">${profit.toFixed(2)} USD</span>
                    </p>
                `;
                container.appendChild(tradeBox);
            });
        }
        // *********************************************************

        // H√†m c·∫≠p nh·∫≠t l·ªãch s·ª≠ giao d·ªãch (Gi·ªØ nguy√™n)
        function addHistory(message) {
            const historyList = document.getElementById('historyList');
            if (!historyList) return;

            const now = new Date().toLocaleTimeString('vi-VN');
            const historyItem = document.createElement('div');
            historyItem.className = 'history-item';
            historyItem.innerHTML = `[${now}] ${message}`;

            // Gi·ªõi h·∫°n 50 m·ª•c l·ªãch s·ª≠ g·∫ßn nh·∫•t
            if (historyList.children.length >= 50) {
                historyList.removeChild(historyList.lastChild);
            }
            historyList.insertBefore(historyItem, historyList.firstChild);
        }

        // S·ª¨A L·ªñI 2: Th√™m n·ªôi dung cho h√†m checkPriceAlerts
        function checkPriceAlerts(oldPrice, newPrice) {
            if (!alertLevels.length) return;
            alertLevels.forEach(level => {
                const crossUp = oldPrice < level && newPrice >= level;
                const crossDown = oldPrice > level && newPrice <= level;

                if ((crossUp || crossDown) && !alertedLevels.has(level)) {
                    alertedLevels.add(level);
                    const direction = crossUp ? 'l√™n' : 'xu·ªëng';
                    const message = `‚ö†Ô∏è Gi√° v·ª´a v∆∞·ª£t m·ªëc ${level} (${direction})`;
                    addHistory(message);
                    playNotificationSound('alert', { level: level, direction: crossUp ? 'up' : 'down', price: newPrice });
                }
            });
        }

        // S·ª¨A L·ªñI 2: Th√™m n·ªôi dung cho h√†m updateAlertLevels
        function updateAlertLevels() {
            const alertInput = document.getElementById('alertPrices').value;
            alertLevels = alertInput.split(',')
                .map(level => parseFloat(level.trim()))
                .filter(level => !isNaN(level) && level > 0);
            alertedLevels.clear();
            localStorage.setItem('alertLevels', JSON.stringify(alertLevels));
            addHistory(`üìä ƒê√£ c·∫≠p nh·∫≠t ${alertLevels.length} m·ªëc c·∫£nh b√°o gi√°`);
        }

        // S·ª¨A L·ªñI 3: Th√™m n·ªôi dung cho h√†m updateSuggestionStats
        function updateSuggestionStats(trade, profit) {
            if (trade.suggestionSource) {
                const type = trade.type; // BUY ho·∫∑c SELL
                suggestionStats[type].total++;
                if (profit > 0) {
                    suggestionStats[type].correct++;
                }

                // C·∫≠p nh·∫≠t trade index g·∫ßn nh·∫•t
                suggestionStats[type].lastTradeIndex = trade.tradeIndex;

                localStorage.setItem('suggestionStats', JSON.stringify(suggestionStats));
                updateSuggestionStatsDisplay();
            }
        }

        // C·∫≠p nh·∫≠t hi·ªÉn th·ªã th·ªëng k√™ g·ª£i √Ω (Gi·ªØ nguy√™n)
        function updateSuggestionStatsDisplay() {
            const body = document.getElementById('suggestionStatsBody');
            if (!body) return;

            ['BUY', 'SELL'].forEach(type => {
                const stats = suggestionStats[type];
                const total = stats.total;
                const correct = stats.correct;
                const winRate = total > 0 ? ((correct / total) * 100).toFixed(2) : '0.00';

                document.getElementById(`stat${type}Total`).textContent = total;
                document.getElementById(`stat${type}Correct`).textContent = correct;
                document.getElementById(`stat${type}Pct`).textContent = `${winRate}%`;
            });
        }

        // H√†m v·∫Ω bi·ªÉu ƒë·ªì s·ªë d∆∞ & gi√° v√†ng
        function drawBalanceChart() {
            if (balanceChart) {
                balanceChart.destroy();
            }

            const dataToChart = balanceHistory;
            const labels = dataToChart.map(item => new Date(item.time).toLocaleTimeString('vi-VN'));
            const balanceData = dataToChart.map(item => item.balance);
            const goldPriceData = dataToChart.map(item => item.goldPrice);

            const ctx = document.getElementById('balanceChart').getContext('2d');
            balanceChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'S·ªë D∆∞ (USD)',
                            data: balanceData,
                            borderColor: '#0ecb81',
                            backgroundColor: 'rgba(14, 203, 129, 0.1)',
                            yAxisID: 'yBalance',
                            tension: 0.2,
                            pointRadius: 1,
                            pointHoverRadius: 5,
                        },
                        {
                            label: 'Gi√° V√†ng (XAU/USD)',
                            data: goldPriceData,
                            borderColor: '#d4af37',
                            backgroundColor: 'rgba(212, 175, 55, 0.1)',
                            yAxisID: 'yGold',
                            tension: 0.2,
                            pointRadius: 1,
                            pointHoverRadius: 5,
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            ticks: {
                                maxTicksLimit: 20
                            }
                        },
                        yBalance: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            title: {
                                display: true,
                                text: 'S·ªë D∆∞ (USD)',
                                color: '#0ecb81'
                            },
                            grid: {
                                color: 'rgba(14, 203, 129, 0.1)'
                            }
                        },
                        yGold: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            grid: {
                                drawOnChartArea: false
                            },
                            title: {
                                display: true,
                                text: 'Gi√° V√†ng (XAU/USD)',
                                color: '#d4af37'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                        }
                    }
                }
            });

            // K√≠ch ho·∫°t logic g·ª£i √Ω sau khi v·∫Ω bi·ªÉu ƒë·ªì (C·∫ßn thi·∫øt cho c·∫£ 2 ch·∫ø ƒë·ªô)
            setTimeout(() => { // ƒê√É TH√äM setTimeout THEO Y√äU C·∫¶U
                if (suggestionByDirectionEnabled) {
                    checkDirectionalSuggestion(); // G·ªçi h√†m g·ª£i √Ω theo h∆∞·ªõng
                } else if (suggestionByIntersectionEnabled) {
                    checkIntersectionSuggestion(); // G·ªçi h√†m g·ª£i √Ω giao nhau
                } else {
                    document.getElementById('suggestionDisplay').innerHTML = 'Ch∆∞a c√≥ ch·∫ø ƒë·ªô g·ª£i √Ω n√†o ƒë∆∞·ª£c b·∫≠t.';
                }
            }, 100);
        }

        // Ki·ªÉm tra g·ª£i √Ω Giao nhau C≈®
        function checkIntersectionSuggestion(isTradeCheck = false) {
            if (!balanceChart || !suggestionByIntersectionEnabled) return null;

            const dsBalance = balanceChart.data.datasets[0].data;
            const dsGold = balanceChart.data.datasets[1].data;
            const len = dsBalance.length;

            if (len < 2) return null;

            const minSlope = intersectionSettings.minSlope;
            const minGapPct = intersectionSettings.minGapPct / 100;
            const confirmDelay = intersectionSettings.confirmDelay;
            const suggestionMode = intersectionSettings.suggestionMode;

            let currentSuggestion = null;
            let lastIntersectionIndex = -1;

            // T√¨m ƒëi·ªÉm giao nhau g·∫ßn nh·∫•t (n∆°i Balance v√† GoldPrice b·∫±ng nhau ho·∫∑c c·∫Øt nhau)
            for (let i = len - 2; i >= 0; i--) {
                const bal1 = dsBalance[i];
                const bal2 = dsBalance[i + 1];
                const gold1 = dsGold[i];
                const gold2 = dsGold[i + 1];

                // Check for intersection
                const crossUp = bal1 <= gold1 && bal2 > gold2; // Gold C·∫Øt l√™n Balance (T√≠n hi·ªáu SELL)
                const crossDown = bal1 >= gold1 && bal2 < gold2; // Balance C·∫Øt l√™n Gold (T√≠n hi·ªáu BUY)

                if (crossUp || crossDown) {
                    lastIntersectionIndex = i;
                    
                    // Ki·ªÉm tra ƒëi·ªÅu ki·ªán x√°c nh·∫≠n (ƒë·ªô d·ªëc, kho·∫£ng c√°ch sau giao nhau)
                    if (lastIntersectionIndex + confirmDelay < len) {
                        const confirmIndex = lastIntersectionIndex + confirmDelay;
                        const balConfirm = dsBalance[confirmIndex];
                        const goldConfirm = dsGold[confirmIndex];
                        
                        const balanceSlope = (bal2 - bal1) / 1;
                        const goldSlope = (gold2 - gold1) / 1;

                        // T√≠n hi·ªáu SELL (Gold C·∫Øt l√™n Balance)
                        if (crossUp) {
                            // C·∫ßn Gold n·∫±m tr√™n Balance sau x√°c nh·∫≠n
                            const currentGap = (goldConfirm - balConfirm);
                            const minGap = goldConfirm * minGapPct;
                            
                            if (goldSlope > minSlope && currentGap > minGap) {
                                currentSuggestion = 'SELL';
                            }
                        }
                        
                        // T√≠n hi·ªáu BUY (Balance C·∫Øt l√™n Gold)
                        if (crossDown) {
                            // C·∫ßn Balance n·∫±m tr√™n Gold sau x√°c nh·∫≠n
                            const currentGap = (balConfirm - goldConfirm);
                            const minGap = balConfirm * minGapPct;

                            if (balanceSlope > minSlope && currentGap > minGap) {
                                currentSuggestion = 'BUY';
                            }
                        }
                    }

                    break; // Ch·ªâ quan t√¢m ƒë·∫øn giao nhau g·∫ßn nh·∫•t
                }
            }
            
            // X·ª≠ l√Ω hi·ªÉn th·ªã v√† √¢m thanh
            if (currentSuggestion) {
                const isSuggestionNew = alertedIntersectionIndices.size === 0 || !alertedIntersectionIndices.has(lastIntersectionIndex);
                const displayDiv = document.getElementById('suggestionDisplay');
                
                let isFiltered = false;
                if (suggestionMode === 'buy' && currentSuggestion === 'SELL') {
                    isFiltered = true;
                } else if (suggestionMode === 'sell' && currentSuggestion === 'BUY') {
                    isFiltered = true;
                }

                if (isFiltered) {
                    displayDiv.innerHTML = `G·ª£i √Ω ${currentSuggestion} ƒë√£ b·ªã l·ªçc b·ªüi ch·∫ø ƒë·ªô hi·ªÉn th·ªã (${suggestionMode}).`;
                    currentSuggestion = null; // V√¥ hi·ªáu h√≥a g·ª£i √Ω n·∫øu b·ªã l·ªçc
                } else {
                    displayDiv.innerHTML = `<div class="suggestion-box suggest-${currentSuggestion.toLowerCase()}">
                        ‚úÖ G·ª¢I √ù GIAO NHAU: ${currentSuggestion}
                    </div>`;

                    if (isSuggestionNew && !isTradeCheck) {
                        playNotificationSound('intersection', { suggestion: currentSuggestion }); // TH√äM data cho TTS
                        // L∆∞u l·∫°i ch·ªâ s·ªë giao nhau ƒë√£ c·∫£nh b√°o
                        alertedIntersectionIndices.add(lastIntersectionIndex);
                        // C·∫≠p nh·∫≠t th·ªëng k√™ (ch·ªâ c·∫≠p nh·∫≠t khi kh√¥ng ph·∫£i check trade)
                        suggestionStats[currentSuggestion].lastTime = new Date().toISOString();
                        suggestionStats[currentSuggestion].lastIndex = lastIntersectionIndex;
                        localStorage.setItem('suggestionStats', JSON.stringify(suggestionStats));
                        updateSuggestionStatsDisplay();
                    }
                }
            } else if (!isTradeCheck) {
                 if (lastIntersectionIndex === -1) {
                    document.getElementById('suggestionDisplay').innerHTML = 'Ch∆∞a ph√°t hi·ªán giao nhau n√†o.';
                } else {
                    document.getElementById('suggestionDisplay').innerHTML = `Giao nhau ƒë√£ x·∫£y ra t·∫°i #${lastIntersectionIndex} nh∆∞ng ch∆∞a ƒë·∫°t ƒëi·ªÅu ki·ªán d·ªëc/gap t·ªëi thi·ªÉu ho·∫∑c b·ªã l·ªçc b·ªüi ch·∫ø ƒë·ªô hi·ªÉn th·ªã.`;
                }
            }

            return currentSuggestion;
        }

        // ********** H√ÄM checkDirectionalSuggestion M·ªöI (Thay th·∫ø findDirectionalSuggestion) **********
        function checkDirectionalSuggestion(isTradeCheck = false) {
            if (!balanceChart || !suggestionByDirectionEnabled) return null;
            
            const dsBalance = balanceChart.data.datasets[0].data;
            const dsGold = balanceChart.data.datasets[1].data;
            const dataArray = (suggestionBaseLine === 'balance' ? dsBalance : dsGold);
            const len = dataArray.length;
            
            // L·∫•y ƒëi·ªÉm d·ªØ li·ªáu t·ª´ balanceHistory
            const currentMaxIndex = len - 1;
            const maxPoint = suggestionStartIndex; // Ch·ªâ s·ªë trong balanceHistory
            
            if (maxPoint > currentMaxIndex) {
                 if (!isTradeCheck) {
                    document.getElementById('suggestionDisplay').innerHTML = `‚ö†Ô∏è Ch·ªâ s·ªë ƒëi·ªÉm (${maxPoint}) v∆∞·ª£t qu√° d·ªØ li·ªáu hi·ªán t·∫°i (${currentMaxIndex}).`;
                }
                return null;
            }
            
            // L·∫•y d·ªØ li·ªáu t·ª´ ƒëi·ªÉm b·∫Øt ƒë·∫ßu ƒë·∫øn hi·ªán t·∫°i
            const startValue = dataArray[maxPoint]; // Gi√° tr·ªã t·∫°i ƒëi·ªÉm b·∫Øt ƒë·∫ßu
            const currentValue = dataArray[currentMaxIndex]; // Gi√° tr·ªã hi·ªán t·∫°i (ƒëi·ªÉm cu·ªëi)
            
            // L·∫•y d·ªØ li·ªáu x√°c nh·∫≠n h∆∞·ªõng (s·ªë ƒëi·ªÉm g·∫ßn nh·∫•t)
            const confirmStart = Math.max(maxPoint, currentMaxIndex - directionConfirmationPoints);
            const confirmData = dataArray.slice(confirmStart, currentMaxIndex + 1);

            if (confirmData.length < directionConfirmationPoints + 1 && maxPoint > 0) {
                 if (!isTradeCheck) {
                    document.getElementById('suggestionDisplay').innerHTML = `‚ö†Ô∏è Ch∆∞a ƒë·ªß ${directionConfirmationPoints + 1} ƒëi·ªÉm d·ªØ li·ªáu ƒë·ªÉ x√°c nh·∫≠n h∆∞·ªõng (ch·ªâ c√≥ ${confirmData.length} ƒëi·ªÉm t·ª´ #${confirmStart} ƒë·∫øn #${currentMaxIndex}).`;
                }
                return null;
            }

            let currentSuggestion = null;

            // **********************************************
            // LOGIC X√ÅC ƒê·ªäNH H∆Ø·ªöNG M·ªöI (D·ª±a tr√™n xu h∆∞·ªõng)
            // **********************************************

            // 1. So s√°nh ƒêi·ªÉm hi·ªán t·∫°i v·ªõi ƒêi·ªÉm b·∫Øt ƒë·∫ßu
            if (currentValue > startValue) {
                currentSuggestion = 'BUY';
            } else if (currentValue < startValue) {
                currentSuggestion = 'SELL';
            } else {
                currentSuggestion = null; // Gi√° kh√¥ng thay ƒë·ªïi so v·ªõi ƒëi·ªÉm b·∫Øt ƒë·∫ßu
            }

            // 2. Ki·ªÉm tra h∆∞·ªõng x√°c nh·∫≠n (tƒÉng/gi·∫£m li√™n t·ª•c)
            if (currentSuggestion) {
                let isDirectionConfirmed = true;
                if (currentSuggestion === 'BUY') {
                    // X√°c nh·∫≠n BUY: Gi√° tr·ªã ph·∫£i lu√¥n tƒÉng ho·∫∑c gi·ªØ nguy√™n trong c√°c b∆∞·ªõc x√°c nh·∫≠n
                    for (let i = 1; i < confirmData.length; i++) {
                        if (confirmData[i] < confirmData[i - 1]) {
                            isDirectionConfirmed = false;
                            break;
                        }
                    }
                } else if (currentSuggestion === 'SELL') {
                    // X√°c nh·∫≠n SELL: Gi√° tr·ªã ph·∫£i lu√¥n gi·∫£m ho·∫∑c gi·ªØ nguy√™n trong c√°c b∆∞·ªõc x√°c nh·∫≠n
                    for (let i = 1; i < confirmData.length; i++) {
                        if (confirmData[i] > confirmData[i - 1]) {
                            isDirectionConfirmed = false;
                            break;
                        }
                    }
                }

                if (!isDirectionConfirmed) {
                    currentSuggestion = null; // H∆∞·ªõng kh√¥ng ƒë∆∞·ª£c x√°c nh·∫≠n
                }
            }


            // **********************************************
            // X·ª≠ l√Ω hi·ªÉn th·ªã v√† √¢m thanh
            // **********************************************
            if (currentSuggestion) {
                const displayDiv = document.getElementById('suggestionDisplay');

                // Ch·ªâ hi·ªÉn th·ªã/ph√°t √¢m thanh n·∫øu g·ª£i √Ω m·ªõi ho·∫∑c g·ª£i √Ω ƒë√£ ƒë∆∞·ª£c x√°c nh·∫≠n (v√† kh√¥ng ph·∫£i ki·ªÉm tra l·ªánh)
                if (lastDirectionalSuggestion !== currentSuggestion && !isTradeCheck) {
                    displayDiv.innerHTML = `<div class="suggestion-box suggest-${currentSuggestion.toLowerCase()}">
                        ‚úÖ G·ª¢I √ù THEO H∆Ø·ªöNG: ${currentSuggestion} (ƒêi·ªÉm #${maxPoint})
                    </div>`;

                    playNotificationSound('suggestion', { suggestion: currentSuggestion }); // TH√äM data cho TTS
                    
                    // C·∫≠p nh·∫≠t tr·∫°ng th√°i g·ª£i √Ω
                    lastDirectionalSuggestion = currentSuggestion;
                    localStorage.setItem('lastDirectionalSuggestion', lastDirectionalSuggestion);
                    
                    // C·∫≠p nh·∫≠t th·ªëng k√™ (ch·ªâ c·∫≠p nh·∫≠t khi kh√¥ng ph·∫£i check trade)
                    suggestionStats[currentSuggestion].lastTime = new Date().toISOString();
                    suggestionStats[currentSuggestion].lastIndex = currentMaxIndex;
                    localStorage.setItem('suggestionStats', JSON.stringify(suggestionStats));
                    updateSuggestionStatsDisplay();
                } else if (isTradeCheck) {
                    // N·∫øu ƒëang check trade, ch·ªâ c·∫ßn tr·∫£ v·ªÅ k·∫øt qu·∫£
                } else {
                     displayDiv.innerHTML = `<div class="suggestion-box suggest-${currentSuggestion.toLowerCase()}">
                        ‚úÖ G·ª¢I √ù THEO H∆Ø·ªöNG: ${currentSuggestion} (ƒêang duy tr√¨ t·ª´ ƒêi·ªÉm #${maxPoint})
                    </div>`;
                }

            } else if (!isTradeCheck) {
                document.getElementById('suggestionDisplay').innerHTML = `Kh√¥ng c√≥ g·ª£i √Ω (${suggestionBaseLine}) t·∫°i ƒêi·ªÉm #${maxPoint}.`;
                // Reset tr·∫°ng th√°i g·ª£i √Ω n·∫øu h∆∞·ªõng kh√¥ng ƒë∆∞·ª£c x√°c nh·∫≠n
                if (lastDirectionalSuggestion !== null) {
                    lastDirectionalSuggestion = null;
                    localStorage.setItem('lastDirectionalSuggestion', null);
                    logStatus('üîÑ ƒê√£ reset g·ª£i √Ω theo h∆∞·ªõng.');
                }
            }
            
            return currentSuggestion;
        }

        // T·∫£i c√†i ƒë·∫∑t G·ª£i √Ω theo h∆∞·ªõng (M·ªöI)
        function loadDirectionalSettings() {
            suggestionByDirectionEnabled = localStorage.getItem('suggestionByDirectionEnabled') === 'true'; 
            suggestionByIntersectionEnabled = localStorage.getItem('suggestionByIntersectionEnabled') === 'true'; 
            suggestionBaseLine = localStorage.getItem('suggestionBaseLine') || 'balance';
            suggestionStartIndex = parseInt(localStorage.getItem('suggestionStartIndex')) || 0;
            directionConfirmationPoints = parseInt(localStorage.getItem('directionConfirmationPoints')) || 3;
            lastDirectionalSuggestion = localStorage.getItem('lastDirectionalSuggestion') || null;

            // T·∫£i c√†i ƒë·∫∑t ƒëi·ªÉm
            nextPointMode = localStorage.getItem('nextPointMode') || 'fixed';
            fixedInterval = parseInt(localStorage.getItem('fixedInterval')) || 5;
            customPoints = JSON.parse(localStorage.getItem('customPoints')) || [0, 5, 10, 15, 20, 25];
            currentPointIndex = parseInt(localStorage.getItem('currentPointIndex')) || 0;

            if (document.getElementById('suggestionByDirectionEnabled')) {
                document.getElementById('suggestionByDirectionEnabled').checked = suggestionByDirectionEnabled;
            }
            if (document.getElementById('suggestionByIntersectionEnabled')) {
                document.getElementById('suggestionByIntersectionEnabled').checked = suggestionByIntersectionEnabled;
            }
            if (document.getElementById('suggestionBaseLine')) {
                document.getElementById('suggestionBaseLine').value = suggestionBaseLine;
            }
            if (document.getElementById('directionConfirmationPoints')) {
                document.getElementById('directionConfirmationPoints').value = directionConfirmationPoints;
            }
            
            // T·∫£i c√†i ƒë·∫∑t ƒëi·ªÉm
            if (document.getElementById('nextPointMode')) {
                document.getElementById('nextPointMode').value = nextPointMode;
            }
            if (document.getElementById('fixedInterval')) {
                document.getElementById('fixedInterval').value = fixedInterval;
            }
            if (document.getElementById('customPoints')) {
                document.getElementById('customPoints').value = customPoints.join(',');
            }
            updateCurrentPointDisplay();
            
            togglePointModeSettings();
            toggleSuggestionMode();
        }

        // H√†m l∆∞u c√†i ƒë·∫∑t h∆∞·ªõng (M·ªöI)
        function saveDirectionalSettings() {
            suggestionBaseLine = document.getElementById('suggestionBaseLine').value;
            directionConfirmationPoints = parseInt(document.getElementById('directionConfirmationPoints').value);

            // TH√äM: L∆∞u c√†i ƒë·∫∑t ƒëi·ªÉm ti·∫øp theo
            nextPointMode = document.getElementById('nextPointMode').value;
            fixedInterval = parseInt(document.getElementById('fixedInterval').value);
            customPoints = document.getElementById('customPoints').value.split(',')
                .map(p => parseInt(p.trim()))
                .filter(p => !isNaN(p));
            
            // ƒê·∫£m b·∫£o currentPointIndex n·∫±m trong danh s√°ch customPoints (n·∫øu d√πng ch·∫ø ƒë·ªô custom)
            if (nextPointMode === 'custom' && customPoints.length > 0) {
                if (!customPoints.includes(currentPointIndex)) {
                    // N·∫øu ƒëi·ªÉm hi·ªán t·∫°i kh√¥ng c√≥ trong danh s√°ch m·ªõi, chuy·ªÉn v·ªÅ ƒëi·ªÉm ƒë·∫ßu ti√™n
                    currentPointIndex = customPoints[0];
                }
            } else if (nextPointMode === 'fixed') {
                // ƒê·∫£m b·∫£o fixedInterval l√† s·ªë d∆∞∆°ng
                if (fixedInterval <= 0 || isNaN(fixedInterval)) {
                    fixedInterval = 5;
                    document.getElementById('fixedInterval').value = 5;
                }
            }

            // L∆∞u v√†o localStorage
            localStorage.setItem('suggestionBaseLine', suggestionBaseLine);
            localStorage.setItem('directionConfirmationPoints', directionConfirmationPoints);
            
            localStorage.setItem('nextPointMode', nextPointMode);
            localStorage.setItem('fixedInterval', fixedInterval);
            localStorage.setItem('customPoints', JSON.stringify(customPoints));
            localStorage.setItem('currentPointIndex', currentPointIndex);
            
            // Lu√¥n ƒë·ªìng b·ªô suggestionStartIndex v·ªõi currentPointIndex
            suggestionStartIndex = currentPointIndex; 
            localStorage.setItem('suggestionStartIndex', suggestionStartIndex);

            logStatus('üíæ ƒê√£ l∆∞u c·∫•u h√¨nh g·ª£i √Ω theo h∆∞·ªõng & ƒëi·ªÉm ti·∫øp theo');
            alert('‚úÖ ƒê√£ l∆∞u c·∫•u h√¨nh g·ª£i √Ω theo h∆∞·ªõng!');
            drawBalanceChart();
            updateCurrentPointDisplay();
        }

        // H√†m chuy·ªÉn ƒë·ªïi ch·∫ø ƒë·ªô g·ª£i √Ω (M·ªöI)
        function toggleSuggestionMode() {
            suggestionByDirectionEnabled = document.getElementById('suggestionByDirectionEnabled').checked;
            suggestionByIntersectionEnabled = document.getElementById('suggestionByIntersectionEnabled').checked;

            document.getElementById('directionalSettingsContainer').style.display = suggestionByDirectionEnabled ? 'block' : 'none';
            document.getElementById('intersectionSettingsContainer').style.display = suggestionByIntersectionEnabled ? 'block' : 'none';

            if (!suggestionByDirectionEnabled && !suggestionByIntersectionEnabled) {
                document.getElementById('suggestionDisplay').innerHTML = 'Ch∆∞a c√≥ ch·∫ø ƒë·ªô g·ª£i √Ω n√†o ƒë∆∞·ª£c b·∫≠t.';
            }

            localStorage.setItem('suggestionByDirectionEnabled', suggestionByDirectionEnabled);
            localStorage.setItem('suggestionByIntersectionEnabled', suggestionByIntersectionEnabled);
            
            logStatus(`G·ª£i √Ω Theo H∆∞·ªõng: ${suggestionByDirectionEnabled ? 'B·∫≠t' : 'T·∫Øt'} | G·ª£i √Ω Giao nhau: ${suggestionByIntersectionEnabled ? 'B·∫≠t' : 'T·∫Øt'}`);
            drawBalanceChart(); // V·∫Ω l·∫°i ƒë·ªÉ k√≠ch ho·∫°t logic g·ª£i √Ω m·ªõi
        }

        // H√ÄM CHUY·ªÇN ƒê·ªîI HI·ªÇN TH·ªä C√ÄI ƒê·∫∂T ƒêI·ªÇM M·ªöI (Gi·ªØ nguy√™n)
        function togglePointModeSettings() {
            const mode = document.getElementById('nextPointMode').value;
            document.getElementById('fixedIntervalSettings').style.display = mode === 'fixed' ? 'flex' : 'none';
            document.getElementById('customPointsSettings').style.display = mode === 'custom' ? 'flex' : 'none';
        }

        // H√ÄM T·ª∞ ƒê·ªòNG CHUY·ªÇN ƒê·∫æN ƒêI·ªÇM TI·∫æP THEO (M·ªöI)
        function advanceToNextPoint() {
            const currentMaxIndex = balanceHistory.length - 1;

            if (currentPointIndex >= currentMaxIndex) {
                logStatus(`‚ö†Ô∏è ƒê√£ ƒë·∫°t ƒë·∫øn ƒëi·ªÉm cu·ªëi c√πng (${currentMaxIndex}). Kh√¥ng th·ªÉ chuy·ªÉn ti·∫øp.`);
                return;
            }

            let nextPoint = currentPointIndex;

            if (nextPointMode === 'fixed') {
                // Ch·∫ø ƒë·ªô kho·∫£ng c·ªë ƒë·ªãnh: currentPointIndex + fixedInterval
                nextPoint = currentPointIndex + fixedInterval;
            } else {
                // Ch·∫ø ƒë·ªô danh s√°ch t√πy ch·ªânh: ƒëi ƒë·∫øn ƒëi·ªÉm ti·∫øp theo trong m·∫£ng
                const currentIndexInArray = customPoints.indexOf(currentPointIndex);
                if (currentIndexInArray !== -1 && currentIndexInArray < customPoints.length - 1) {
                    nextPoint = customPoints[currentIndexInArray + 1];
                } else if (customPoints.length > 0) {
                    // N·∫øu ƒë√£ ƒë·∫øn cu·ªëi danh s√°ch (ho·∫∑c ƒëi·ªÉm hi·ªán t·∫°i kh√¥ng ph·∫£i l√† ƒëi·ªÉm cu·ªëi), quay l·∫°i ƒëi·ªÉm ƒë·∫ßu
                    nextPoint = customPoints[0];
                }
            }

            // ƒê·∫£m b·∫£o ƒëi·ªÉm ti·∫øp theo kh√¥ng v∆∞·ª£t qu√° ch·ªâ s·ªë hi·ªán t·∫°i c·ªßa balanceHistory
            if (nextPoint > currentMaxIndex && currentMaxIndex >= 0) {
                nextPoint = currentMaxIndex;
                logStatus(`‚ö†Ô∏è ƒêi·ªÉm ti·∫øp theo v∆∞·ª£t qu√° ƒëi·ªÉm t·ªëi ƒëa (${currentMaxIndex}). ƒê√£ ƒëi·ªÅu ch·ªânh v·ªÅ #${currentMaxIndex}.`);
            } else if (nextPoint < 0) {
                nextPoint = 0;
            }

            currentPointIndex = nextPoint;

            // C·∫≠p nh·∫≠t suggestionStartIndex v·ªõi ƒëi·ªÉm m·ªõi
            suggestionStartIndex = currentPointIndex;

            // L∆∞u tr·∫°ng th√°i
            localStorage.setItem('currentPointIndex', currentPointIndex);
            localStorage.setItem('suggestionStartIndex', suggestionStartIndex);

            // Reset g·ª£i √Ω ƒë·ªÉ t√¨m h∆∞·ªõng m·ªõi
            lastDirectionalSuggestion = null;
            localStorage.setItem('lastDirectionalSuggestion', null);

            logStatus(`üîÑ Chuy·ªÉn ƒë·∫øn ƒëi·ªÉm ti·∫øp theo: #${currentPointIndex}`);
            updateCurrentPointDisplay();
        }

        // H√ÄM C·∫¨P NH·∫¨T HI·ªÇN TH·ªä ƒêI·ªÇM HI·ªÜN T·∫†I (Gi·ªØ nguy√™n)
        function updateCurrentPointDisplay() {
            document.getElementById('currentPointDisplay').textContent = currentPointIndex;
        }

        // H√ÄM CHUY·ªÇN ƒêI·ªÇM TH·ª¶ C√îNG (Gi·ªØ nguy√™n)
        function manualAdvancePoint() {
            advanceToNextPoint();
            drawBalanceChart(); // V·∫Ω l·∫°i bi·ªÉu ƒë·ªì ƒë·ªÉ k√≠ch ho·∫°t ph√¢n t√≠ch m·ªõi
        }

        // H√ÄM ƒê·∫∂T ƒêI·ªÇM TH·ª¶ C√îNG M·ªöI
        function setManualPoint() {
            const manualPoint = parseInt(document.getElementById('manualPointInput').value);
            const maxIndex = balanceHistory.length - 1;

            if (isNaN(manualPoint) || manualPoint < 0 || manualPoint > maxIndex) {
                alert(`‚ùå ƒêi·ªÉm kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p s·ªë t·ª´ 0 ƒë·∫øn ${maxIndex}.`);
                return;
            }

            currentPointIndex = manualPoint;
            suggestionStartIndex = manualPoint;

            localStorage.setItem('currentPointIndex', currentPointIndex);
            localStorage.setItem('suggestionStartIndex', suggestionStartIndex);
            lastDirectionalSuggestion = null; // Reset g·ª£i √Ω khi ƒë·∫∑t l·∫°i ƒëi·ªÉm
            localStorage.setItem('lastDirectionalSuggestion', null);

            // C·∫≠p nh·∫≠t hi·ªÉn th·ªã
            updateCurrentPointDisplay();
            drawBalanceChart();
            logStatus(`üéØ ƒê√£ ƒë·∫∑t ƒëi·ªÉm hi·ªán t·∫°i th·ªß c√¥ng: #${currentPointIndex}`);
            alert(`‚úÖ ƒê√£ ƒë·∫∑t ƒëi·ªÉm hi·ªán t·∫°i th√†nh: #${currentPointIndex}`);
        }
        // K·∫æT TH√öC H√ÄM ƒê·∫∂T ƒêI·ªÇM TH·ª¶ C√îNG M·ªöI

        // L∆∞u c√†i ƒë·∫∑t G·ª£i √Ω Giao nhau (Gi·ªØ nguy√™n)
        function saveIntersectionSettings() {
            intersectionSettings.minSlope = parseFloat(document.getElementById('minSlope').value);
            intersectionSettings.minGapPct = parseFloat(document.getElementById('minGapPct').value);
            intersectionSettings.confirmDelay = parseInt(document.getElementById('confirmDelay').value);
            intersectionSettings.suggestionMode = document.getElementById('suggestionMode').value;

            localStorage.setItem('intersectionSettings', JSON.stringify(intersectionSettings));
            logStatus('üíæ ƒê√£ l∆∞u c·∫•u h√¨nh g·ª£i √Ω giao d·ªãch (Giao nhau)');
            alert('‚úÖ ƒê√£ l∆∞u c·∫•u h√¨nh g·ª£i √Ω giao nhau!');
        }

        // T·∫£i c√†i ƒë·∫∑t G·ª£i √Ω Giao nhau (Gi·ªØ nguy√™n)
        function loadIntersectionSettings() {
            if (intersectionSettings) {
                if (document.getElementById('minSlope')) document.getElementById('minSlope').value = intersectionSettings.minSlope;
                if (document.getElementById('minGapPct')) document.getElementById('minGapPct').value = intersectionSettings.minGapPct;
                if (document.getElementById('confirmDelay')) document.getElementById('confirmDelay').value = intersectionSettings.confirmDelay;
                if (document.getElementById('suggestionMode')) document.getElementById('suggestionMode').value = intersectionSettings.suggestionMode;
            }
        }

        // Reset d·ªØ li·ªáu G·ª£i √Ω v√† th·ªëng k√™ (Gi·ªØ nguy√™n)
        function resetSuggestionData() {
            if (!confirm('B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën reset d·ªØ li·ªáu G·ª£i √Ω v√† Th·ªëng k√™?')) return;

            suggestionStats = { 
                BUY: { total: 0, correct: 0, lastIndex: -1, lastTime: null, lastTradeIndex: -1 },
                SELL: { total: 0, correct: 0, lastIndex: -1, lastTime: null, lastTradeIndex: -1 }
            };
            lastDirectionalSuggestion = null; // Gi·ªØ l·∫°i logic reset ƒëi·ªÉm m·ªõi
            currentPointIndex = 0;
            suggestionStartIndex = 0;

            localStorage.removeItem('suggestionStats');
            localStorage.removeItem('lastDirectionalSuggestion');
            localStorage.setItem('currentPointIndex', 0);
            localStorage.setItem('suggestionStartIndex', 0);

            document.getElementById('suggestionDisplay').innerHTML = 'Ch∆∞a c√≥ g·ª£i √Ω n√†o.';
            updateSuggestionStatsDisplay();
            updateCurrentPointDisplay();
            logStatus('üîÑ ƒê√£ reset d·ªØ li·ªáu g·ª£i √Ω v√† th·ªëng k√™');
        }

        // L∆∞u c√†i ƒë·∫∑t giao d·ªãch (Gi·ªØ nguy√™n)
        function saveTradingSettings() {
            const settings = {
                virtualBalance: parseFloat(document.getElementById('virtualBalance').value),
                leverage: parseFloat(document.getElementById('leverage').value),
                lotSize: parseFloat(document.getElementById('lotSize').value),
                stopLoss: parseFloat(document.getElementById('stopLoss').value),
                takeProfit: parseFloat(document.getElementById('takeProfit').value),
            };
            localStorage.setItem('tradingSettings', JSON.stringify(settings));
        }

        // T·∫£i c√†i ƒë·∫∑t giao d·ªãch (Gi·ªØ nguy√™n)
        function loadTradingSettings() {
            const savedSettings = JSON.parse(localStorage.getItem('tradingSettings'));
            if (savedSettings) {
                if (document.getElementById('virtualBalance')) document.getElementById('virtualBalance').value = savedSettings.virtualBalance;
                if (document.getElementById('leverage')) document.getElementById('leverage').value = savedSettings.leverage;
                if (document.getElementById('lotSize')) document.getElementById('lotSize').value = savedSettings.lotSize;
                if (document.getElementById('stopLoss')) document.getElementById('stopLoss').value = savedSettings.stopLoss;
                if (document.getElementById('takeProfit')) document.getElementById('takeProfit').value = savedSettings.takeProfit;
                virtualBalance = balanceHistory.length > 0 ? balanceHistory[balanceHistory.length - 1].balance : savedSettings.virtualBalance;
            }
        }

        // Reset d·ªØ li·ªáu (Gi·ªØ nguy√™n)
        function resetData() {
            if (!confirm('B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën X√ìA TO√ÄN B·ªò d·ªØ li·ªáu giao d·ªãch? (Bao g·ªìm l·ªãch s·ª≠, c√†i ƒë·∫∑t, v√† s·ªë d∆∞)')) return;

            // X√≥a LocalStorage
            localStorage.removeItem('tradingSettings');
            localStorage.removeItem('balanceHistory');
            localStorage.removeItem('intersectionSettings');
            localStorage.removeItem('suggestionStats');
            localStorage.removeItem('globalSoundUrl');
            localStorage.removeItem('soundUseStatus');
            localStorage.removeItem('defaultSoundsEnabled');
            localStorage.removeItem('enableTTSSound'); // TH√äM: Reset TTS
            // X√≥a c√†i ƒë·∫∑t m·ªõi
            localStorage.removeItem('suggestionByDirectionEnabled');
            localStorage.removeItem('suggestionByIntersectionEnabled');
            localStorage.removeItem('suggestionBaseLine');
            localStorage.removeItem('suggestionStartIndex');
            localStorage.removeItem('directionConfirmationPoints');
            localStorage.removeItem('lastDirectionalSuggestion');
            // TH√äM: Reset ƒëi·ªÉm
            localStorage.removeItem('currentPointIndex');
            localStorage.removeItem('nextPointMode');
            localStorage.removeItem('fixedInterval');
            localStorage.removeItem('customPoints');

            // Kh·ªüi t·∫°o l·∫°i c√°c bi·∫øn
            virtualBalance = 1000;
            tradesToday = 0;
            balanceHistory = [];
            currentTrades = [];
            alertLevels = [];
            alertedLevels.clear();
            alertedIntersectionIndices.clear();
            userGlobalNotifySound = null;
            soundUseStatus = {};
            defaultSoundsEnabled = true;
            ttsEnabled = false; // TH√äM: Reset TTS
            // Kh·ªüi t·∫°o l·∫°i bi·∫øn g·ª£i √Ω
            suggestionByDirectionEnabled = false;
            suggestionByIntersectionEnabled = false;
            suggestionBaseLine = 'balance';
            suggestionStartIndex = 0;
            directionConfirmationPoints = 3;
            lastDirectionalSuggestion = null;
            suggestionStats = {
                BUY: { total: 0, correct: 0, lastIndex: -1, lastTime: null, lastTradeIndex: -1 },
                SELL: { total: 0, correct: 0, lastIndex: -1, lastTime: null, lastTradeIndex: -1 }
            };
            // TH√äM: Reset ƒëi·ªÉm
            currentPointIndex = 0;
            nextPointMode = 'fixed';
            fixedInterval = 5;
            customPoints = [0, 5, 10, 15, 20, 25];

            // T·∫£i l·∫°i c√†i ƒë·∫∑t ƒë·ªÉ c·∫≠p nh·∫≠t UI
            loadTradingSettings();
            loadDirectionalSettings();
            loadIntersectionSettings();
            loadSoundSettings();
            
            // Reset c√°c gi√° tr·ªã hi·ªÉn th·ªã kh√°c
            document.getElementById('currentPrice').textContent = '0.00';
            document.getElementById('statusText').textContent = 'Ch∆∞a b·∫Øt ƒë·∫ßu';
            document.getElementById('tradesCount').textContent = '0';
            document.getElementById('historyList').innerHTML = '';
            document.getElementById('suggestionDisplay').innerHTML = 'Ch∆∞a c√≥ g·ª£i √Ω n√†o.';

            // V·∫Ω l·∫°i bi·ªÉu ƒë·ªì r·ªóng
            initChart();

            alert('‚úÖ ƒê√£ reset to√†n b·ªô d·ªØ li·ªáu!');
            logStatus('üóëÔ∏è ƒê√£ reset to√†n b·ªô d·ªØ li·ªáu!');
        }

        // Ph√¢n t√≠ch hi·ªáu su·∫•t (Gi·ªØ nguy√™n)
        function analyzeBalanceHistory() {
            if (balanceHistory.length < 2) {
                alert('Kh√¥ng ƒë·ªß d·ªØ li·ªáu ƒë·ªÉ ph√¢n t√≠ch.');
                return;
            }

            const initialBalance = balanceHistory[0].balance;
            const finalBalance = virtualBalance;
            const totalProfit = finalBalance - initialBalance;
            const totalTrades = currentTrades.filter(t => t.closed).length;
            const profitableTrades = currentTrades.filter(t => t.closed && t.profit > 0).length;
            const winRate = totalTrades > 0 ? ((profitableTrades / totalTrades) * 100).toFixed(2) : '0.00';

            const analysis = `
                --- PH√ÇN T√çCH HI·ªÜU SU·∫§T ---
                - S·ªë d∆∞ ban ƒë·∫ßu: ${initialBalance.toFixed(2)} USD
                - T·ªïng s·ªë l·ªánh ƒë√£ ƒë√≥ng: ${totalTrades}
                - S·ªë l·ªánh th·∫Øng: ${profitableTrades}
                - T·ª∑ l·ªá th·∫Øng: ${winRate}%
                - T·ªïng l·ª£i nhu·∫≠n: ${totalProfit.toFixed(2)} USD
                - S·ªë d∆∞ hi·ªán t·∫°i: ${virtualBalance.toFixed(2)} USD
            `;
            alert(analysis);
            addHistory('üìà ƒê√£ ph√¢n t√≠ch hi·ªáu su·∫•t giao d·ªãch');
        }

        // H√†m x√≥a l·ªãch s·ª≠ (Gi·ªØ nguy√™n)
        function clearHistory() {
            if (!confirm('B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a l·ªãch s·ª≠ giao d·ªãch v√† log?')) return;
            document.getElementById('historyList').innerHTML = '';
            // KH√îNG x√≥a balanceHistory hay tradesToday
            logStatus('üóëÔ∏è ƒê√£ x√≥a log v√† l·ªãch s·ª≠ hi·ªÉn th·ªã');
        }

        // T·∫£i c√°c c√†i ƒë·∫∑t v√† kh·ªüi t·∫°o (Gi·ªØ nguy√™n)
        function loadSettingsAndInitialize() {
            loadTradingSettings();
            loadIntersectionSettings();
            loadDirectionalSettings(); // T·∫£i c√†i ƒë·∫∑t h∆∞·ªõng v√† ƒëi·ªÉm m·ªõi
            loadSoundSettings();

            // S·ª¨A L·ªñI 5: Th√™m t·∫£i alert levels t·ª´ localStorage
            const savedAlertLevels = JSON.parse(localStorage.getItem('alertLevels'));
            if (savedAlertLevels) {
                alertLevels = savedAlertLevels;
                document.getElementById('alertPrices').value = alertLevels.join(',');
            } else {
                updateAlertLevels(); // C·∫≠p nh·∫≠t m·ªëc c·∫£nh b√°o (ƒë·ªÉ l∆∞u m·∫£ng r·ªóng n·∫øu ch∆∞a c√≥)
            }

            updateStatus();
            initChart();
            toggleSuggestionMode(); // Ph·∫£i g·ªçi sau khi loadDirectionalSettings
        }

        window.onload = function() {
            loadSettingsAndInitialize();
            connectWebSocket(); // S·ª¨A L·ªñI 6: Th√™m log kh·ªüi ƒë·ªông
            addHistory('üîÑ ·ª®ng d·ª•ng kh·ªüi ƒë·ªông'); 
            
            // Ki·ªÉm tra gi√° ƒë·ª©ng im m·ªói 5 gi√¢y
            setInterval(checkPriceStagnation, 5000);

            // Listeners cho C√†i ƒë·∫∑t giao d·ªãch
            ['virtualBalance', 'leverage', 'lotSize', 'stopLoss', 'takeProfit'].forEach(id => {
                document.getElementById(id).addEventListener('change', saveTradingSettings);
            });

            // Listener cho M·ªëc c·∫£nh b√°o
            document.getElementById('alertPrices').addEventListener('change', updateAlertLevels);

            // Listeners cho C√†i ƒë·∫∑t G·ª£i √Ω Giao nhau (C≈®)
            ['minSlope', 'minGapPct', 'confirmDelay', 'suggestionMode'].forEach(id => {
                document.getElementById(id).addEventListener('change', saveIntersectionSettings);
            });

            // Listeners cho C√†i ƒë·∫∑t G·ª£i √Ω Theo H∆∞·ªõng (M·ªöI)
            ['suggestionBaseLine', 'directionConfirmationPoints'].forEach(id => {
                document.getElementById(id).addEventListener('change', saveDirectionalSettings);
            });
        };
    </script>
</body>
</html>
</div>

<div id="replayTab" class="tab-content">
<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ph√°t L·∫°i Bi·ªÉu ƒê·ªì S·ªë D∆∞ & Gi√° V√†ng</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root {
            --bg-color: #f8f9fa;
            --text-color: #333;
            --panel-bg: white;
            --border-color: #ddd;
            --primary-color: #d4af37;
            --secondary-color: #0ecb81;
            --accent-color: #f6465d;
        }
        .dark-mode {
            --bg-color: #1e2026;
            --text-color: #e0e0e0;
            --panel-bg: #2a2d35;
            --border-color: #444;
            --primary-color: #e5c046;
            --secondary-color: #0ecb81;
            --accent-color: #ff6b81;
        }
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 20px;
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: all 0.3s ease;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: var(--panel-bg);
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
            padding: 20px;
        }
        h1 {
            color: var(--primary-color);
            text-align: center;
            margin-bottom: 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .theme-toggle {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: var(--text-color);
        }
        .panel {
            background: var(--panel-bg);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            border: 1px solid var(--border-color);
        }
        .panel-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 15px;
            color: var(--text-color);
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 10px;
        }
        .control-group {
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        label {
            display: inline-block;
            width: 150px;
            font-weight: 500;
        }
        input[type="text"], input[type="number"], input[type="file"], select {
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: #f5f5f5;
            color: var(--text-color);
        }
        button {
            background-color: var(--primary-color);
            color: #1e2026;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            margin-right: 10px;
            transition: all 0.3s;
        }
        button:hover {
            background-color: #e5c046;
        }
        button.secondary {
            background-color: var(--secondary-color);
            color: white;
        }
        button.secondary:hover {
            background-color: #0d9e6e;
        }
        button.danger {
            background-color: var(--accent-color);
            color: white;
        }
        button.danger:hover {
            background-color: #ff6b81;
        }
        .chart-container {
            height: 400px;
            margin-bottom: 30px;
        }
        .status-display {
            font-size: 16px;
            font-weight: bold;
            padding: 10px;
            border: 1px solid var(--primary-color);
            border-radius: 4px;
            margin-bottom: 20px;
            background: #fff3cd;
            color: #856404;
            display: flex;
            justify-content: space-between;
        }
        .dark-mode .status-display {
            background: #3a3f4a;
            color: #e5c046;
            border-color: #e5c046;
        }
        .data-info {
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            margin-bottom: 15px;
            background: #f1f1f1;
        }
        .dark-mode .data-info {
            background: #3a3f4a;
        }
        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 15px;
        }
        .speed-btn {
            padding: 8px 12px;
            background-color: #ccc;
            color: #333;
            font-weight: normal;
        }
        .speed-btn.active {
            background-color: var(--primary-color);
            color: #1e2026;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>
            Ph√°t L·∫°i Bi·ªÉu ƒê·ªì S·ªë D∆∞ & Gi√° V√†ng
            <button id="themeToggle" class="theme-toggle">üåô</button>
        </h1>
        
        <div class="status-display" id="replayStatus">
            <div>Tr·∫°ng th√°i: <span id="statusTextReplay">Ch∆∞a t·∫£i d·ªØ li·ªáu</span></div>
            <div>Ch·ªâ s·ªë hi·ªán t·∫°i: <span id="currentIndex">0</span> / <span id="totalIndex">0</span></div>
            <div>S·ªë d∆∞: <span id="currentBalance">0.00</span> USD</div>
        </div>

        <div class="panel">
            <div class="panel-title">üìä D·ªØ Li·ªáu Bi·ªÉu ƒê·ªì</div>
            <div class="control-group">
                <label for="dataSource">Ngu·ªìn d·ªØ li·ªáu:</label>
                <select id="dataSource" onchange="toggleDataSource()">
                    <option value="localStorage">T·ª´ LocalStorage (Pro Gold Max)</option>
                    <option value="file">T·∫£i t·ª´ file JSON</option>
                    <option value="url">T·∫£i t·ª´ URL</option>
                </select>
            </div>
            <div id="fileUploadContainer" style="display: none;">
                <div class="control-group">
                    <label for="jsonFile">Ch·ªçn file JSON:</label>
                    <input type="file" id="jsonFile" accept=".json">
                </div>
            </div>
            <div id="urlUploadContainer" style="display: none;">
                <div class="control-group">
                    <label for="jsonUrl">Nh·∫≠p URL .json:</label>
                    <input type="text" id="jsonUrl" placeholder="https://vd.com/data.json">
                </div>
            </div>
            <div class="data-info" id="dataInfo">
                Ch∆∞a c√≥ d·ªØ li·ªáu. Vui l√≤ng t·∫£i d·ªØ li·ªáu t·ª´ LocalStorage, file JSON ho·∫∑c URL.
            </div>
            <div class="control-group">
                <button onclick="loadData()">T·∫£i D·ªØ Li·ªáu</button>
                <button class="secondary" onclick="exportData()">Xu·∫•t D·ªØ Li·ªáu</button>
            </div>
        </div>

        <div class="panel">
            <div class="panel-title">‚è± ƒêi·ªÅu Khi·ªÉn Ph√°t L·∫°i</div>
            <div class="control-group">
                <label for="intervalTime">Th·ªùi gian m·ªói ƒëi·ªÉm (gi√¢y):</label>
                <input type="number" id="intervalTime" value="3" min="0.1" step="0.1">
            </div>
            <div class="speed-control">
                <label>T·ªëc ƒë·ªô:</label>
                <button class="speed-btn" onclick="setSpeed(0.5)">0.5x</button>
                <button class="speed-btn active" onclick="setSpeed(1)">1x</button>
                <button class="speed-btn" onclick="setSpeed(2)">2x</button>
                <button class="speed-btn" onclick="setSpeed(5)">5x</button>
                <button class="speed-btn" onclick="setSpeed(10)">10x</button>
            </div>
            <div class="control-group" style="margin-top: 15px;">
                <label for="jumpTime">Nh·∫£y ƒë·∫øn gi·ªù:</label>
                <input type="time" id="jumpTime" step="60">
                <button onclick="jumpToTime()">Nh·∫£y</button>
                <label for="replayStartIndex">B·∫Øt ƒë·∫ßu t·∫°i Index:</label>
                <input type="number" id="replayStartIndex" value="0" min="0" style="width: 80px;">
            </div>
            <div class="control-group">
                <input type="checkbox" id="loopReplay">
                <label for="loopReplay" style="width: auto;">L·∫∑p l·∫°i (Loop)</label>
            </div>
            <div class="control-group" style="margin-top: 20px;">
                <button id="playBtn" onclick="startReplay()" disabled>‚ñ∂Ô∏è Ph√°t</button>
                <button id="pauseBtn" onclick="pauseReplay()" disabled>‚è∏Ô∏è T·∫°m d·ª´ng</button>
                <button id="resetBtn" onclick="resetReplay()">üîÑ Reset</button>
                <button id="skipForwardBtn" onclick="skipForward()">‚è© B·ªè qua</button>
                <button id="skipBackBtn" onclick="skipBack()">‚è™ L√πi l·∫°i</button>
            </div>
        </div>
        
        <div class="panel">
            <div class="panel-title">Bi·ªÉu ƒê·ªì Ph√°t L·∫°i</div>
            <div class="chart-container">
                <canvas id="replayChart"></canvas>
            </div>
        </div>
    </div>

    <script>
        let chartReplay;
        let chartData = [];
        let currentIndex = 0;
        let replayInterval = null;
        let isPlaying = false;
        let currentSpeed = 1;
        let replayStartIndex = 0;

        // Kh·ªüi t·∫°o bi·ªÉu ƒë·ªì r·ªóng
        function initChart() {
            const ctx = document.getElementById('replayChart').getContext('2d');
            
            if (chartReplay) {
                chartReplay.destroy();
            }

            chartReplay = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [
                        {
                            label: 'S·ªë D∆∞ (USD)',
                            data: [],
                            borderColor: '#0ecb81',
                            backgroundColor: 'rgba(14, 203, 129, 0.1)',
                            yAxisID: 'yBalance',
                            tension: 0.2,
                            pointRadius: 3,
                            pointBackgroundColor: '#0ecb81',
                        },
                        {
                            label: 'Gi√° V√†ng (XAU/USD)',
                            data: [],
                            borderColor: '#d4af37',
                            backgroundColor: 'rgba(212, 175, 55, 0.1)',
                            yAxisID: 'yGold',
                            tension: 0.2,
                            pointRadius: 1,
                            pointBackgroundColor: '#d4af37',
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            ticks: {
                                maxTicksLimit: 20
                            }
                        },
                        yBalance: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            title: {
                                display: true,
                                text: 'S·ªë D∆∞ (USD)',
                                color: '#0ecb81'
                            },
                            grid: {
                                color: 'rgba(14, 203, 129, 0.1)'
                            }
                        },
                        yGold: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            grid: {
                                drawOnChartArea: false
                            },
                            title: {
                                display: true,
                                text: 'Gi√° V√†ng (XAU/USD)',
                                color: '#d4af37'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                        },
                        tooltip: {
                            mode: 'index',
                            intersect: false,
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += new Intl.NumberFormat('vi-VN').format(context.parsed.y.toFixed(2));
                                    }
                                    return label;
                                }
                            }
                        }
                    }
                }
            });
        }

        // C·∫≠p nh·∫≠t bi·ªÉu ƒë·ªì theo currentIndex
        function updateChart() {
            if (chartData.length === 0) return;
            
            const slicedData = chartData.slice(0, currentIndex + 1);

            const labels = slicedData.map(item => new Date(item.time).toLocaleTimeString('vi-VN'));
            const balanceData = slicedData.map(item => item.balance);
            const goldPriceData = slicedData.map(item => item.goldPrice);

            chartReplay.data.labels = labels;
            chartReplay.data.datasets[0].data = balanceData;
            chartReplay.data.datasets[1].data = goldPriceData;
            
            // Highlight ƒëi·ªÉm hi·ªán t·∫°i
            chartReplay.data.datasets[0].pointBackgroundColor = Array(currentIndex).fill('#0ecb81');
            chartReplay.data.datasets[0].pointBackgroundColor[currentIndex] = 'white';
            chartReplay.data.datasets[0].pointBorderColor = Array(currentIndex).fill('#0ecb81');
            chartReplay.data.datasets[0].pointBorderColor[currentIndex] = 'red';
            chartReplay.data.datasets[0].pointBorderWidth = Array(currentIndex).fill(1);
            chartReplay.data.datasets[0].pointBorderWidth[currentIndex] = 3;
            chartReplay.data.datasets[0].pointRadius = Array(currentIndex).fill(3);
            chartReplay.data.datasets[0].pointRadius[currentIndex] = 6;


            chartReplay.update();
        }

        // C·∫≠p nh·∫≠t tr·∫°ng th√°i hi·ªÉn th·ªã
        function updateStatus() {
            document.getElementById('totalIndex').textContent = chartData.length > 0 ? chartData.length - 1 : 0;
            document.getElementById('currentIndex').textContent = currentIndex;
            
            if (chartData.length > 0) {
                const currentItem = chartData[currentIndex];
                document.getElementById('currentBalance').textContent = currentItem.balance.toFixed(2);
                document.getElementById('statusTextReplay').textContent = isPlaying ? 'ƒêang ph√°t' : 'ƒê√£ d·ª´ng';
                document.getElementById('replayStartIndex').value = replayStartIndex;
            } else {
                document.getElementById('currentBalance').textContent = '0.00';
                document.getElementById('statusTextReplay').textContent = 'Ch∆∞a t·∫£i d·ªØ li·ªáu';
                document.getElementById('replayStartIndex').value = 0;
            }
        }

        // T·∫£i d·ªØ li·ªáu t·ª´ localStorage, file ho·∫∑c URL
        function loadData() {
            const dataSource = document.getElementById('dataSource').value;
            if (dataSource === 'localStorage') {
                loadFromLocalStorage();
            } else if (dataSource === 'file') {
                loadFromFile();
            } else if (dataSource === 'url') {
                loadFromUrl();
            }
        }

        // ********** H√ÄM loadFromLocalStorage ƒê√É C·∫¨P NH·∫¨T **********
        function loadFromLocalStorage() {
          try {
            const balanceHistory = JSON.parse(localStorage.getItem('balanceHistory'));
            
            if (!balanceHistory || balanceHistory.length === 0) {
              document.getElementById('dataInfo').innerHTML = '‚ùå Kh√¥ng t√¨m th·∫•y d·ªØ li·ªáu. Vui l√≤ng t·∫£i file JSON tr∆∞·ªõc.';
              return;
            }
            
            chartData = balanceHistory.map(item => ({
              time: new Date(item.time),
              balance: item.balance,
              goldPrice: item.goldPrice || 0
            }));
            
            document.getElementById('dataInfo').innerHTML = `‚úÖ ƒê√£ t·∫£i ${chartData.length} ƒëi·ªÉm d·ªØ li·ªáu t·ª´ file JSON.`;
            initReplay();
            
          } catch (error) {
            document.getElementById('dataInfo').innerHTML = `‚ùå L·ªói khi t·∫£i d·ªØ li·ªáu: ${error.message}`;
          }
        }
        // ************************************************************

        // T·∫£i d·ªØ li·ªáu t·ª´ file JSON
        function loadFromFile() {
            const fileInput = document.getElementById('jsonFile');
            const file = fileInput.files[0];
            const dataInfo = document.getElementById('dataInfo');
            
            if (!file) {
                dataInfo.innerHTML = '‚ùå Vui l√≤ng ch·ªçn file JSON.';
                return;
            }

            dataInfo.innerHTML = 'ƒêang ƒë·ªçc file...';
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const jsonData = JSON.parse(e.target.result);

                    if (!Array.isArray(jsonData)) {
                        dataInfo.innerHTML = '‚ùå D·ªØ li·ªáu JSON kh√¥ng h·ª£p l·ªá. Ph·∫£i l√† m·∫£ng.';
                        return;
                    }

                    if (jsonData.length > 0) {
                        const firstItem = jsonData[0];
                        if (!firstItem.time || firstItem.balance === undefined || firstItem.goldPrice === undefined) {
                            dataInfo.innerHTML = '‚ùå C·∫•u tr√∫c d·ªØ li·ªáu kh√¥ng h·ª£p l·ªá. M·ªói m·ª•c c·∫ßn c√≥: time, balance, goldPrice.';
                            return;
                        }
                    }

                    chartData = jsonData.map(item => ({
                        ...item,
                        time: new Date(item.time) // Chuy·ªÉn ƒë·ªïi th√†nh ƒë·ªëi t∆∞·ª£ng Date
                    }));
                    
                    dataInfo.innerHTML = `‚úÖ ƒê√£ t·∫£i ${chartData.length} ƒëi·ªÉm d·ªØ li·ªáu t·ª´ file JSON.`;
                    initReplay();

                } catch (error) {
                    dataInfo.innerHTML = `‚ùå L·ªói khi ƒë·ªçc file JSON: ${error.message}`;
                }
            };
            reader.readAsText(file);
        }

        // T·∫£i d·ªØ li·ªáu t·ª´ URL
        async function loadFromUrl() {
            const urlInput = document.getElementById('jsonUrl');
            const url = urlInput.value;
            const dataInfo = document.getElementById('dataInfo');
            
            if (!url) {
                dataInfo.innerHTML = '‚ùå Vui l√≤ng nh·∫≠p URL c·ªßa file JSON.';
                return;
            }

            dataInfo.innerHTML = 'ƒêang t·∫£i d·ªØ li·ªáu t·ª´ URL...';

            try {
                const response = await fetch(url);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const jsonData = await response.json();

                if (!Array.isArray(jsonData)) {
                    dataInfo.innerHTML = '‚ùå D·ªØ li·ªáu JSON kh√¥ng h·ª£p l·ªá. Ph·∫£i l√† m·∫£ng.';
                    return;
                }

                if (jsonData.length > 0) {
                    const firstItem = jsonData[0];
                    if (!firstItem.time || firstItem.balance === undefined || firstItem.goldPrice === undefined) {
                        dataInfo.innerHTML = '‚ùå C·∫•u tr√∫c d·ªØ li·ªáu kh√¥ng h·ª£p l·ªá. M·ªói m·ª•c c·∫ßn c√≥: time, balance, goldPrice.';
                        return;
                    }
                }

                chartData = jsonData.map(item => ({
                    ...item,
                    time: new Date(item.time) // Chuy·ªÉn ƒë·ªïi th√†nh ƒë·ªëi t∆∞·ª£ng Date
                }));
                
                dataInfo.innerHTML = `‚úÖ ƒê√£ t·∫£i ${chartData.length} ƒëi·ªÉm d·ªØ li·ªáu t·ª´ URL.`;
                initReplay();

            } catch (error) {
                dataInfo.innerHTML = `‚ùå L·ªói khi t·∫£i d·ªØ li·ªáu t·ª´ URL: ${error.message}`;
            }
        }

        // Xu·∫•t d·ªØ li·ªáu
        function exportData() {
            if (chartData.length === 0) {
                alert('Kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ xu·∫•t.');
                return;
            }
            const dataStr = JSON.stringify(chartData, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'replay_data_' + new Date().toISOString().split('T')[0] + '.json';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            alert(`‚úÖ ƒê√£ xu·∫•t ${chartData.length} ƒëi·ªÉm d·ªØ li·ªáu!`);
        }

        // H√†m ƒë∆∞·ª£c g·ªçi sau khi t·∫£i d·ªØ li·ªáu th√†nh c√¥ng
        function initReplay() {
            pauseReplay();
            currentIndex = replayStartIndex = parseInt(document.getElementById('replayStartIndex').value) || 0;
            if (chartData.length > 0 && currentIndex >= chartData.length) {
                currentIndex = replayStartIndex = chartData.length - 1;
            } else if (currentIndex < 0) {
                currentIndex = replayStartIndex = 0;
            }

            updateChart();
            updateStatus();
            document.getElementById('playBtn').disabled = chartData.length === 0;
            document.getElementById('replayStartIndex').max = chartData.length > 0 ? chartData.length - 1 : 0;
            document.getElementById('totalIndex').textContent = chartData.length > 0 ? chartData.length - 1 : 0;
        }
        
        // ƒêi·ªÅu khi·ªÉn replay
        function startReplay() {
            if (isPlaying || chartData.length === 0) return;
            
            const isLooping = document.getElementById('loopReplay').checked;
            
            if (currentIndex >= chartData.length) {
                currentIndex = replayStartIndex;
                updateChart();
                updateStatus();
            }

            isPlaying = true;
            document.getElementById('playBtn').disabled = true;
            document.getElementById('pauseBtn').disabled = false;
            
            const intervalTime = parseFloat(document.getElementById('intervalTime').value) * 1000 / currentSpeed;

            replayInterval = setInterval(() => {
                currentIndex++;
                
                if (currentIndex >= chartData.length) {
                    if (isLooping) {
                        currentIndex = replayStartIndex;
                    } else {
                        pauseReplay();
                        return;
                    }
                }
                updateChart();
                updateStatus();
            }, intervalTime);
        }

        // T·∫°m d·ª´ng replay
        function pauseReplay() {
            isPlaying = false;
            document.getElementById('playBtn').disabled = false;
            document.getElementById('pauseBtn').disabled = true;
            if (replayInterval) {
                clearInterval(replayInterval);
                replayInterval = null;
            }
        }

        // Reset replay
        function resetReplay() {
            pauseReplay();
            replayStartIndex = parseInt(document.getElementById('replayStartIndex').value) || 0;
            currentIndex = replayStartIndex;
            updateChart();
            updateStatus();
        }

        // Nh·∫£y t·ªõi th·ªùi gian
        function jumpToTime() {
            const timeInput = document.getElementById('jumpTime').value;
            if (!timeInput) {
                alert('Vui l√≤ng ch·ªçn th·ªùi gian.');
                return;
            }
            if (chartData.length === 0) {
                alert('Vui l√≤ng t·∫£i d·ªØ li·ªáu tr∆∞·ªõc.');
                return;
            }

            const [targetHours, targetMinutes] = timeInput.split(':').map(Number);
            const targetTotalMinutes = targetHours * 60 + targetMinutes;

            let bestIndex = -1;
            let minDiff = Infinity;

            for (let i = 0; i < chartData.length; i++) {
                const itemTime = chartData[i].time;
                const itemTotalMinutes = itemTime.getHours() * 60 + itemTime.getMinutes();
                const diff = Math.abs(itemTotalMinutes - targetTotalMinutes);

                if (diff < minDiff) {
                    minDiff = diff;
                    bestIndex = i;
                }
            }

            if (bestIndex !== -1) {
                pauseReplay();
                replayStartIndex = bestIndex;
                currentIndex = bestIndex;
                updateChart();
                updateStatus();
            }
        }

        // Nh·∫£y ƒë·∫øn ƒëi·ªÉm ti·∫øp theo
        function skipForward() {
            if (currentIndex < chartData.length - 1) {
                currentIndex++;
                updateChart();
                updateStatus();
            }
        }

        // L√πi l·∫°i ƒëi·ªÉm tr∆∞·ªõc
        function skipBack() {
            if (currentIndex > 0) {
                currentIndex--;
                updateChart();
                updateStatus();
            }
        }

        // ƒê·∫∑t t·ªëc ƒë·ªô
        function setSpeed(speed) {
            currentSpeed = speed;
            document.querySelectorAll('.speed-btn').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`.speed-control button:nth-child(${speed === 0.5 ? 2 : speed === 1 ? 3 : speed === 2 ? 4 : speed === 5 ? 5 : 6})`).classList.add('active');
            
            // N·∫øu ƒëang ph√°t, kh·ªüi ƒë·ªông l·∫°i interval v·ªõi t·ªëc ƒë·ªô m·ªõi
            if (isPlaying) {
                pauseReplay();
                startReplay();
            }
        }

        // Chuy·ªÉn ƒë·ªïi ngu·ªìn d·ªØ li·ªáu
        function toggleDataSource() {
            const dataSource = document.getElementById('dataSource').value;
            document.getElementById('fileUploadContainer').style.display = dataSource === 'file' ? 'flex' : 'none';
            document.getElementById('urlUploadContainer').style.display = dataSource === 'url' ? 'flex' : 'none';
        }

        // Chuy·ªÉn ƒë·ªïi ch·∫ø ƒë·ªô s√°ng/t·ªëi
        function toggleTheme() {
            document.body.classList.toggle('dark-mode');
            const themeToggle = document.getElementById('themeToggle');
            themeToggle.textContent = document.body.classList.contains('dark-mode') ? '‚òÄÔ∏è' : 'üåô';
            if (chartReplay) {
                chartReplay.options.scales.yBalance.title.color = document.body.classList.contains('dark-mode') ? '#0ecb81' : '#0ecb81';
                chartReplay.options.scales.yGold.title.color = document.body.classList.contains('dark-mode') ? '#e5c046' : '#d4af37';
                chartReplay.update();
            }
        }

        // Kh·ªüi t·∫°o khi trang t·∫£i
        window.onload = function() {
            initChart();
            document.getElementById('themeToggle').addEventListener('click', toggleTheme);
            document.getElementById('replayStartIndex').addEventListener('change', initReplay);
            
            // Th·ª≠ t·∫£i d·ªØ li·ªáu t·ª´ localStorage ngay l·∫≠p t·ª©c n·∫øu c√≥ c·ªù replayReady
            if (localStorage.getItem('replayReady') === 'true') {
                 document.getElementById('dataSource').value = 'localStorage';
                 loadFromLocalStorage();
            } else {
                // T·∫£i l·∫°i setting UI cho input file/url n·∫øu c·∫ßn
                toggleDataSource();
            }
        };
    </script>
</body>
</html>
</div>
<script>
// Tab switching
const liveTabBtn = document.getElementById('liveTabBtn');
const replayTabBtn = document.getElementById('replayTabBtn');
const liveTab = document.getElementById('liveTab');
const replayTab = document.getElementById('replayTab');
const transferBtn = document.getElementById('transferDataBtn');

liveTabBtn.onclick = () => {
  liveTabBtn.classList.add('active');
  replayTabBtn.classList.remove('active');
  liveTab.classList.add('active');
  replayTab.classList.remove('active');
};

replayTabBtn.onclick = () => {
  replayTabBtn.classList.add('active');
  liveTabBtn.classList.remove('active');
  replayTab.classList.add('active');
  liveTab.classList.remove('active');
};

// T·∫°o input file ·∫©n ƒë·ªÉ ch·ªçn JSON
const fileInput = document.createElement('input');
fileInput.type = 'file';
fileInput.accept = '.json';
fileInput.style.display = 'none';
document.body.appendChild(fileInput);

// X·ª≠ l√Ω t·∫£i d·ªØ li·ªáu JSON
transferBtn.onclick = () => {
  fileInput.click();
};

fileInput.addEventListener('change', function(e) {
  const file = e.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const jsonData = JSON.parse(e.target.result);
      
      // Ki·ªÉm tra c·∫•u tr√∫c d·ªØ li·ªáu
      if (!Array.isArray(jsonData)) {
        alert('‚ùå D·ªØ li·ªáu JSON kh√¥ng h·ª£p l·ªá. Ph·∫£i l√† m·∫£ng.');
        return;
      }
      
      if (jsonData.length > 0) {
        const firstItem = jsonData[0];
        // Ki·ªÉm tra c√°c tr∆∞·ªùng c·∫ßn thi·∫øt (bao g·ªìm goldPrice)
        if (!firstItem.time || firstItem.balance === undefined || firstItem.goldPrice === undefined) {
          alert('‚ùå C·∫•u tr√∫c d·ªØ li·ªáu kh√¥ng h·ª£p l·ªá. C·∫ßn c√≥: time, balance, goldPrice');
          return;
        }
      }
      
      // L∆∞u d·ªØ li·ªáu v√†o localStorage ƒë·ªÉ tab ph√°t l·∫°i s·ª≠ d·ª•ng
      localStorage.setItem('balanceHistory', JSON.stringify(jsonData));
      localStorage.setItem('replayReady', 'true');
      
      alert(`‚úÖ ƒê√£ t·∫£i th√†nh c√¥ng ${jsonData.length} ƒëi·ªÉm d·ªØ li·ªáu!`);
      
      // T·ª± ƒë·ªông chuy·ªÉn sang tab ph√°t l·∫°i
      setTimeout(() => {
        replayTabBtn.click();
        
        // Th√¥ng b√°o ƒë·ªÉ ng∆∞·ªùi d√πng bi·∫øt c·∫ßn nh·∫•n "T·∫£i D·ªØ Li·ªáu" trong tab ph√°t l·∫°i
        setTimeout(() => {
          alert('üìä Vui l√≤ng nh·∫•n n√∫t "T·∫£i D·ªØ Li·ªáu" trong tab Ph√°t L·∫°i ƒë·ªÉ xem bi·ªÉu ƒë·ªì.');
        }, 500);
        
      }, 1000);
      
    } catch (error) {
      alert('‚ùå L·ªói khi ƒë·ªçc file JSON: ' + error.message);
    }
  };
  
  reader.readAsText(file);
  
  // Reset input ƒë·ªÉ c√≥ th·ªÉ ch·ªçn c√πng file nhi·ªÅu l·∫ßn
  fileInput.value = '';
});

// ƒê·ªïi text cho n√∫t
transferBtn.textContent = 'T·∫£i d·ªØ li·ªáu JSON';
transferBtn.title = 'Ch·ªçn file JSON t·ª´ b·ªô nh·ªõ ƒë·ªÉ ph√°t l·∫°i';

// H√†m xu·∫•t d·ªØ li·ªáu hi·ªán t·∫°i (n·∫øu c·∫ßn)
function exportCurrentData() {
  try {
    const balanceHistory = JSON.parse(localStorage.getItem('balanceHistory') || '[]');
    if (balanceHistory.length === 0) {
      alert('Kh√¥ng c√≥ d·ªØ li·ªáu ƒë·ªÉ xu·∫•t.');
      return;
    }
    
    const dataStr = JSON.stringify(balanceHistory, null, 2);
    const dataBlob = new Blob([dataStr], {type: 'application/json'});
    
    const url = URL.createObjectURL(dataBlob);
    const link = document.createElement('a');
    link.href = url;
    link.download = 'gold_trading_data_' + new Date().toISOString().split('T')[0] + '.json';
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
    
    alert(`‚úÖ ƒê√£ xu·∫•t ${balanceHistory.length} ƒëi·ªÉm d·ªØ li·ªáu!`);
  } catch (error) {
    alert('‚ùå L·ªói khi xu·∫•t d·ªØ li·ªáu: ' + error.message);
  }
}

// Th√™m n√∫t xu·∫•t d·ªØ li·ªáu (t√πy ch·ªçn)
const exportBtn = document.createElement('button');
exportBtn.textContent = 'Xu·∫•t d·ªØ li·ªáu JSON';
exportBtn.style.background = '#17a2b8';
exportBtn.style.color = 'white';
exportBtn.style.marginLeft = '10px';
exportBtn.onclick = exportCurrentData;

// Ch√®n n√∫t xu·∫•t v√†o header (t√πy ch·ªçn)
document.querySelector('header').appendChild(exportBtn);
</script>
</body>
</html>
