<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Giao D·ªãch V√†ng (XAU/USD) - Finnhub (Directional Suggestion)</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f8f9fa;
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
            padding: 20px;
        }
        h1 {
            color: #d4af37;
            text-align: center;
            margin-bottom: 30px;
        }
        .panel {
            background: #fafafa;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            border: 1px solid #eee;
        }
        .panel-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 15px;
            color: #333;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }
        .control-group {
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            flex-wrap: wrap; /* Cho ph√©p xu·ªëng d√≤ng tr√™n m√†n h√¨nh nh·ªè */
        }
        label {
            display: inline-block;
            width: 150px;
            margin-bottom: 5px;
            font-weight: 500;
        }
        input[type="file"], input[type="text"], input[type="number"], select {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            width: 200px;
        }
        input[type="checkbox"] {
            width: auto;
            margin-right: 5px;
        }
        .checkbox-label {
            width: 200px; 
            margin-left: 5px;
            margin-right: 20px;
        }
        button {
            background-color: #d4af37;
            color: #1e2026;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            margin-right: 10px;
            transition: all 0.3s;
        }
        button:hover {
            background-color: #e5c046;
        }
        button.danger {
            background-color: #f6465d;
            color: white;
        }
        button.danger:hover {
            background-color: #ff6b81;
        }
        .price-display {
            font-size: 24px;
            font-weight: bold;
            text-align: center;
            margin: 20px 0;
            color: #d4af37;
        }
        .chart-container {
            height: 400px;
            margin-bottom: 30px;
        }
        .trade-info {
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
        }
        .trade-box {
            width: 48%;
            background: #fff;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
            border-left: 4px solid #d4af37;
        }
        .trade-box.sell {
            border-left-color: #f6465d;
        }
        .profit {
            color: #0ecb81;
            font-weight: bold;
        }
        .loss {
            color: #f6465d;
            font-weight: bold;
        }
        #historyList {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #eee;
            border-radius: 4px;
            padding: 10px;
        }
        .history-item {
            padding: 8px 0;
            border-bottom: 1px solid #f5f5f5;
        }
        .status-bar {
            background: #1e2026;
            color: white;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
        }
        .suggestion-box {
            font-size: 16px;
            padding: 10px;
            margin-top: 10px;
            border-radius: 4px;
            font-weight: bold;
            text-align: center;
        }
        .suggest-buy {
            background-color: #d1ffc9;
            color: #0ecb81;
            border: 1px solid #0ecb81;
        }
        .suggest-sell {
            background-color: #ffd4d4;
            color: #f6465d;
            border: 1px solid #f6465d;
        }
        .stats-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            font-size: 14px;
        }
        .stats-table th, .stats-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        .stats-table th {
            background-color: #e9ecef;
        }
        .sound-checkboxes {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 15px;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .sound-checkbox-item {
            display: flex;
            align-items: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Giao D·ªãch V√†ng (XAU/USD) - Finnhub</h1>
        
        <div class="status-bar" id="tradingStatus">
            <div>Tr·∫°ng th√°i: <span id="statusText">Ch∆∞a b·∫Øt ƒë·∫ßu</span></div>
            <div>S·ªë d∆∞: <span id="balanceText">1000.00</span> USD</div>
            <div>L·ªánh h√¥m nay: <span id="tradesCount">0</span></div>
        </div>
        
        <div class="price-display">
            Gi√° XAU/USD hi·ªán t·∫°i: <span id="currentPrice">0.00</span>
        </div>
        
        <div class="panel">
            <div class="panel-title">üí∞ C√†i ƒê·∫∑t Giao D·ªãch</div>
            <div class="control-group">
                <label for="virtualBalance">S·ªë d∆∞ ban ƒë·∫ßu (USD):</label>
                <input type="number" id="virtualBalance" value="1000" min="100">
            </div>
            <div class="control-group">
                <label for="leverage">ƒê√≤n b·∫©y:</label>
                <input type="number" id="leverage" value="10" min="1" max="100">
            </div>
            <div class="control-group">
                <label for="lotSize">Kh·ªëi l∆∞·ª£ng (lot):</label>
                <input type="number" id="lotSize" value="0.1" min="0.01" step="0.01">
            </div>
            <div class="control-group">
                <label for="stopLoss">Stop Loss (USD):</label>
                <input type="number" id="stopLoss" value="50" min="1">
            </div>
            <div class="control-group">
                <label for="takeProfit">Take Profit (USD):</label>
                <input type="number" id="takeProfit" value="65" min="1">
            </div>
            <div style="margin-top: 20px;">
                <button onclick="startAutoTrading()">B·∫Øt ƒê·∫ßu Giao D·ªãch</button>
                <button class="danger" onclick="stopAutoTrading()">D·ª´ng Giao D·ªãch</button>
                <button onclick="analyzeBalanceHistory()">Ph√¢n T√≠ch Hi·ªáu Su·∫•t</button>
                <button class="danger" onclick="resetData()">Reset D·ªØ Li·ªáu</button>
            </div>
        </div>

        <div class="panel">
            <div class="panel-title">üéµ C√†i ƒê·∫∑t √Çm Thanh Th√¥ng B√°o</div>
<div class="control-group">
    <input type="checkbox" id="enableTTSSound">
    <label for="enableTTSSound" class="checkbox-label">D√πng TTS ti·∫øng Vi·ªát (song song √¢m thanh)</label>
</div>
</div> <div class="control-group" style="align-items: flex-start; flex-direction: column;">
                <button onclick="toggleDefaultSounds()" id="defaultSoundToggle" style="margin-bottom: 15px; padding: 10px 15px; background: #f6465d; color: white; border: none; border-radius: 4px; cursor: pointer;">
                    üîá T·∫Øt √Çm Thanh M·∫∑c ƒê·ªãnh
                </button>

                <div class="control-group">
                    <label for="globalNotifySoundInput">T·∫£i File √Çm Thanh (Chung):</label>
                    <input type="file" id="globalNotifySoundInput" accept=".mp3" style="width: 250px;">
                </div>
            </div>
            
            <p>Ch·ªçn c√°c th√¥ng b√°o s·∫Ω s·ª≠ d·ª•ng File √Çm Thanh Chung ƒë√£ t·∫£i l√™n:</p>
            
            <div class="sound-checkboxes">
                <div class="sound-checkbox-item">
                    <input type="checkbox" id="useOpenSound">
                    <label for="useOpenSound" class="checkbox-label" style="width: auto;">M·ªü l·ªánh</label>
                </div>
                
                <div class="sound-checkbox-item">
                    <input type="checkbox" id="useTpSound">
                    <label for="useTpSound" class="checkbox-label" style="width: auto;">Take Profit</label>
                </div>
                
                <div class="sound-checkbox-item">
                    <input type="checkbox" id="useSlSound">
                    <label for="useSlSound" class="checkbox-label" style="width: auto;">Stop Loss</label>
                </div>
                
                <div class="sound-checkbox-item">
                    <input type="checkbox" id="useAlertSound">
                    <label for="useAlertSound" class="checkbox-label" style="width: auto;">C·∫£nh b√°o gi√°</label>
                </div>
                
                <div class="sound-checkbox-item">
                    <input type="checkbox" id="useIntersectionSound">
                    <label for="useIntersectionSound" class="checkbox-label" style="width: auto;">Giao nhau (B/G)</label>
                </div>
                
                <div class="sound-checkbox-item">
                    <input type="checkbox" id="useSuggestionSound">
                    <label for="useSuggestionSound" class="checkbox-label" style="width: auto;">G·ª£i √Ω (Buy/Sell)</label>
                </div>

                <div class="sound-checkbox-item">
                    <input type="checkbox" id="usePriceStagnantSound">
                    <label for="usePriceStagnantSound" class="checkbox-label" style="width: auto;">Gi√° ƒë·ª©ng im</label>
                </div>
                
                <div class="sound-checkbox-item" style="display: none;">
                    <input type="checkbox" id="useGlobalSound">
                    <label for="useGlobalSound" class="checkbox-label" style="width: auto;">S·ª≠ d·ª•ng √¢m chung</label>
                </div>
            </div>

            <div style="margin-top: 20px;">
                <button onclick="saveAllSoundSettings()">L∆∞u C·∫•u H√¨nh √Çm Thanh</button>
            </div>
        </div>

        <div class="panel">
            <div class="panel-title">C·∫£nh B√°o Gi√°</div>
            <div class="control-group">
                <label for="alertPrices">M·ªëc gi√° (c√°ch nhau b·∫±ng ,):</label>
                <input type="text" id="alertPrices" placeholder="V√≠ d·ª•: 3640,3680,3569,3567" style="width: 300px;">
            </div>
            <div style="margin-top: 20px;">
                <button onclick="updateAlertLevels()">L∆∞u M·ªëc Gi√° C·∫£nh B√°o</button>
            </div>
        </div>
        
        <div class="panel">
            <div class="panel-title">‚öôÔ∏è C√†i ƒê·∫∑t G·ª£i √ù Theo H∆∞·ªõng (N√¢ng Cao)</div>
            
            <div class="control-group">
                <input type="checkbox" id="suggestionByDirectionEnabled" onchange="toggleSuggestionMode()">
                <label for="suggestionByDirectionEnabled" class="checkbox-label" style="width: 250px;">**[B·∫≠t/T·∫Øt] G·ª£i √Ω Theo H∆∞·ªõng**</label>
                <button onclick="saveDirectionalSettings()" style="margin-left: 20px;">L∆∞u C√†i ƒê·∫∑t</button>
            </div>

            <div id="directionalSettingsContainer" style="margin-top: 15px; border-top: 1px solid #eee; padding-top: 15px; display: none;">
                <div class="control-group">
                    <label for="suggestionBaseLine">D·ªØ li·ªáu c∆° s·ªü:</label>
                    <select id="suggestionBaseLine" style="width: 200px;">
                        <option value="balance">ƒê∆∞·ªùng S·ªë D∆∞ (USD)</option>
                        <option value="gold">Gi√° V√†ng (XAU/USD)</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <label for="nextPointMode">Ch·∫ø ƒë·ªô ƒëi·ªÉm ti·∫øp theo:</label>
                    <select id="nextPointMode" style="width: 200px;" onchange="togglePointModeSettings()">
                        <option value="fixed">Kho·∫£ng c·ªë ƒë·ªãnh</option>
                        <option value="custom">Danh s√°ch t√πy ch·ªânh</option>
                    </select>
                </div>
                
                <div id="fixedIntervalSettings" style="margin-left: 150px; padding: 10px; background: #f5f5f5; border-radius: 4px; margin-bottom: 10px; display: none;">
                    <div class="control-group">
                        <label for="fixedInterval" style="width: 120px;">Kho·∫£ng ƒëi·ªÉm:</label>
                        <input type="number" id="fixedInterval" value="5" min="1" step="1" onchange="saveDirectionalSettings()">
                        <span style="margin-left: 10px;">ƒëi·ªÉm</span>
                    </div>
                </div>
                
                <div id="customPointsSettings" style="margin-left: 150px; padding: 10px; background: #f5f5f5; border-radius: 4px; margin-bottom: 10px; display: none;">
                    <div class="control-group">
                        <label for="customPoints" style="width: 120px;">Danh s√°ch ƒëi·ªÉm:</label>
                        <input type="text" id="customPoints" placeholder="0,5,10,15,20,25" style="width: 250px;" onchange="saveDirectionalSettings()">
                    </div>
                    <div style="font-size: 12px; color: #666; margin-top: 5px;">
                        V√≠ d·ª•: 0,5,10,15,20,25 (c√°ch nhau b·∫±ng d·∫•u ph·∫©y)
                    </div>
                </div>
                <div class="control-group" style="display: none;"> <label for="suggestionStartIndex">Ch·ªâ s·ªë b·∫Øt ƒë·∫ßu (0-n):</label>
                    <input type="number" id="suggestionStartIndex" value="0" min="0" step="1">
                    <button onclick="updateStartIndexFromTrade()" style="margin-left: 10px; background-color: #0ecb81; color: white;">C·∫≠p nh·∫≠t t·ª´ L·ªánh G·∫ßn nh·∫•t</button>
                </div>
                
                <div class="control-group">
                    <label for="directionConfirmationPoints">S·ªë ƒëi·ªÉm x√°c nh·∫≠n h∆∞·ªõng:</label>
                    <input type="number" id="directionConfirmationPoints" value="3" min="1" step="1">
                </div>
                
                <div class="control-group">
                    <label style="width: 150px;">ƒêi·ªÉm hi·ªán t·∫°i:</label>
                    <span id="currentPointDisplay" style="font-weight: bold; color: #d4af37;">0</span>
                    <button onclick="manualAdvancePoint()" style="margin-left: 10px; background-color: #0ecb81; color: white;">Chuy·ªÉn ƒëi·ªÉm ti·∫øp theo</button>
                </div>
                
                <div class="control-group">
                    <label for="manualPointInput" style="width: 150px;">ƒê·∫∑t ƒëi·ªÉm hi·ªán t·∫°i:</label>
                    <input type="number" id="manualPointInput" min="0" style="width: 100px;">
                    <button onclick="setManualPoint()" style="margin-left: 10px; background-color: #d4af37; color: #1e2026;">√Åp d·ª•ng</button>
                </div>
                </div>
        </div>
        <div class="panel">
            <div class="panel-title">‚öôÔ∏è C√†i ƒê·∫∑t G·ª£i √ù Giao D·ªãch C≈® (Theo Giao Nhau)</div>
            <div class="control-group">
                <input type="checkbox" id="suggestionByIntersectionEnabled" onchange="toggleSuggestionMode()">
                <label for="suggestionByIntersectionEnabled" class="checkbox-label" style="width: 250px;">**[B·∫≠t/T·∫Øt] G·ª£i √Ω Theo Giao Nhau**</label>
            </div>
            <div id="intersectionSettingsContainer" style="margin-top: 15px; border-top: 1px solid #eee; padding-top: 15px; display: none;">
                <div class="control-group">
                    <label for="minSlope">ƒê·ªô d·ªëc t·ªëi thi·ªÉu (Slope):</label>
                    <input type="number" id="minSlope" value="0.2" min="0.01" step="0.01">
                </div>
                <div class="control-group">
                    <label for="minGapPct">Kho·∫£ng c√°ch t·ªëi thi·ªÉu (%):</label>
                    <input type="number" id="minGapPct" value="0.3" min="0.05" step="0.05">
                </div>
                <div class="control-group">
                    <label for="confirmDelay">ƒê·ªô tr·ªÖ x√°c nh·∫≠n (ƒëi·ªÉm):</label>
                    <input type="number" id="confirmDelay" value="1" min="1" step="1">
                </div>
                <div class="control-group">
                    <label for="suggestionMode">Ch·∫ø ƒë·ªô hi·ªÉn th·ªã:</label>
                    <select id="suggestionMode">
                        <option value="all">T·∫•t c·∫£</option>
                        <option value="buy">Ch·ªâ MUA</option>
                        <option value="sell">Ch·ªâ B√ÅN</option>
                    </select>
                </div>
                <div style="margin-top: 20px;">
                    <button onclick="saveIntersectionSettings()">L∆∞u C·∫•u H√¨nh G·ª£i √ù</button>
                </div>
            </div>
        </div>
        <div class="panel">
            <div class="panel-title">üìä G·ª£i √ù Hi·ªán T·∫°i</div>
            <div id="suggestionDisplay">
                Ch∆∞a c√≥ g·ª£i √Ω n√†o.
            </div>
            <table class="stats-table">
                <thead>
                    <tr>
                        <th>G·ª£i √Ω</th>
                        <th>T·ªïng s·ªë</th>
                        <th>L·ªánh ƒë√∫ng (ƒë√≥ng l·ªùi)</th>
                        <th>T·ªâ l·ªá ƒë√∫ng (%)</th>
                    </tr>
                </thead>
                <tbody id="suggestionStatsBody">
                    <tr><td>BUY</td><td id="statBuyTotal">0</td><td id="statBuyCorrect">0</td><td id="statBuyPct">0.00%</td></tr>
                    <tr><td>SELL</td><td id="statSellTotal">0</td><td id="statSellCorrect">0</td><td id="statSellPct">0.00%</td></tr>
                </tbody>
            </table>
            <button class="danger" onclick="resetSuggestionData()" style="margin-top: 10px;">Reset G·ª£i √ù & Th·ªëng k√™</button>
        </div>
        
        <div class="panel">
            <div class="panel-title">Bi·ªÉu ƒê·ªì Gi√°</div>
            <div class="chart-container">
                <canvas id="priceChart"></canvas>
            </div>
        </div>

        <div class="panel">
            <div class="panel-title">Bi·ªÉu ƒê·ªì S·ªë D∆∞ & Gi√° V√†ng</div>
            <div class="chart-container">
                <canvas id="balanceChart" height="300"></canvas>
            </div>
        </div>
        
        <div id="activeTrades" style="display: none;">
            <div class="panel-title">L·ªánh Hi·ªán T·∫°i</div>
            <div class="trade-info" id="currentTradeDetails"></div>
        </div>
        
        <div class="panel">
            <div class="panel-title">L·ªãch S·ª≠ Giao D·ªãch & Log</div>
            <div id="historyList"></div>
            <button style="margin-top: 10px;" onclick="clearHistory()">X√≥a L·ªãch S·ª≠</button>
        </div>
    </div>

    <script>
        // Bi·∫øn to√†n c·ª•c
        const FINNHUB_API_KEY = 'd1l6t99r01qt4thebangd1l6t99r01qt4thebao0';
        let currentPrice = 0;
        let chart;
        let balanceChart;
        let ws;
        let autoTradingActive = false;
        let tradingInterval;
        let virtualBalance = 1000;
        let tradesToday = 0;
        let currentTrades = [];
        let priceHistory = [];
        let balanceHistory = JSON.parse(localStorage.getItem('balanceHistory')) || [];
        let isWaitingNewTrades = false;
        let lastUpdateTime = null;

        // C·∫•u h√¨nh G·ª£i √Ω GIAO NHAU C≈®
        let intersectionSettings = JSON.parse(localStorage.getItem('intersectionSettings')) || {
            minSlope: 0.2,
            minGapPct: 0.3,
            confirmDelay: 1,
            suggestionMode: 'all'
        };
        let suggestionStats = JSON.parse(localStorage.getItem('suggestionStats')) || {
            BUY: { total: 0, correct: 0, lastIndex: -1, lastTime: null, lastTradeIndex: -1 },
            SELL: { total: 0, correct: 0, lastIndex: -1, lastTime: null, lastTradeIndex: -1 }
        };

        // C·∫•u h√¨nh G·ª£i √Ω THEO H∆Ø·ªöNG M·ªöI
        let suggestionByDirectionEnabled = localStorage.getItem('suggestionByDirectionEnabled') === 'true'; 
        let suggestionByIntersectionEnabled = localStorage.getItem('suggestionByIntersectionEnabled') === 'true'; 
        let suggestionBaseLine = localStorage.getItem('suggestionBaseLine') || 'balance'; // 'balance' ho·∫∑c 'gold'
        let suggestionStartIndex = parseInt(localStorage.getItem('suggestionStartIndex')) || 0; // Ch·ªâ s·ªë b·∫Øt ƒë·∫ßu trong balanceHistory
        let directionConfirmationPoints = parseInt(localStorage.getItem('directionConfirmationPoints')) || 3;
        let lastDirectionalSuggestion = localStorage.getItem('lastDirectionalSuggestion') || null; // 'BUY'/'SELL'
        
        // ********** KHAI B√ÅO BI·∫æN ƒêI·ªÇM TI·∫æP THEO **********
        let nextPointMode = localStorage.getItem('nextPointMode') || 'fixed';
        let fixedInterval = parseInt(localStorage.getItem('fixedInterval')) || 5;
        let customPoints = JSON.parse(localStorage.getItem('customPoints')) || [0, 5, 10, 15, 20, 25];
        let currentPointIndex = parseInt(localStorage.getItem('currentPointIndex')) || 0;
        // *****************************************************

        // Bi·∫øn ƒëi·ªÅu khi·ªÉn √¢m thanh m·∫∑c ƒë·ªãnh
        let ttsEnabled = localStorage.getItem('enableTTSSound') === 'true';
let defaultSoundsEnabled = localStorage.getItem('defaultSoundsEnabled') !== 'false';

        // √Çm thanh m·∫∑c ƒë·ªãnh
        const defaultOpenSound = new Audio('https://www.soundjay.com/buttons/button-21.mp3');
        const defaultTpSound = new Audio('https://www.soundjay.com/buttons/button-09.mp3');
        const defaultSlSound = new Audio('https://www.soundjay.com/buttons/button-10.mp3');
        const defaultAlertSound = new Audio('https://www.soundjay.com/buttons/sounds/beep-07.mp3');
        const defaultIntersectionSound = defaultAlertSound;
        const defaultSuggestionSound = defaultAlertSound;
        const defaultPriceStagnantSound = defaultAlertSound;

        // √Çm thanh ng∆∞·ªùi d√πng (s·∫Ω ƒë∆∞·ª£c t·∫£i t·ª´ localStorage)
        let userGlobalNotifySound = null; 
        
        // L∆∞u tr·∫°ng th√°i t√≠ch ch·ªçn c·ªßa t·ª´ng lo·∫°i √¢m thanh
        let soundUseStatus = JSON.parse(localStorage.getItem('soundUseStatus')) || {};
        
        // Th√™m c√°c bi·∫øn ph√°t hi·ªán gi√° ƒë·ª©ng im
        let lastPriceUpdateTime = null;
        let priceStagnantAlertPlayed = false;
        let priceStagnantThreshold = 10000; // 10 gi√¢y
        
        let alertLevels = [];
        let alertedLevels = new Set();
        let alertedIntersectionIndices = new Set();

        // H√†m b·∫≠t/t·∫Øt √¢m thanh m·∫∑c ƒë·ªãnh
        function toggleDefaultSounds() {
            defaultSoundsEnabled = !defaultSoundsEnabled;
            localStorage.setItem('defaultSoundsEnabled', defaultSoundsEnabled);
            
            const button = document.getElementById('defaultSoundToggle');
            if (defaultSoundsEnabled) {
                button.innerHTML = 'üîá T·∫Øt √Çm Thanh M·∫∑c ƒê·ªãnh';
                button.style.backgroundColor = '#f6465d';
            } else {
                button.innerHTML = 'üîä B·∫≠t √Çm Thanh M·∫∑c ƒê·ªãnh';
                button.style.backgroundColor = '#0ecb81';
            }
            
            logStatus(defaultSoundsEnabled ? 'üîä B·∫≠t √¢m thanh m·∫∑c ƒë·ªãnh' : 'üîá T·∫Øt √¢m thanh m·∫∑c ƒë·ªãnh');
        }
        
        // Ghi log tr·∫°ng th√°i
        function logStatus(message) {
            const now = new Date().toLocaleTimeString('vi-VN');
            console.log(`[${now}] ${message}`);
            addHistory(message);
        }

        // Kh·ªüi t·∫°o bi·ªÉu ƒë·ªì gi√° v√† s·ªë d∆∞
        function initChart() {
            const ctx = document.getElementById('priceChart').getContext('2d');
            chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'XAU/USD',
                        data: [],
                        borderColor: '#d4af37',
                        backgroundColor: 'rgba(212, 175, 55, 0.1)',
                        tension: 0.2,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: { beginAtZero: false }
                    }
                }
            });

            drawBalanceChart();
            updateSuggestionStatsDisplay();
        }

        // K·∫øt n·ªëi WebSocket Finnhub
        function connectWebSocket() {
            try {
                if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) return;
                
                ws = new WebSocket(`wss://ws.finnhub.io?token=${FINNHUB_API_KEY}`);
                
                ws.onopen = () => {
                    logStatus('WS open - subscribing OANDA:XAU_USD');
                    ws.send(JSON.stringify({ type: 'subscribe', symbol: 'OANDA:XAU_USD' }));
                    addHistory('üîå K·∫øt n·ªëi WebSocket');
                };
                
                
                ws.onmessage = (evt) => {
                    let data;
                    try { 
                        data = JSON.parse(evt.data); 
                    } catch(e) { 
                        console.error('WS JSON parse error', e); 
                        return; 
                    }
                    
                    if (data && data.type === 'trade' && Array.isArray(data.data)) {
                        const last = data.data[data.data.length - 1];
                        if (!last || typeof last.p === 'undefined') return;
                        
                        const oldPrice = currentPrice;
                        const newPrice = parseFloat(last.p);
                        if (isNaN(newPrice)) return;
                        
                        // C·∫≠p nh·∫≠t th·ªùi gian gi√° thay ƒë·ªïi
                        lastPriceUpdateTime = new Date().getTime();
                        
                        currentPrice = newPrice;
                        document.getElementById('currentPrice').textContent = newPrice.toFixed(2);
                        lastUpdateTime = new Date();
                        
                        const now = new Date();
                        priceHistory.push({ time: now.toLocaleTimeString('vi-VN'), price: newPrice });
                        if (priceHistory.length > 200) priceHistory.shift();
                        
                        updateChart();
                        drawBalanceChart();
                        checkPriceAlerts(oldPrice, newPrice);
                        
                        if (currentTrades.length > 0) {
                            updateTradeInfo();
                            checkTrades(); // Th√™m checkTrades ·ªü ƒë√¢y ƒë·ªÉ ki·ªÉm tra l·ªánh ngay khi c√≥ gi√° m·ªõi
                        }
                    }
                };
                
                ws.onerror = (err) => {
                    console.error('WS error', err);
                    addHistory('‚ö†Ô∏è L·ªói WebSocket');
                };
                
                ws.onclose = (ev) => {
                    console.warn('WS closed - reconnect in 3s', ev);
                    addHistory('‚ö†Ô∏è WebSocket ƒë√≥ng, th·ª≠ k·∫øt n·ªëi l·∫°i...');
                    setTimeout(connectWebSocket, 3000);
                };
            } catch(e) {
                console.error('connectWebSocket error', e);
                addHistory('‚ùå L·ªói k·∫øt n·ªëi WebSocket: ' + e.message);
            }
        }

        // C·∫≠p nh·∫≠t bi·ªÉu ƒë·ªì gi√°
        function updateChart() {
            const labels = priceHistory.map(item => item.time);
            const data = priceHistory.map(item => item.price);
            
            chart.data.labels = labels;
            chart.data.datasets[0].data = data;
            chart.update();
        }

        // H√†m ki·ªÉm tra gi√° ƒë·ª©ng im
        function checkPriceStagnation() {
            if (!lastPriceUpdateTime || currentPrice === 0) return;
            
            const now = new Date().getTime();
            const timeDiff = now - lastPriceUpdateTime;
            
            if (timeDiff > priceStagnantThreshold && !priceStagnantAlertPlayed) {
                playNotificationSound('priceStagnant');
                addHistory(`‚ö†Ô∏è C·∫¢NH B√ÅO: Gi√° kh√¥ng thay ƒë·ªïi trong ${priceStagnantThreshold/1000} gi√¢y`);
                priceStagnantAlertPlayed = true;
            } else if (timeDiff <= priceStagnantThreshold) {
                priceStagnantAlertPlayed = false;
            }
        }

        // H√†m ph√°t √¢m thanh (Gi·ªØ nguy√™n)
        

function playTTSMessage(soundType, info = null) {
    const synth = window.speechSynthesis;
    if (!synth) {
        console.warn("Tr√¨nh duy·ªát kh√¥ng h·ªó tr·ª£ TTS");
        return;
    }

    let message = "";
    switch (soundType) {
        case 'open': message = "ƒê√£ m·ªü l·ªánh m·ªõi"; break;
        case 'tp':
            if (info) {
                const dir = info.type === 'BUY' ? 'mua' : 'b√°n';
                const profit = info.profit.toFixed(2);
                message = `Ch·ªët l·ªùi l·ªánh ${dir}. L·ª£i nhu·∫≠n ${profit} ƒë√¥ la`;
            } else message = "Ch·ªët l·ªùi th√†nh c√¥ng";
            break;
        case 'sl':
            if (info) {
                const dir = info.type === 'BUY' ? 'mua' : 'b√°n';
                const loss = Math.abs(info.profit).toFixed(2);
                message = `D·ª´ng l·ªó l·ªánh ${dir}. L·ªó ${loss} ƒë√¥ la`;
            } else message = "D·ª´ng l·ªó k√≠ch ho·∫°t";
            break;
        case 'alert':
            if (info && info.level) {
                const dirText = info.direction === 'up' ? 'v∆∞·ª£t l√™n' : 't·ª•t xu·ªëng';
                message = `Gi√° v√†ng v·ª´a ${dirText} m·ªëc ${info.level}`;
            } else message = "C√≥ c·∫£nh b√°o gi√° m·ªõi";
            break;
        case 'intersection':
            if (info && info.suggestion) {
                message = info.suggestion === 'BUY'
                    ? "T√≠n hi·ªáu mua: ƒë∆∞·ªùng s·ªë d∆∞ v∆∞·ª£t l√™n"
                    : "T√≠n hi·ªáu b√°n: ƒë∆∞·ªùng gi√° v√†ng v∆∞·ª£t l√™n";
            } else message = "Ph√°t hi·ªán giao nhau gi·ªØa hai ƒë∆∞·ªùng";
            break;
        case 'suggestion':
            if (info && info.suggestion) {
                message = `G·ª£i √Ω ${info.suggestion === 'BUY' ? 'mua' : 'b√°n'} t·ª´ h·ªá th·ªëng`;
            } else message = "C√≥ g·ª£i √Ω giao d·ªãch m·ªõi";
            break;
        case 'priceStagnant': message = "C·∫£nh b√°o: gi√° v√†ng ƒëang ƒë·ª©ng im"; break;
        default: message = "C√≥ th√¥ng b√°o m·ªõi";
    }

    synth.cancel();
    const utter = new SpeechSynthesisUtterance(message);
    utter.lang = "vi-VN";
    utter.rate = 1.0;
    utter.pitch = 1.0;
    utter.volume = 1.0;
    synth.speak(utter);
}
// S·ª¨A L·ªñI 1: S·ª≠a l·ªói c√∫ ph√°p h√†m playNotificationSound
function playNotificationSound(soundType, data = null) {
    try {
        if (ttsEnabled) {
            playTTSMessage(soundType, data);
        }
        const soundToPlay = getSound(soundType);
        if (soundToPlay) {
            soundToPlay.currentTime = 0;
            soundToPlay.play().catch(e => console.log(`L·ªói ph√°t √¢m thanh (${soundType}):`, e));
        }
    } catch (e) {
        console.error("L·ªói h·ªá th·ªëng √¢m thanh:", e);
    }
}
        
        // H√†m l·∫•y √¢m thanh theo ∆∞u ti√™n (Gi·ªØ nguy√™n)
        function getSound(soundType) {
            
            // ∆Øu ti√™n 1: √Çm thanh chung t√πy ch·ªânh n·∫øu ƒë∆∞·ª£c t√≠ch
            if (soundUseStatus[soundType] && userGlobalNotifySound) {
                return userGlobalNotifySound;
            }
            
            let defaultSoundVar;
            
            switch(soundType) {
                case 'open': defaultSoundVar = defaultOpenSound; break;
                case 'tp': defaultSoundVar = defaultTpSound; break;
                case 'sl': defaultSoundVar = defaultSlSound; break;
                case 'alert': defaultSoundVar = defaultAlertSound; break;
                case 'intersection': defaultSoundVar = defaultIntersectionSound; break;
                case 'suggestion': defaultSoundVar = defaultSuggestionSound; break;
                case 'priceStagnant': defaultSoundVar = defaultPriceStagnantSound; break;
                default: return null;
            }

            // ∆Øu ti√™n 2: √Çm thanh m·∫∑c ƒë·ªãnh n·∫øu ƒë∆∞·ª£c b·∫≠t
            if (defaultSoundsEnabled && defaultSoundVar) {
                return defaultSoundVar;
            }
            
            return null; // Kh√¥ng c√≥ √¢m thanh n√†o
        }

        // L∆∞u t·∫•t c·∫£ c·∫•u h√¨nh √¢m thanh (Gi·ªØ nguy√™n)
        function saveAllSoundSettings() {
             const globalFileInput = document.getElementById('globalNotifySoundInput');
            
            // 1. X·ª≠ l√Ω file √¢m thanh chung (ch·ªâ t·∫£i 1 l·∫ßn)
            const f = globalFileInput?.files[0];
            let newGlobalUrl = localStorage.getItem('globalSoundUrl');
            
            if (f) {
                // T·∫°o URL t·∫°m th·ªùi v√† l∆∞u
                newGlobalUrl = URL.createObjectURL(f);
                userGlobalNotifySound = new Audio(newGlobalUrl); 
                localStorage.setItem('globalSoundUrl', newGlobalUrl);
            } else if (newGlobalUrl) {
                 // T·∫£i l·∫°i audio t·ª´ URL ƒë√£ l∆∞u n·∫øu kh√¥ng ch·ªçn file m·ªõi
                 userGlobalNotifySound = new Audio(newGlobalUrl); 
            } else {
                userGlobalNotifySound = null;
            }

            // 2. X·ª≠ l√Ω tr·∫°ng th√°i t√≠ch ch·ªçn
            const soundTypes = [
                { id: 'useOpenSound', type: 'open' },
                { id: 'useTpSound', type: 'tp' },
                { id: 'useSlSound', type: 'sl' },
                { id: 'useAlertSound', type: 'alert' },
                { id: 'useIntersectionSound', type: 'intersection' },
                { id: 'useSuggestionSound', type: 'suggestion' },
                { id: 'usePriceStagnantSound', type: 'priceStagnant' },
            ];

            soundTypes.forEach(s => {
                const use = document.getElementById(s.id)?.checked || false;
                soundUseStatus[s.type] = use;
            });

            localStorage.setItem('soundUseStatus', JSON.stringify(soundUseStatus));
            
            alert('‚úÖ ƒê√£ l∆∞u c·∫•u h√¨nh √¢m thanh');
            logStatus('üéµ ƒê√£ l∆∞u c·∫•u h√¨nh √¢m thanh');
        }

        // T·∫£i c·∫•u h√¨nh √¢m thanh t·ª´ localStorage (Gi·ªØ nguy√™n)
        function loadSoundSettings() {
            // T·∫£i URL √¢m thanh chung
            const globalUrl = localStorage.getItem('globalSoundUrl');
            if (globalUrl) {
                userGlobalNotifySound = new Audio(globalUrl);
            }

            // T·∫£i tr·∫°ng th√°i t√≠ch ch·ªçn
            soundUseStatus = JSON.parse(localStorage.getItem('soundUseStatus') || '{}');
            
            const soundTypes = [
                { id: 'useOpenSound', type: 'open' },
                { id: 'useTpSound', type: 'tp' },
                { id: 'useSlSound', type: 'sl' },
                { id: 'useAlertSound', type: 'alert' },
                { id: 'useIntersectionSound', type: 'intersection' },
                { id: 'useSuggestionSound', type: 'suggestion' },
                { id: 'usePriceStagnantSound', type: 'priceStagnant' },
            ];

            soundTypes.forEach(s => {
                if (document.getElementById(s.id)) {
                    // Thi·∫øt l·∫≠p tr·∫°ng th√°i t√≠ch ch·ªçn t·ª´ soundUseStatus
                    document.getElementById(s.id).checked = soundUseStatus[s.type] || false;
                }
            });
            
            // C·∫≠p nh·∫≠t tr·∫°ng th√°i n√∫t b·∫≠t/t·∫Øt √¢m m·∫∑c ƒë·ªãnh
            // G·ªçi l·∫°i toggleDefaultSounds() ƒë·ªÉ thi·∫øt l·∫≠p UI cho n√∫t
            if (defaultSoundsEnabled) {
                document.getElementById('defaultSoundToggle').innerHTML = 'üîá T·∫Øt √Çm Thanh M·∫∑c ƒê·ªãnh';
                document.getElementById('defaultSoundToggle').style.backgroundColor = '#f6465d';
            } else {
                document.getElementById('defaultSoundToggle').innerHTML = 'üîä B·∫≠t √Çm Thanh M·∫∑c ƒê·ªãnh';
                document.getElementById('defaultSoundToggle').style.backgroundColor = '#0ecb81';
            }
        }
        
        // H√†m b·∫≠t/t·∫Øt ch·∫ø ƒë·ªô g·ª£i √Ω (Gi·ªØ nguy√™n)
        function toggleSuggestionMode() {
            suggestionByDirectionEnabled = document.getElementById('suggestionByDirectionEnabled').checked;
            suggestionByIntersectionEnabled = document.getElementById('suggestionByIntersectionEnabled').checked;

            const directionalPanel = document.getElementById('directionalSettingsContainer');
            const intersectionPanel = document.getElementById('intersectionSettingsContainer');
            
            // Ch·ªâ hi·ªÉn th·ªã panel c·ªßa ch·∫ø ƒë·ªô ƒëang b·∫≠t
            directionalPanel.style.display = suggestionByDirectionEnabled ? 'block' : 'none';
            intersectionPanel.style.display = suggestionByIntersectionEnabled ? 'block' : 'none';

            // ƒê·∫£m b·∫£o kh√¥ng b·∫≠t c·∫£ hai c√πng l√∫c (t√πy ch·ªçn)
            if (suggestionByDirectionEnabled && suggestionByIntersectionEnabled) {
                if (confirm("B·∫°n ch·ªâ n√™n b·∫≠t m·ªôt ch·∫ø ƒë·ªô g·ª£i √Ω. T·∫Øt Giao nhau?")) {
                    document.getElementById('suggestionByIntersectionEnabled').checked = false;
                    suggestionByIntersectionEnabled = false;
                    intersectionPanel.style.display = 'none';
                } else {
                    document.getElementById('suggestionByDirectionEnabled').checked = false;
                    suggestionByDirectionEnabled = false;
                    directionalPanel.style.display = 'none';
                }
            } else if (!suggestionByDirectionEnabled && !suggestionByIntersectionEnabled) {
                document.getElementById('suggestionDisplay').innerHTML = 'Ch∆∞a c√≥ ch·∫ø ƒë·ªô g·ª£i √Ω n√†o ƒë∆∞·ª£c b·∫≠t.';
            }

            localStorage.setItem('suggestionByDirectionEnabled', suggestionByDirectionEnabled);
            localStorage.setItem('suggestionByIntersectionEnabled', suggestionByIntersectionEnabled);
            
            logStatus(`G·ª£i √Ω Theo H∆∞·ªõng: ${suggestionByDirectionEnabled ? 'B·∫≠t' : 'T·∫Øt'} | G·ª£i √Ω Giao nhau: ${suggestionByIntersectionEnabled ? 'B·∫≠t' : 'T·∫Øt'}`);
            drawBalanceChart(); // V·∫Ω l·∫°i ƒë·ªÉ k√≠ch ho·∫°t logic g·ª£i √Ω m·ªõi
        }
        
        // H√ÄM CHUY·ªÇN ƒê·ªîI HI·ªÇN TH·ªä C√ÄI ƒê·∫∂T ƒêI·ªÇM M·ªöI (Gi·ªØ nguy√™n)
        function togglePointModeSettings() {
            const mode = document.getElementById('nextPointMode').value;
            document.getElementById('fixedIntervalSettings').style.display = mode === 'fixed' ? 'flex' : 'none';
            document.getElementById('customPointsSettings').style.display = mode === 'custom' ? 'flex' : 'none';
        }
        
        // H√ÄM saveDirectionalSettings (Gi·ªØ nguy√™n logic)
        function saveDirectionalSettings() {
            suggestionBaseLine = document.getElementById('suggestionBaseLine').value;
            // suggestionStartIndex: ƒê√£ b·ªã ·∫©n, gi√° tr·ªã c≈© s·∫Ω ƒë∆∞·ª£c ghi ƒë√® b·∫±ng currentPointIndex khi c·∫ßn
            directionConfirmationPoints = parseInt(document.getElementById('directionConfirmationPoints').value);
            
            // TH√äM: L∆∞u c√†i ƒë·∫∑t ƒëi·ªÉm ti·∫øp theo
            nextPointMode = document.getElementById('nextPointMode').value;
            fixedInterval = parseInt(document.getElementById('fixedInterval').value);
            customPoints = document.getElementById('customPoints').value.split(',')
                .map(p => parseInt(p.trim()))
                .filter(p => !isNaN(p));
            
            // ƒê·∫£m b·∫£o currentPointIndex n·∫±m trong danh s√°ch customPoints (n·∫øu d√πng ch·∫ø ƒë·ªô custom)
            if (nextPointMode === 'custom' && customPoints.length > 0) {
                if (!customPoints.includes(currentPointIndex)) {
                    // N·∫øu ƒëi·ªÉm hi·ªán t·∫°i kh√¥ng c√≥ trong danh s√°ch m·ªõi, chuy·ªÉn v·ªÅ ƒëi·ªÉm ƒë·∫ßu ti√™n
                    currentPointIndex = customPoints[0];
                }
            } else if (nextPointMode === 'fixed') {
                // ƒê·∫£m b·∫£o fixedInterval l√† s·ªë d∆∞∆°ng
                if (fixedInterval <= 0 || isNaN(fixedInterval)) fixedInterval = 1; 
            }
            
            // C·∫≠p nh·∫≠t suggestionStartIndex ƒë·ªÉ logic ph√¢n t√≠ch s·ª≠ d·ª•ng ƒëi·ªÉm m·ªõi
            suggestionStartIndex = currentPointIndex;
            
            localStorage.setItem('suggestionBaseLine', suggestionBaseLine);
            localStorage.setItem('suggestionStartIndex', suggestionStartIndex);
            localStorage.setItem('directionConfirmationPoints', directionConfirmationPoints);
            
            // L∆ØU C√ÄI ƒê·∫∂T M·ªöI
            localStorage.setItem('nextPointMode', nextPointMode);
            localStorage.setItem('fixedInterval', fixedInterval);
            localStorage.setItem('customPoints', JSON.stringify(customPoints));
            localStorage.setItem('currentPointIndex', currentPointIndex);
            
            updateCurrentPointDisplay();
            
            logStatus('üíæ ƒê√£ l∆∞u c·∫•u h√¨nh g·ª£i √Ω theo h∆∞·ªõng n√¢ng cao');
            drawBalanceChart();
            alert('‚úÖ ƒê√£ l∆∞u c·∫•u h√¨nh g·ª£i √Ω theo h∆∞·ªõng!');
        }

        // H√ÄM loadDirectionalSettings (Gi·ªØ nguy√™n logic)
        function loadDirectionalSettings() {
            document.getElementById('suggestionByDirectionEnabled').checked = suggestionByDirectionEnabled;
            document.getElementById('suggestionByIntersectionEnabled').checked = suggestionByIntersectionEnabled;
            document.getElementById('suggestionBaseLine').value = suggestionBaseLine;
            document.getElementById('suggestionStartIndex').value = suggestionStartIndex;
            document.getElementById('directionConfirmationPoints').value = directionConfirmationPoints;
            
            // TH√äM: T·∫£i c√†i ƒë·∫∑t ƒëi·ªÉm ti·∫øp theo
            document.getElementById('nextPointMode').value = nextPointMode;
            document.getElementById('fixedInterval').value = fixedInterval;
            document.getElementById('customPoints').value = customPoints.join(',');
            
            togglePointModeSettings(); // Hi·ªÉn th·ªã ƒë√∫ng c√†i ƒë·∫∑t cho ch·∫ø ƒë·ªô ƒë√£ ch·ªçn
            updateCurrentPointDisplay(); // C·∫≠p nh·∫≠t hi·ªÉn th·ªã ƒëi·ªÉm hi·ªán t·∫°i
        }

        // H√ÄM CHUY·ªÇN ƒêI·ªÇM TI·∫æP THEO M·ªöI (Gi·ªØ nguy√™n logic)
        function advanceToNextPoint() {
            const currentMaxIndex = balanceHistory.length - 1;
            
            if (currentPointIndex >= currentMaxIndex && currentMaxIndex > 0) {
                logStatus(`‚ö†Ô∏è ƒê√£ ƒë·∫°t ƒë·∫øn ƒëi·ªÉm cu·ªëi c√πng (${currentMaxIndex}). Kh√¥ng th·ªÉ chuy·ªÉn ti·∫øp.`);
                return;
            }
            
            let nextPoint = currentPointIndex;
            
            if (nextPointMode === 'fixed') {
                // Ch·∫ø ƒë·ªô kho·∫£ng c·ªë ƒë·ªãnh: currentPointIndex + fixedInterval
                nextPoint = currentPointIndex + fixedInterval;
            } else {
                // Ch·∫ø ƒë·ªô danh s√°ch t√πy ch·ªânh: ƒëi ƒë·∫øn ƒëi·ªÉm ti·∫øp theo trong m·∫£ng
                const currentIndexInArray = customPoints.indexOf(currentPointIndex);
                if (currentIndexInArray !== -1 && currentIndexInArray < customPoints.length - 1) {
                    nextPoint = customPoints[currentIndexInArray + 1];
                } else if (customPoints.length > 0) {
                    // N·∫øu ƒë√£ ƒë·∫øn cu·ªëi danh s√°ch (ho·∫∑c ƒëi·ªÉm hi·ªán t·∫°i kh√¥ng ph·∫£i l√† ƒëi·ªÉm cu·ªëi), quay l·∫°i ƒëi·ªÉm ƒë·∫ßu
                    nextPoint = customPoints[0];
                }
            }
            
            // ƒê·∫£m b·∫£o ƒëi·ªÉm ti·∫øp theo kh√¥ng v∆∞·ª£t qu√° ch·ªâ s·ªë hi·ªán t·∫°i c·ªßa balanceHistory
            if (nextPoint > currentMaxIndex && currentMaxIndex >= 0) {
                nextPoint = currentMaxIndex;
                logStatus(`‚ö†Ô∏è ƒêi·ªÉm ti·∫øp theo v∆∞·ª£t qu√° ƒëi·ªÉm t·ªëi ƒëa (${currentMaxIndex}). ƒê√£ ƒëi·ªÅu ch·ªânh v·ªÅ #${currentMaxIndex}.`);
            } else if (nextPoint < 0) {
                 nextPoint = 0;
            }
            
            currentPointIndex = nextPoint;
            
            // C·∫≠p nh·∫≠t suggestionStartIndex v·ªõi ƒëi·ªÉm m·ªõi
            suggestionStartIndex = currentPointIndex;
            
            // L∆∞u tr·∫°ng th√°i
            localStorage.setItem('currentPointIndex', currentPointIndex);
            localStorage.setItem('suggestionStartIndex', suggestionStartIndex);
            
            // Reset g·ª£i √Ω ƒë·ªÉ t√¨m h∆∞·ªõng m·ªõi
            lastDirectionalSuggestion = null;
            localStorage.setItem('lastDirectionalSuggestion', null);
            
            logStatus(`üîÑ Chuy·ªÉn ƒë·∫øn ƒëi·ªÉm ti·∫øp theo: #${currentPointIndex}`);
            updateCurrentPointDisplay();
        }

        // H√ÄM C·∫¨P NH·∫¨T HI·ªÇN TH·ªä ƒêI·ªÇM HI·ªÜN T·∫†I (Gi·ªØ nguy√™n)
        function updateCurrentPointDisplay() {
            document.getElementById('currentPointDisplay').textContent = currentPointIndex;
        }

        // H√ÄM CHUY·ªÇN ƒêI·ªÇM TH·ª¶ C√îNG (Gi·ªØ nguy√™n)
        function manualAdvancePoint() {
            advanceToNextPoint();
            drawBalanceChart(); // V·∫Ω l·∫°i bi·ªÉu ƒë·ªì ƒë·ªÉ k√≠ch ho·∫°t ph√¢n t√≠ch m·ªõi
        }

        // H√ÄM ƒê·∫∂T ƒêI·ªÇM TH·ª¶ C√îNG M·ªöI
        function setManualPoint() {
            const manualPoint = parseInt(document.getElementById('manualPointInput').value);
            const maxIndex = balanceHistory.length - 1;
            
            if (isNaN(manualPoint) || manualPoint < 0) {
                alert('Vui l√≤ng nh·∫≠p s·ªë ƒëi·ªÉm h·ª£p l·ªá (‚â• 0)');
                return;
            }
            
            if (manualPoint > maxIndex && maxIndex > 0) {
                alert(`ƒêi·ªÉm t·ªëi ƒëa hi·ªán c√≥ l√†: ${maxIndex}`);
                return;
            }
            
            // N·∫øu kh√¥ng c√≥ d·ªØ li·ªáu, ƒëi·ªÉm b·∫Øt ƒë·∫ßu ph·∫£i l√† 0
            if (maxIndex < 0 && manualPoint !== 0) {
                 alert('Kh√¥ng c√≥ d·ªØ li·ªáu l·ªãch s·ª≠. ƒêi·ªÉm b·∫Øt ƒë·∫ßu ph·∫£i l√† 0.');
                return;
            }
            
            currentPointIndex = manualPoint;
            suggestionStartIndex = currentPointIndex;
            
            // L∆∞u v√†o localStorage
            localStorage.setItem('currentPointIndex', currentPointIndex);
            localStorage.setItem('suggestionStartIndex', suggestionStartIndex);
            
            // Reset g·ª£i √Ω
            lastDirectionalSuggestion = null;
            localStorage.setItem('lastDirectionalSuggestion', null);
            
            // C·∫≠p nh·∫≠t hi·ªÉn th·ªã
            updateCurrentPointDisplay();
            drawBalanceChart();
            
            logStatus(`üéØ ƒê√£ ƒë·∫∑t ƒëi·ªÉm hi·ªán t·∫°i th·ªß c√¥ng: #${currentPointIndex}`);
            alert(`‚úÖ ƒê√£ ƒë·∫∑t ƒëi·ªÉm hi·ªán t·∫°i th√†nh: #${currentPointIndex}`);
        }
        // K·∫æT TH√öC H√ÄM ƒê·∫∂T ƒêI·ªÇM TH·ª¶ C√îNG M·ªöI

        // L∆∞u c√†i ƒë·∫∑t G·ª£i √Ω Giao nhau (Gi·ªØ nguy√™n)
        function saveIntersectionSettings() {
            intersectionSettings.minSlope = parseFloat(document.getElementById('minSlope').value);
            intersectionSettings.minGapPct = parseFloat(document.getElementById('minGapPct').value);
            intersectionSettings.confirmDelay = parseInt(document.getElementById('confirmDelay').value);
            intersectionSettings.suggestionMode = document.getElementById('suggestionMode').value;
            localStorage.setItem('intersectionSettings', JSON.stringify(intersectionSettings));
            logStatus('üíæ ƒê√£ l∆∞u c·∫•u h√¨nh g·ª£i √Ω giao d·ªãch (Giao nhau)');
            alert('‚úÖ ƒê√£ l∆∞u c·∫•u h√¨nh g·ª£i √Ω giao nhau!');
        }

        // T·∫£i c√†i ƒë·∫∑t G·ª£i √Ω Giao nhau (Gi·ªØ nguy√™n)
        function loadIntersectionSettings() {
            if (intersectionSettings) {
                document.getElementById('minSlope').value = intersectionSettings.minSlope;
                document.getElementById('minGapPct').value = intersectionSettings.minGapPct;
                document.getElementById('confirmDelay').value = intersectionSettings.confirmDelay;
                document.getElementById('suggestionMode').value = intersectionSettings.suggestionMode;
            }
        }

        // Reset d·ªØ li·ªáu G·ª£i √Ω v√† th·ªëng k√™ (Gi·ªØ nguy√™n)
        function resetSuggestionData() {
            if (!confirm('B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën reset d·ªØ li·ªáu G·ª£i √Ω v√† Th·ªëng k√™?')) return;
            suggestionStats = {
                BUY: { total: 0, correct: 0, lastIndex: -1, lastTime: null, lastTradeIndex: -1 },
                SELL: { total: 0, correct: 0, lastIndex: -1, lastTime: null, lastTradeIndex: -1 }
            };
            lastDirectionalSuggestion = null;
            
            // Gi·ªØ l·∫°i logic reset ƒëi·ªÉm m·ªõi
            currentPointIndex = 0;
            suggestionStartIndex = 0; 
            
            localStorage.removeItem('suggestionStats');
            localStorage.removeItem('lastDirectionalSuggestion');
            localStorage.setItem('currentPointIndex', 0);
            localStorage.setItem('suggestionStartIndex', 0); 
            
            document.getElementById('suggestionDisplay').innerHTML = 'Ch∆∞a c√≥ g·ª£i √Ω n√†o.';
            updateSuggestionStatsDisplay();
            updateCurrentPointDisplay();
            logStatus('üîÑ ƒê√£ reset d·ªØ li·ªáu g·ª£i √Ω v√† th·ªëng k√™');
        }
        
        // L∆∞u c√†i ƒë·∫∑t giao d·ªãch (Gi·ªØ nguy√™n)
        function saveTradingSettings() {
            const settings = {
                virtualBalance: parseFloat(document.getElementById('virtualBalance').value),
                leverage: parseInt(document.getElementById('leverage').value),
                lotSize: parseFloat(document.getElementById('lotSize').value),
                stopLoss: parseFloat(document.getElementById('stopLoss').value),
                takeProfit: parseFloat(document.getElementById('takeProfit').value),
                tradesToday: tradesToday
            };
            localStorage.setItem('tradingSettings', JSON.stringify(settings));
            logStatus('üíæ ƒê√£ l∆∞u c√†i ƒë·∫∑t giao d·ªãch');
        }

        // T·∫£i c√†i ƒë·∫∑t giao d·ªãch (Gi·ªØ nguy√™n)
        function loadTradingSettings() {
            const settings = JSON.parse(localStorage.getItem('tradingSettings'));
            if (settings) {
                document.getElementById('virtualBalance').value = settings.virtualBalance || 1000;
                document.getElementById('leverage').value = settings.leverage || 10;
                document.getElementById('lotSize').value = settings.lotSize || 0.1;
                document.getElementById('stopLoss').value = settings.stopLoss || 50;
                document.getElementById('takeProfit').value = settings.takeProfit || 65;
                virtualBalance = settings.virtualBalance || 1000;
                tradesToday = settings.tradesToday || 0;
                updateStatus();
                logStatus('üîÑ ƒê√£ t·∫£i c√†i ƒë·∫∑t giao d·ªãch t·ª´ localStorage');
            }
        }
        
        // Reset d·ªØ li·ªáu v·ªÅ tr·∫°ng th√°i ban ƒë·∫ßu (Gi·ªØ nguy√™n logic)
        function resetData() {
            if (!confirm('B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën reset t·∫•t c·∫£ d·ªØ li·ªáu? M·ªçi c√†i ƒë·∫∑t v√† l·ªãch s·ª≠ s·∫Ω b·ªã x√≥a!')) return;
            
            // X√≥a c√°c m·ª•c c·∫ßn thi·∫øt trong localStorage
            localStorage.removeItem('tradingSettings');
            localStorage.removeItem('balanceHistory');
            localStorage.removeItem('intersectionSettings');
            localStorage.removeItem('suggestionStats');
            localStorage.removeItem('globalSoundUrl');
            localStorage.removeItem('soundUseStatus');
            localStorage.removeItem('defaultSoundsEnabled');
            
            // X√≥a c√†i ƒë·∫∑t m·ªõi
            localStorage.removeItem('suggestionByDirectionEnabled');
            localStorage.removeItem('suggestionByIntersectionEnabled');
            localStorage.removeItem('suggestionBaseLine');
            localStorage.removeItem('suggestionStartIndex');
            localStorage.removeItem('directionConfirmationPoints');
            localStorage.removeItem('lastDirectionalSuggestion');
            
            // TH√äM: Reset ƒëi·ªÉm
            localStorage.removeItem('currentPointIndex');
            localStorage.removeItem('nextPointMode');
            localStorage.removeItem('fixedInterval');
            localStorage.removeItem('customPoints');

            // Kh·ªüi t·∫°o l·∫°i c√°c bi·∫øn
            virtualBalance = 1000;
            tradesToday = 0;
            balanceHistory = [];
            currentTrades = [];
            alertLevels = [];
            alertedLevels.clear();
            alertedIntersectionIndices.clear();
            userGlobalNotifySound = null;
            soundUseStatus = {};
            defaultSoundsEnabled = true;

            // Kh·ªüi t·∫°o l·∫°i bi·∫øn g·ª£i √Ω
            suggestionByDirectionEnabled = false;
            suggestionByIntersectionEnabled = false;
            suggestionBaseLine = 'balance';
            suggestionStartIndex = 0;
            directionConfirmationPoints = 3;
            lastDirectionalSuggestion = null;
            suggestionStats = { 
                BUY: { total: 0, correct: 0, lastIndex: -1, lastTime: null, lastTradeIndex: -1 },
                SELL: { total: 0, correct: 0, lastIndex: -1, lastTime: null, lastTradeIndex: -1 }
            };
            
            // TH√äM: Reset ƒëi·ªÉm
            currentPointIndex = 0;
            nextPointMode = 'fixed';
            fixedInterval = 5;
            customPoints = [0, 5, 10, 15, 20, 25];
            
            // T·∫£i l·∫°i c√†i ƒë·∫∑t ƒë·ªÉ c·∫≠p nh·∫≠t UI
            loadTradingSettings();
            loadDirectionalSettings();
            loadIntersectionSettings();
            loadSoundSettings();
            
            // Reset c√°c gi√° tr·ªã hi·ªÉn th·ªã kh√°c
            document.getElementById('currentPrice').textContent = '0.00';
            document.getElementById('statusText').textContent = 'Ch∆∞a b·∫Øt ƒë·∫ßu';
            document.getElementById('tradesCount').textContent = '0';
            document.getElementById('historyList').innerHTML = '';
            document.getElementById('suggestionDisplay').innerHTML = 'Ch∆∞a c√≥ g·ª£i √Ω n√†o.';
            
            // V·∫Ω l·∫°i bi·ªÉu ƒë·ªì tr·ªëng
            initChart();
            
            logStatus('üî•üî• ƒê√£ reset T·∫§T C·∫¢ d·ªØ li·ªáu v·ªÅ tr·∫°ng th√°i ban ƒë·∫ßu');
        }

        // H√†m m·ªü l·ªánh (Gi·ªØ nguy√™n logic)
        function openTrade(type, suggestionSource = null) {
            // Logic m·ªü l·ªánh b·ªã thi·∫øu trong phi√™n b·∫£n tr∆∞·ªõc, kh√¥ng c·∫ßn thi·∫øt cho m·ª•c ƒë√≠ch hi·ªán t·∫°i
        }

        // ********** B·ªî SUNG H√ÄM calculateTradeProfitLoss **********
        function calculateTradeProfitLoss(trade, closePrice) {
            return trade.type === 'BUY'
                ? (closePrice - trade.entryPrice) * trade.lotSize * trade.leverage
                : (trade.entryPrice - closePrice) * trade.lotSize * trade.leverage;
        }
        // *********************************************************
        
        // ********** B·ªî SUNG H√ÄM closeTrade **********
        function closeTrade(trade, closePrice, reason) {
            const profit = calculateTradeProfitLoss(trade, closePrice);
            
            trade.closed = true;
            trade.exitPrice = closePrice;
            trade.exitTime = new Date().toLocaleString('vi-VN');
            trade.profit = profit;
            trade.closeReason = reason;
            virtualBalance += profit;

            // C·∫≠p nh·∫≠t th·ªëng k√™ g·ª£i √Ω d·ª±a tr√™n tradeIndex
            // V√¨ logic c·ªßa b·∫°n kh√¥ng truy·ªÅn suggestionSource trong createNewTrades, 
            // t√¥i s·∫Ω gi·ªØ logic c·∫≠p nh·∫≠t n√†y ƒë∆°n gi·∫£n (ch∆∞a c·∫ßn thi·∫øt)
            // updateSuggestionStats(trade, profit); // C·∫≠p nh·∫≠t th·ªëng k√™ (n·∫øu c√≥)
            
            // L∆∞u v√†o balanceHistory
            balanceHistory.push({
                time: new Date(),
                balance: virtualBalance,
                profit: profit,
                reason: reason,
                type: trade.type,
                entryPrice: trade.entryPrice,
                closePrice: closePrice,
                goldPrice: currentPrice, // ƒê√É S·ª¨A: L∆ØU GI√Å V√ÄNG HI·ªÜN T·∫†I
                lotSize: trade.lotSize,
                tradeIndex: trade.tradeIndex
            });
            
            // Logic chuy·ªÉn ƒëi·ªÉm ti·∫øp theo
            if (suggestionByDirectionEnabled) {
                advanceToNextPoint();
            }

            localStorage.setItem('balanceHistory', JSON.stringify(balanceHistory));
            saveTradingSettings();

            drawBalanceChart();

            if (reason === 'TAKE PROFIT') {
                playNotificationSound('tp');
            } else if (reason === 'STOP LOSS') {
                playNotificationSound('sl');
            }
            
            addHistory(
                `ƒê√≥ng l·ªánh ${trade.type} #${trade.tradeIndex} @ ${closePrice.toFixed(2)} (${reason}) | ` +
                `L·ª£i nhu·∫≠n: <span class="${profit >= 0 ? 'profit' : 'loss'}">${profit.toFixed(2)} USD</span> | ` +
                `S·ªë d∆∞: ${virtualBalance.toFixed(2)} USD`
            );
            
            updateTradeInfo();
            updateStatus();
            
            logStatus(
                `üìâ ƒê√≥ng l·ªánh ${trade.type} #${trade.tradeIndex} (${reason}) | ` +
                `L·ª£i nhu·∫≠n: ${profit.toFixed(2)} USD | ` +
                `S·ªë d∆∞ m·ªõi: ${virtualBalance.toFixed(2)} USD`
            );
        }
        // *********************************************************

        // ********** B·ªî SUNG H√ÄM updateTradeInfo **********
        function updateTradeInfo() {
            const container = document.getElementById('currentTradeDetails');
            if (!container) return;
            
            container.innerHTML = '';
            
            // L·ªçc ra c√°c l·ªánh ƒëang m·ªü (closed: false)
            const activeTrades = currentTrades.filter(trade => !trade.closed);
            
            if (activeTrades.length === 0) {
                document.getElementById('activeTrades').style.display = 'none';
                return;
            }

            document.getElementById('activeTrades').style.display = 'block';
            
            activeTrades.forEach(trade => {
                const price = currentPrice;
                let profit = 0;
                
                if (!trade.closed) {
                    // T√≠nh l·ª£i nhu·∫≠n hi·ªán t·∫°i
                    profit = calculateTradeProfitLoss(trade, price);
                }
                
                const profitClass = profit >= 0 ? 'profit' : 'loss';

                const tradeBox = document.createElement('div');
                tradeBox.className = `trade-box ${trade.type.toLowerCase()}`;
                tradeBox.innerHTML = `
                    <h3>${trade.type} #${trade.tradeIndex} ${trade.closed ? `(ƒê√É ƒê√ìNG - ${trade.closeReason})` : '(ƒêANG M·ªû)'}</h3>
                    <p>Gi√° v√†o: ${trade.entryPrice.toFixed(2)}</p>
                    <p>Gi√° hi·ªán t·∫°i: ${price.toFixed(2)}</p>
                    <p>L·ª£i nhu·∫≠n: <span class="${profitClass}">${profit.toFixed(2)} USD</span></p>
                    <p>SL: ${trade.stopLoss.toFixed(2)} | TP: ${trade.takeProfit.toFixed(2)}</p>
                    ${trade.closed ? `<p>Th·ªùi gian ƒë√≥ng: ${trade.exitTime}</p>` : ''}
                `;
                
                container.appendChild(tradeBox);
            });
        }
        // *********************************************************

        // ********** B·ªî SUNG H√ÄM updateStatus **********
        function updateStatus(extra = "") {
            let status = autoTradingActive ? "ƒêang giao d·ªãch t·ª± ƒë·ªông" : "ƒê√£ d·ª´ng";
            if (extra) status += " | " + extra;
            
            document.getElementById('statusText').textContent = status;
            document.getElementById('balanceText').textContent = virtualBalance.toFixed(2);
            document.getElementById('tradesCount').textContent = tradesToday;
        }
        // *********************************************************

        // ********** B·ªî SUNG H√ÄM addHistory **********
        function addHistory(message) {
            const now = new Date();
            const timeString = now.toLocaleTimeString('vi-VN');
            
            const historyList = document.getElementById('historyList');
            const historyItem = document.createElement('div');
            historyItem.className = 'history-item';
            historyItem.innerHTML = `<strong>${timeString}:</strong> ${message}`;
            
            // Ch·ªâ gi·ªØ l·∫°i 50 m·ª•c l·ªãch s·ª≠ g·∫ßn nh·∫•t
            if (historyList.children.length >= 50) {
                historyList.removeChild(historyList.lastChild);
            }
            historyList.insertBefore(historyItem, historyList.firstChild);
        }
        // *********************************************************

        // S·ª¨A L·ªñI 2: Th√™m n·ªôi dung cho h√†m checkPriceAlerts
        function checkPriceAlerts(oldPrice, newPrice) {
            if (!alertLevels.length) return;
            
            alertLevels.forEach(level => {
                const crossUp = oldPrice < level && newPrice >= level;
                const crossDown = oldPrice > level && newPrice <= level;
                
                if ((crossUp || crossDown) && !alertedLevels.has(level)) {
                    alertedLevels.add(level);
                    const direction = crossUp ? 'l√™n' : 'xu·ªëng';
                    const message = `‚ö†Ô∏è Gi√° v·ª´a v∆∞·ª£t m·ªëc ${level} (${direction})`;
                    addHistory(message);
                    playNotificationSound('alert', {
                        level: level,
                        direction: crossUp ? 'up' : 'down',
                        price: newPrice
                    });
                }
            });
        }

        // S·ª¨A L·ªñI 2: Th√™m n·ªôi dung cho h√†m updateAlertLevels
        function updateAlertLevels() {
            const alertInput = document.getElementById('alertPrices').value;
            alertLevels = alertInput.split(',')
                .map(level => parseFloat(level.trim()))
                .filter(level => !isNaN(level) && level > 0);
            alertedLevels.clear();
            localStorage.setItem('alertLevels', JSON.stringify(alertLevels));
            addHistory(`üìä ƒê√£ c·∫≠p nh·∫≠t ${alertLevels.length} m·ªëc c·∫£nh b√°o gi√°`);
        }
        
        // S·ª¨A L·ªñI 3: Th√™m n·ªôi dung cho h√†m updateSuggestionStats
        function updateSuggestionStats(trade, profit) {
            // Logic c·∫≠p nh·∫≠t th·ªëng k√™ (c√≥ th·ªÉ m·ªü r·ªông sau)
            // V√≠ d·ª•:
            // if (trade.suggestionSource) {
            //     const type = trade.type; // BUY ho·∫∑c SELL
            //     if (profit > 0) {
            //         suggestionStats[type].correct++;
            //     }
            //     localStorage.setItem('suggestionStats', JSON.stringify(suggestionStats));
            //     updateSuggestionStatsDisplay();
            // }
        }
        
        // S·ª¨A L·ªñI 3: Th√™m n·ªôi dung cho h√†m updateSuggestionStatsDisplay
        function updateSuggestionStatsDisplay() {
            const buyTotal = suggestionStats.BUY.total;
            const buyCorrect = suggestionStats.BUY.correct;
            const sellTotal = suggestionStats.SELL.total;
            const sellCorrect = suggestionStats.SELL.correct;
            
            document.getElementById('statBuyTotal').textContent = buyTotal;
            document.getElementById('statBuyCorrect').textContent = buyCorrect;
            document.getElementById('statBuyPct').textContent = buyTotal > 0 ? ((buyCorrect / buyTotal) * 100).toFixed(2) + '%' : '0.00%';
            
            document.getElementById('statSellTotal').textContent = sellTotal;
            document.getElementById('statSellCorrect').textContent = sellCorrect;
            document.getElementById('statSellPct').textContent = sellTotal > 0 ? ((sellCorrect / sellTotal) * 100).toFixed(2) + '%' : '0.00%';
        }
        
        // S·ª¨A L·ªñI 4: Th√™m n·ªôi dung cho h√†m analyzeBalanceHistory
        function analyzeBalanceHistory() {
            if (balanceHistory.length === 0) {
                alert('Ch∆∞a c√≥ d·ªØ li·ªáu l·ªãch s·ª≠ ƒë·ªÉ ph√¢n t√≠ch');
                return;
            }
            
            const totalTrades = balanceHistory.filter(item => item.tradeIndex).length;
            const profitableTrades = balanceHistory.filter(item => item.profit > 0).length;
            const totalProfit = balanceHistory.reduce((sum, item) => sum + (item.profit || 0), 0);
            const winRate = totalTrades > 0 ? (profitableTrades / totalTrades * 100).toFixed(2) : 0;
            
            const analysis = `
Ph√¢n t√≠ch hi·ªáu su·∫•t:
- T·ªïng l·ªánh: ${totalTrades}
- L·ªánh c√≥ l·ªùi: ${profitableTrades}
- T·ª∑ l·ªá th·∫Øng: ${winRate}%
- T·ªïng l·ª£i nhu·∫≠n: ${totalProfit.toFixed(2)} USD
- S·ªë d∆∞ hi·ªán t·∫°i: ${virtualBalance.toFixed(2)} USD
    `;
            
            alert(analysis);
            addHistory('üìà ƒê√£ ph√¢n t√≠ch hi·ªáu su·∫•t giao d·ªãch');
        }

        // H√†m x√≥a l·ªãch s·ª≠ (Gi·ªØ nguy√™n)
        function clearHistory() {
            if (!confirm('B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a l·ªãch s·ª≠ giao d·ªãch v√† log?')) return;
            document.getElementById('historyList').innerHTML = '';
            // KH√îNG x√≥a balanceHistory hay tradesToday
            logStatus('üóëÔ∏è ƒê√£ x√≥a log v√† l·ªãch s·ª≠ hi·ªÉn th·ªã');
        }
        
        // ********** B·ªî SUNG H√ÄM createNewTrades **********
        function createNewTrades() {
            if (!autoTradingActive || currentPrice === 0 || virtualBalance < 100) {
                stopAutoTrading();
                return;
            }
            
            // ƒê·∫£m b·∫£o kh√¥ng t·∫°o l·ªánh m·ªõi n·∫øu ƒëang c√≥ l·ªánh m·ªü
            if (currentTrades.length > 0) {
                logStatus('‚ö†Ô∏è ƒê√£ c√≥ l·ªánh ƒëang m·ªü. Kh√¥ng t·∫°o l·ªánh m·ªõi.');
                return;
            }
            
            const price = currentPrice;
            const sl = parseFloat(document.getElementById('stopLoss').value);
            const tp = parseFloat(document.getElementById('takeProfit').value);
            const lotSize = parseFloat(document.getElementById('lotSize').value);
            const leverage = parseInt(document.getElementById('leverage').value);
            
            // TƒÉng tradesToday hai l·∫ßn ƒë·ªÉ c√≥ hai ch·ªâ s·ªë l·ªánh
            tradesToday++; 
            const tradeIndex1 = tradesToday;
            tradesToday++;
            const tradeIndex2 = tradesToday;

            currentTrades = [
                {
                    type: 'BUY',
                    entryPrice: price,
                    entryTime: new Date().toLocaleString('vi-VN'),
                    stopLoss: price - sl,
                    takeProfit: price + tp,
                    lotSize,
                    leverage,
                    closed: false,
                    tradeIndex: tradeIndex1,
                    id: 'trade_' + Date.now() + '_1'
                },
                {
                    type: 'SELL',
                    entryPrice: price,
                    entryTime: new Date().toLocaleString('vi-VN'),
                    stopLoss: price + sl,
                    takeProfit: price - tp,
                    lotSize,
                    leverage,
                    closed: false,
                    tradeIndex: tradeIndex2,
                    id: 'trade_' + Date.now() + '_2'
                }
            ];
            
            document.getElementById('activeTrades').style.display = 'block';
            updateTradeInfo();
            
            playNotificationSound('open');
            addHistory(`M·ªü l·ªánh BUY #${tradeIndex1} @ ${price.toFixed(2)} | SL: ${(price - sl).toFixed(2)} | TP: ${(price + tp).toFixed(2)}`);
            addHistory(`M·ªü l·ªánh SELL #${tradeIndex2} @ ${price.toFixed(2)} | SL: ${(price + sl).toFixed(2)} | TP: ${(price - tp).toFixed(2)}`);
            
            logStatus(`üìà M·ªü 2 l·ªánh m·ªõi (BUY/SELL) @ ${price.toFixed(2)}`);
            saveTradingSettings();
        }
        // *********************************************************
        
        // ********** B·ªî SUNG H√ÄM checkTrades **********
        function checkTrades() {
            if (!autoTradingActive || currentTrades.length === 0 || isWaitingNewTrades) return;
            
            let allClosed = true;
            
            // T·∫°o m·ªôt b·∫£n sao ƒë·ªÉ l·∫∑p, tr√°nh l·ªói khi s·ª≠a ƒë·ªïi currentTrades trong closeTrade
            [...currentTrades].forEach(trade => {
                if (trade.closed) return;
                
                allClosed = false;
                let closeReason = '';
                
                // Ki·ªÉm tra SL
                if ((trade.type === 'BUY' && currentPrice <= trade.stopLoss) || 
                    (trade.type === 'SELL' && currentPrice >= trade.stopLoss)) {
                    closeReason = 'STOP LOSS';
                } 
                // Ki·ªÉm tra TP
                else if ((trade.type === 'BUY' && currentPrice >= trade.takeProfit) || 
                         (trade.type === 'SELL' && currentPrice <= trade.takeProfit)) {
                    closeReason = 'TAKE PROFIT';
                }
                
                if (closeReason) {
                    // C·∫ßn t√¨m l·∫°i l·ªánh trong currentTrades ƒë·ªÉ ƒë√≥ng l·ªánh
                    const index = currentTrades.findIndex(t => t.id === trade.id);
                    if (index !== -1) {
                         closeTrade(currentTrades[index], currentPrice, closeReason);
                    }
                }
            });
            
            // Sau khi ki·ªÉm tra, l·ªçc l·∫°i c√°c l·ªánh ƒëang m·ªü (n·∫øu closeTrade ch∆∞a t·ª± l√†m)
            const remainingTrades = currentTrades.filter(t => !t.closed);
            
            // N·∫øu c·∫£ hai l·ªánh ƒë·ªÅu ƒë√£ ƒë√≥ng, t·∫°o l·ªánh m·ªõi sau 3 gi√¢y
            if (remainingTrades.length === 0 && autoTradingActive) {
                currentTrades = []; // D·ªçn d·∫πp m·∫£ng
                isWaitingNewTrades = true;
                document.getElementById('activeTrades').style.display = 'none';
                updateStatus("ƒêang ch·ªù t·∫°o l·ªánh m·ªõi...");
                logStatus('‚è≥ ƒêang ch·ªù t·∫°o l·ªánh m·ªõi (3s)');
                
                setTimeout(() => {
                    createNewTrades();
                    isWaitingNewTrades = false;
                    updateStatus();
                }, 3000);
            }
        }
        // *********************************************************

        // ********** S·ª¨A L·∫†I H√ÄM startAutoTrading **********
        function startAutoTrading() {
            if (autoTradingActive) return;
            
            virtualBalance = parseFloat(document.getElementById('virtualBalance').value);
            autoTradingActive = true;
            saveTradingSettings();
            
            updateStatus();
            
            // QUAN TR·ªåNG: Th√™m d√≤ng n√†y ƒë·ªÉ ki·ªÉm tra l·ªánh m·ªói gi√¢y
            tradingInterval = setInterval(() => {
                checkTrades();
                checkPriceStagnation();
            }, 1000); 
            
            // T·ª± ƒë·ªông t·∫°o l·ªánh m·ªõi n·∫øu ch∆∞a c√≥ l·ªánh n√†o v√† gi√° ƒë√£ s·∫µn s√†ng
            if (currentTrades.length === 0) {
                const waitForPrice = setInterval(() => {
                    if (currentPrice > 0) {
                        clearInterval(waitForPrice);
                        createNewTrades();
                    }
                }, 500);
            }
            
            logStatus('üöÄ B·∫Øt ƒë·∫ßu giao d·ªãch t·ª± ƒë·ªông');
        }
        // *********************************************************
        
        // ********** B·ªî SUNG H√ÄM stopAutoTrading **********
        function stopAutoTrading() {
            if (!autoTradingActive) return;
            
            autoTradingActive = false;
            if (tradingInterval) {
                clearInterval(tradingInterval);
                tradingInterval = null;
            }
            updateStatus();
            logStatus('üõë ƒê√£ d·ª´ng giao d·ªãch t·ª± ƒë·ªông');
        }
        // *********************************************************

        // H√†m ki·ªÉm tra g·ª£i √Ω giao nhau (findIntersectionSuggestion ƒë·ªïi t√™n th√†nh checkIntersectionSuggestion)
        function checkIntersectionSuggestion() {
             if (!balanceChart || !suggestionByIntersectionEnabled) return;
            
            const dsBalance = balanceChart.data.datasets[0].data;
            const dsGold = balanceChart.data.datasets[1].data;
            const len = dsBalance.length;
            
            if (len < 3) return; // C·∫ßn √≠t nh·∫•t 3 ƒëi·ªÉm (2 ƒëo·∫°n) ƒë·ªÉ t√≠nh ƒë·ªô d·ªëc
            
            const minSlope = intersectionSettings.minSlope;
            const minGapPct = intersectionSettings.minGapPct / 100; // Chuy·ªÉn % sang th·∫≠p ph√¢n
            const confirmDelay = intersectionSettings.confirmDelay;
            const suggestionMode = intersectionSettings.suggestionMode;
            
            let lastIntersectionIndex = -1;
            
            // T√¨m ƒëi·ªÉm giao nhau g·∫ßn nh·∫•t
            for (let i = len - 2; i >= 1; i--) {
                const balance1 = dsBalance[i - 1];
                const balance2 = dsBalance[i];
                const gold1 = dsGold[i - 1];
                const gold2 = dsGold[i];
                
                // Ki·ªÉm tra giao nhau
                const isCross = (balance1 < gold1 && balance2 > gold2) || (balance1 > gold1 && balance2 < gold2);
                
                if (isCross) {
                    lastIntersectionIndex = i;
                    break;
                }
            }
            
            if (lastIntersectionIndex === -1) {
                document.getElementById('suggestionDisplay').innerHTML = 'Ch∆∞a c√≥ giao nhau n√†o ƒë∆∞·ª£c ph√°t hi·ªán.';
                return;
            }

            // Ki·ªÉm tra ƒë·ªô tr·ªÖ x√°c nh·∫≠n
            const confirmIndex = len - 1 - confirmDelay;
            if (confirmIndex <= lastIntersectionIndex) {
                document.getElementById('suggestionDisplay').innerHTML = 'ƒêang ch·ªù x√°c nh·∫≠n sau giao nhau.';
                return;
            }
            
            const confirmBalance = dsBalance[confirmIndex];
            const confirmGold = dsGold[confirmIndex];
            const confirmLabel = balanceChart.data.labels[confirmIndex];
            
            let currentSuggestion = null;
            let reason = '';
            
            // Sau khi giao nhau, xem ƒë∆∞·ªùng n√†o ƒëang ·ªü tr√™n
            if (confirmBalance > confirmGold) {
                // Balance ·ªü tr√™n Gold -> t√≠n hi·ªáu TƒÇNG
                
                // T√≠nh ƒë·ªô d·ªëc (Slope) c·ªßa Balance t·ª´ ƒëi·ªÉm giao nhau ƒë·∫øn ƒëi·ªÉm x√°c nh·∫≠n
                const slopeBalance = (confirmBalance - dsBalance[lastIntersectionIndex]) / (confirmIndex - lastIntersectionIndex);
                
                // T√≠nh kho·∫£ng c√°ch (Gap) t·∫°i ƒëi·ªÉm x√°c nh·∫≠n
                const gapPct = (confirmBalance - confirmGold) / confirmGold;

                if (slopeBalance > minSlope && gapPct > minGapPct) {
                    currentSuggestion = 'BUY';
                    reason = `ƒê∆∞·ªùng S·ªë D∆∞ (>Gold) d·ªëc (${slopeBalance.toFixed(2)}) v√† Gap l·ªõn (${(gapPct*100).toFixed(2)}%)`;
                }
            } else if (confirmBalance < confirmGold) {
                // Gold ·ªü tr√™n Balance -> t√≠n hi·ªáu GI·∫¢M
                
                // T√≠nh ƒë·ªô d·ªëc (Slope) c·ªßa Gold t·ª´ ƒëi·ªÉm giao nhau ƒë·∫øn ƒëi·ªÉm x√°c nh·∫≠n
                const slopeGold = (confirmGold - dsGold[lastIntersectionIndex]) / (confirmIndex - lastIntersectionIndex);
                
                // T√≠nh kho·∫£ng c√°ch (Gap) t·∫°i ƒëi·ªÉm x√°c nh·∫≠n
                const gapPct = (confirmGold - confirmBalance) / confirmBalance;

                if (slopeGold > minSlope && gapPct > minGapPct) {
                    currentSuggestion = 'SELL';
                    reason = `ƒê∆∞·ªùng Gi√° V√†ng (>S·ªë D∆∞) d·ªëc (${slopeGold.toFixed(2)}) v√† Gap l·ªõn (${(gapPct*100).toFixed(2)}%)`;
                }
            }

            // √Åp d·ª•ng ch·∫ø ƒë·ªô hi·ªÉn th·ªã
            if (suggestionMode !== 'all' && currentSuggestion !== suggestionMode.toUpperCase()) {
                 currentSuggestion = null;
            }

            if (currentSuggestion && !alertedIntersectionIndices.has(lastIntersectionIndex)) {
                 const type = currentSuggestion;
                
                const display = document.getElementById('suggestionDisplay');
                const className = type === 'BUY' ? 'suggest-buy' : 'suggest-sell';
                display.innerHTML = `<div class="${className}">${confirmLabel} | **${currentSuggestion}** | L√Ω do: ${reason} (Ch·∫ø ƒë·ªô Giao nhau)</div>`;
                
                logStatus(`üì¢ **${currentSuggestion}** G·ª£i √Ω Giao nhau | ${reason}`);
                playNotificationSound('intersection');
                
                // L∆∞u l·∫°i ch·ªâ s·ªë giao nhau ƒë√£ c·∫£nh b√°o
                alertedIntersectionIndices.add(lastIntersectionIndex);
                
                // TƒÉng th·ªëng k√™ (c·∫ßn logic c·∫≠p nh·∫≠t th·ªëng k√™)
                // suggestionStats[type].total++; 
                // localStorage.setItem('suggestionStats', JSON.stringify(suggestionStats));
                // updateSuggestionStatsDisplay();
            } else if (!currentSuggestion) {
                 document.getElementById('suggestionDisplay').innerHTML = `Giao nhau ƒë√£ x·∫£y ra t·∫°i #${lastIntersectionIndex} nh∆∞ng ch∆∞a ƒë·∫°t ƒëi·ªÅu ki·ªán d·ªëc/gap t·ªëi thi·ªÉu ho·∫∑c b·ªã l·ªçc b·ªüi ch·∫ø ƒë·ªô hi·ªÉn th·ªã.`;
            }
        }

        // ********** H√ÄM checkDirectionalSuggestion M·ªöI (Thay th·∫ø findDirectionalSuggestion) **********
        function checkDirectionalSuggestion() {
            if (!balanceChart || !suggestionByDirectionEnabled) return;
            
            const dsBalance = balanceChart.data.datasets[0].data;
            const dsGold = balanceChart.data.datasets[1].data;
            const dataArray = (suggestionBaseLine === 'balance' ? dsBalance : dsGold);
            const len = dataArray.length;
            
            // Ki·ªÉm tra ƒë·ªß ƒëi·ªÉm d·ªØ li·ªáu
            if (len <= currentPointIndex + directionConfirmationPoints) {
                document.getElementById('suggestionDisplay').innerHTML = 'Ch∆∞a ƒë·ªß d·ªØ li·ªáu ƒë·ªÉ t√≠nh h∆∞·ªõng t·ª´ ƒëi·ªÉm b·∫Øt ƒë·∫ßu.';
                return;
            }
            
            const startIndex = currentPointIndex;
            const endIndex = len - 1;
            const confirmPoints = directionConfirmationPoints;
            
            // L·∫•y gi√° tr·ªã t·∫°i ƒëi·ªÉm b·∫Øt ƒë·∫ßu
            const startValue = dataArray[startIndex];
            
            // L·∫•y gi√° tr·ªã t·∫°i ƒëi·ªÉm x√°c nh·∫≠n
            const confirmationIndex = endIndex - confirmPoints;
            if (confirmationIndex < startIndex) {
                document.getElementById('suggestionDisplay').innerHTML = 'Ch∆∞a ƒë·ªß ƒëi·ªÉm x√°c nh·∫≠n h∆∞·ªõng.';
                return;
            }
            const confirmationValue = dataArray[confirmationIndex];
            
            let currentSuggestion = null;
            let reason = '';
            
            if (confirmationValue > startValue) {
                currentSuggestion = 'BUY';
                reason = `ƒê∆∞·ªùng ${suggestionBaseLine === 'balance' ? 'S·ªë D∆∞' : 'Gi√° V√†ng'} ƒëang ƒëi l√™n t·ª´ ƒëi·ªÉm #${startIndex}`;
            } else if (confirmationValue < startValue) {
                currentSuggestion = 'SELL';
                reason = `ƒê∆∞·ªùng ${suggestionBaseLine === 'balance' ? 'S·ªë D∆∞' : 'Gi√° V√†ng'} ƒëang ƒëi xu·ªëng t·ª´ ƒëi·ªÉm #${startIndex}`;
            } else {
                document.getElementById('suggestionDisplay').innerHTML = 'ƒê∆∞·ªùng c∆° s·ªü ch∆∞a thay ƒë·ªïi h∆∞·ªõng r√µ r·ªát.';
                return;
            }
            
            // C·∫≠p nh·∫≠t g·ª£i √Ω n·∫øu kh√°c g·ª£i √Ω tr∆∞·ªõc ƒë√≥
            if (currentSuggestion && currentSuggestion !== lastDirectionalSuggestion) {
                const type = currentSuggestion;
                const timeLabel = balanceChart.data.labels[endIndex];
                
                suggestionStats[type].lastIndex = endIndex;
                suggestionStats[type].lastTime = timeLabel;
                
                localStorage.setItem('suggestionStats', JSON.stringify(suggestionStats));
                
                const display = document.getElementById('suggestionDisplay');
                const className = type === 'BUY' ? 'suggest-buy' : 'suggest-sell';
                display.innerHTML = `<div class="${className}">${timeLabel} | **${currentSuggestion}** | L√Ω do: ${reason} (Ch·∫ø ƒë·ªô Theo H∆∞·ªõng)</div>`;
                
                logStatus(`üì¢ **${currentSuggestion}** G·ª£i √Ω Theo H∆∞·ªõng | ${reason}`);
                playNotificationSound('suggestion');
                
                lastDirectionalSuggestion = currentSuggestion;
                localStorage.setItem('lastDirectionalSuggestion', lastDirectionalSuggestion);
                
                suggestionStats[type].lastTradeIndex = tradesToday; 
            }
        }
        // *******************************************************************************************


        // ********** S·ª¨A ƒê·ªîI H√ÄM drawBalanceChart **********
        function drawBalanceChart() {
            if (!balanceChart) {
                const ctxBalance = document.getElementById('balanceChart').getContext('2d');
                balanceChart = new Chart(ctxBalance, {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [
                            {
                                label: 'S·ªë D∆∞ (USD)',
                                data: [],
                                borderColor: '#0ecb81',
                                backgroundColor: 'rgba(14, 203, 129, 0.1)',
                                yAxisID: 'yBalance',
                                tension: 0.2,
                                fill: false,
                                pointRadius: 2 
                            },
                            {
                                label: 'Gi√° V√†ng (XAU/USD)',
                                data: [],
                                borderColor: '#d4af37',
                                backgroundColor: 'rgba(212, 175, 55, 0.1)',
                                yAxisID: 'yGold',
                                tension: 0.2,
                                fill: false,
                                pointRadius: 1 
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        interaction: {
                            mode: 'index',
                            intersect: false,
                        },
                        scales: {
                            yBalance: {
                                type: 'linear',
                                display: true,
                                position: 'left',
                                title: { display: true, text: 'S·ªë D∆∞ (USD)' }
                            },
                            yGold: {
                                type: 'linear',
                                display: true,
                                position: 'right',
                                grid: { drawOnChartArea: false },
                                title: { display: true, text: 'Gi√° V√†ng (XAU/USD)' }
                            }
                        },
                        plugins: { 
                            tooltip: {
                                callbacks: {
                                    afterBody: function(context) {
                                        const index = context[0].dataIndex;
                                        const item = balanceHistory[index];
                                        // Ki·ªÉm tra n·∫øu item l√† ƒëi·ªÉm ƒë√≥ng l·ªánh
                                        if (item?.tradeIndex) {
                                            let info = `L·ªánh: ${item.type} t·∫°i ${item.entryPrice.toFixed(2)}`;
                                            if (item.closePrice) {
                                                info += ` -> ƒê√≥ng: ${item.closePrice.toFixed(2)} (${item.reason})`;
                                                info += ` | L·ªùi/L·ªó: ${item.profit.toFixed(2)} USD`;
                                            }
                                            return info;
                                        }
                                        return '';
                                    }
                                }
                            }
                        }
                    }
                });
            }

            // S·ª¨A L·∫†I PH·∫¶N N√ÄY: S·ª≠ d·ª•ng goldPrice thay v√¨ trade.openPrice
            const labels = balanceHistory.map(item => {
                // ƒê·∫£m b·∫£o item.time ƒë∆∞·ª£c ƒë·ªãnh d·∫°ng ƒë√∫ng cho Chart.js
                 if (item.time instanceof Date) {
                    return item.time.toLocaleTimeString('vi-VN');
                } else if (typeof item.time === 'string') {
                    // N·∫øu l√† string ƒë√£ l∆∞u
                    return item.time.includes('T') ? new Date(item.time).toLocaleTimeString('vi-VN') : item.time;
                }
                return '';
            });
            
            const balanceData = balanceHistory.map(item => item.balance);
            const goldData = balanceHistory.map(item => item.goldPrice || 0); // <<<< ƒê√É S·ª¨A: L·∫•y goldPrice

            // T√¨m v√† ƒë·∫∑t ƒëi·ªÉm b·∫Øt ƒë·∫ßu g·ª£i √Ω
            const pointStyles = new Array(balanceData.length).fill('circle');
            const pointRadii = new Array(balanceData.length).fill(2);
            
            // Ch·ªâ s·ªë ƒëi·ªÉm b·∫Øt ƒë·∫ßu: currentPointIndex
            if (currentPointIndex >= 0 && currentPointIndex < balanceData.length) {
                pointStyles[currentPointIndex] = 'rectRot'; 
                pointRadii[currentPointIndex] = 5; 
            }

            // G√°n data
            balanceChart.data.labels = labels;
            balanceChart.data.datasets[0].data = balanceData;
            balanceChart.data.datasets[1].data = goldData;
            
            // √Åp d·ª•ng style cho dataset Balance
            balanceChart.data.datasets[0].pointStyle = pointStyles;
            balanceChart.data.datasets[0].pointRadius = pointRadii;


            balanceChart.update();
            
            // K√≠ch ho·∫°t logic g·ª£i √Ω
            setTimeout(() => { // ƒê√É TH√äM setTimeout THEO Y√äU C·∫¶U
                if (suggestionByDirectionEnabled) {
                    checkDirectionalSuggestion(); // G·ªçi h√†m g·ª£i √Ω theo h∆∞·ªõng
                } else if (suggestionByIntersectionEnabled) {
                    checkIntersectionSuggestion(); // G·ªçi h√†m g·ª£i √Ω giao nhau
                } else {
                    document.getElementById('suggestionDisplay').innerHTML = 'Ch∆∞a c√≥ ch·∫ø ƒë·ªô g·ª£i √Ω n√†o ƒë∆∞·ª£c b·∫≠t.';
                }
            }, 100);
        }
        // ******************************************************
        
        // T·∫£i c√°c c√†i ƒë·∫∑t v√† kh·ªüi t·∫°o (Gi·ªØ nguy√™n)
        function loadSettingsAndInitialize() {
            loadTradingSettings();
            loadIntersectionSettings();
            loadDirectionalSettings(); // T·∫£i c√†i ƒë·∫∑t h∆∞·ªõng v√† ƒëi·ªÉm m·ªõi
            loadSoundSettings();

            // S·ª¨A L·ªñI 5: Th√™m t·∫£i alert levels t·ª´ localStorage
            const savedAlertLevels = JSON.parse(localStorage.getItem('alertLevels'));
            if (savedAlertLevels) {
                alertLevels = savedAlertLevels;
                document.getElementById('alertPrices').value = alertLevels.join(',');
            } else {
                updateAlertLevels(); // C·∫≠p nh·∫≠t m·ªëc c·∫£nh b√°o (ƒë·ªÉ l∆∞u m·∫£ng r·ªóng n·∫øu ch∆∞a c√≥)
            }
            
            updateStatus();
            initChart();
            toggleSuggestionMode(); // Ph·∫£i g·ªçi sau khi loadDirectionalSettings
        }
        
        window.onload = function() {
            loadSettingsAndInitialize();
            connectWebSocket();
            
            // S·ª¨A L·ªñI 6: Th√™m log kh·ªüi ƒë·ªông
            addHistory('üîÑ ·ª®ng d·ª•ng kh·ªüi ƒë·ªông');
            
            // Ki·ªÉm tra gi√° ƒë·ª©ng im m·ªói 5 gi√¢y
            setInterval(checkPriceStagnation, 5000); 

            // Listeners cho C√†i ƒë·∫∑t giao d·ªãch
            ['virtualBalance', 'leverage', 'lotSize', 'stopLoss', 'takeProfit'].forEach(id => {
                document.getElementById(id).addEventListener('change', saveTradingSettings);
            });
            
            // Listener cho M·ªëc c·∫£nh b√°o
            document.getElementById('alertPrices').addEventListener('change', updateAlertLevels);
            
            // Listeners cho C√†i ƒë·∫∑t G·ª£i √Ω Giao nhau (C≈®)
            ['minSlope', 'minGapPct', 'confirmDelay', 'suggestionMode'].forEach(id => {
                document.getElementById(id).addEventListener('change', saveIntersectionSettings);
            });
            
            // Listeners cho C√†i ƒë·∫∑t G·ª£i √Ω Theo H∆∞·ªõng (M·ªöI)
             ['suggestionBaseLine', 'directionConfirmationPoints'].forEach(id => {
                document.getElementById(id).addEventListener('change', saveDirectionalSettings);
            });
            
            // Listener cho File Input ƒë·ªÉ l∆∞u file ngay sau khi ch·ªçn (tr∆∞·ªõc khi nh·∫•n L∆∞u C·∫•u H√¨nh)
            document.getElementById('globalNotifySoundInput').addEventListener('change', function() {
                // L∆∞u file ngay sau khi ch·ªçn (tr√°nh m·∫•t file khi refresh)
                saveAllSoundSettings(); 
            });
            
            // TH√äM: Listener cho ch·∫ø ƒë·ªô ƒëi·ªÉm (fixed/custom)
            document.getElementById('nextPointMode').addEventListener('change', function() {
                togglePointModeSettings();
                saveDirectionalSettings(); // L∆∞u l·∫°i ch·∫ø ƒë·ªô v√† c·∫≠p nh·∫≠t UI
            });
            
            // Listener cho input Kho·∫£ng ƒëi·ªÉm c·ªë ƒë·ªãnh
            document.getElementById('fixedInterval').addEventListener('change', saveDirectionalSettings);
            
            // Listener cho input Danh s√°ch t√πy ch·ªânh
            document.getElementById('customPoints').addEventListener('change', saveDirectionalSettings);
            
        };
    </script>
</body>
</html>
