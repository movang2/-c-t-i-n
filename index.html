<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Giao D·ªãch V√†ng (XAU/USD) - Finnhub</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f8f9fa;
            color: #333;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0,0,0,0.1);
            padding: 20px;
        }
        h1 {
            color: #d4af37;
            text-align: center;
            margin-bottom: 30px;
        }
        .panel {
            background: #fafafa;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            border: 1px solid #eee;
        }
        .panel-title {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 15px;
            color: #333;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }
        .control-group {
            margin-bottom: 15px;
            display: flex;
            align-items: center;
        }
        label {
            display: inline-block;
            width: 150px;
            margin-bottom: 5px;
            font-weight: 500;
        }
        input[type="file"], input[type="text"], input[type="number"], select {
            padding: 8px 12px;
            border: 1px solid #ddd;
            border-radius: 4px;
            width: 200px;
        }
        input[type="checkbox"] {
            width: auto;
            margin-right: 5px;
        }
        .checkbox-label {
            width: auto; 
            margin-left: 5px;
            margin-right: 20px;
        }
        button {
            background-color: #d4af37;
            color: #1e2026;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            margin-right: 10px;
            transition: all 0.3s;
        }
        button:hover {
            background-color: #e5c046;
        }
        button.danger {
            background-color: #f6465d;
            color: white;
        }
        button.danger:hover {
            background-color: #ff6b81;
        }
        .price-display {
            font-size: 24px;
            font-weight: bold;
            text-align: center;
            margin: 20px 0;
            color: #d4af37;
        }
        .chart-container {
            height: 400px;
            margin-bottom: 30px;
        }
        .trade-info {
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
        }
        .trade-box {
            width: 48%;
            background: #fff;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
            border-left: 4px solid #d4af37;
        }
        .trade-box.sell {
            border-left-color: #f6465d;
        }
        .profit {
            color: #0ecb81;
            font-weight: bold;
        }
        .loss {
            color: #f6465d;
            font-weight: bold;
        }
        #historyList {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid #eee;
            border-radius: 4px;
            padding: 10px;
        }
        .history-item {
            padding: 8px 0;
            border-bottom: 1px solid #f5f5f5;
        }
        .status-bar {
            background: #1e2026;
            color: white;
            padding: 10px;
            border-radius: 4px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
        }
        .suggestion-box {
            font-size: 16px;
            padding: 10px;
            margin-top: 10px;
            border-radius: 4px;
            font-weight: bold;
            text-align: center;
        }
        .suggest-buy {
            background-color: #d1ffc9;
            color: #0ecb81;
            border: 1px solid #0ecb81;
        }
        .suggest-sell {
            background-color: #ffd4d4;
            color: #f6465d;
            border: 1px solid #f6465d;
        }
        .stats-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            font-size: 14px;
        }
        .stats-table th, .stats-table td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        .stats-table th {
            background-color: #e9ecef;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Giao D·ªãch V√†ng (XAU/USD) - Finnhub</h1>
        
        <div class="status-bar" id="tradingStatus">
            <div>Tr·∫°ng th√°i: <span id="statusText">Ch∆∞a b·∫Øt ƒë·∫ßu</span></div>
            <div>S·ªë d∆∞: <span id="balanceText">1000.00</span> USD</div>
            <div>L·ªánh h√¥m nay: <span id="tradesCount">0</span></div>
        </div>
        
        <div class="price-display">
            Gi√° XAU/USD hi·ªán t·∫°i: <span id="currentPrice">0.00</span>
        </div>
        
        <div class="panel">
            <div class="panel-title">üí∞ C√†i ƒê·∫∑t Giao D·ªãch</div>
            <div class="control-group">
                <label for="virtualBalance">S·ªë d∆∞ ban ƒë·∫ßu (USD):</label>
                <input type="number" id="virtualBalance" value="1000" min="100">
            </div>
            <div class="control-group">
                <label for="leverage">ƒê√≤n b·∫©y:</label>
                <input type="number" id="leverage" value="10" min="1" max="100">
            </div>
            <div class="control-group">
                <label for="lotSize">Kh·ªëi l∆∞·ª£ng (lot):</label>
                <input type="number" id="lotSize" value="0.1" min="0.01" step="0.01">
            </div>
            <div class="control-group">
                <label for="stopLoss">Stop Loss (USD):</label>
                <input type="number" id="stopLoss" value="50" min="1">
            </div>
            <div class="control-group">
                <label for="takeProfit">Take Profit (USD):</label>
                <input type="number" id="takeProfit" value="65" min="1">
            </div>
            <div style="margin-top: 20px;">
                <button onclick="startAutoTrading()">B·∫Øt ƒê·∫ßu Giao D·ªãch</button>
                <button class="danger" onclick="stopAutoTrading()">D·ª´ng Giao D·ªãch</button>
                <button onclick="analyzeBalanceHistory()">Ph√¢n T√≠ch Hi·ªáu Su·∫•t</button>
                <button class="danger" onclick="resetData()">Reset D·ªØ Li·ªáu</button>
            </div>
        </div>

        <div class="panel">
            <div class="panel-title">üéµ C√†i ƒê·∫∑t √Çm Thanh Th√¥ng B√°o</div>
            
            <div class="control-group">
                <button onclick="toggleDefaultSounds()" id="defaultSoundToggle" style="margin-bottom: 15px; padding: 10px 15px; background: #f6465d; color: white; border: none; border-radius: 4px; cursor: pointer;">
                    üîá T·∫Øt √Çm Thanh M·∫∑c ƒê·ªãnh
                </button>
            </div>

            <div class="control-group">
                <label for="globalNotifySoundInput">√Çm thanh th√¥ng b√°o chung:</label>
                <input type="file" id="globalNotifySoundInput" accept=".mp3">
                <input type="checkbox" id="useGlobalSound">
                <label for="useGlobalSound" class="checkbox-label">S·ª≠ d·ª•ng</label>
            </div>
            
            <div class="control-group">
                <label for="openSoundInput">M·ªü l·ªánh:</label>
                <input type="file" id="openSoundInput" accept=".mp3">
                <input type="checkbox" id="useOpenSound">
                <label for="useOpenSound" class="checkbox-label">S·ª≠ d·ª•ng</label>
            </div>
            
            <div class="control-group">
                <label for="tpSoundInput">Take Profit:</label>
                <input type="file" id="tpSoundInput" accept=".mp3">
                <input type="checkbox" id="useTpSound">
                <label for="useTpSound" class="checkbox-label">S·ª≠ d·ª•ng</label>
            </div>
            
            <div class="control-group">
                <label for="slSoundInput">Stop Loss:</label>
                <input type="file" id="slSoundInput" accept=".mp3">
                <input type="checkbox" id="useSlSound">
                <label for="useSlSound" class="checkbox-label">S·ª≠ d·ª•ng</label>
            </div>
            
            <div class="control-group">
                <label for="alertSoundInput">C·∫£nh b√°o gi√°:</label>
                <input type="file" id="alertSoundInput" accept=".mp3">
                <input type="checkbox" id="useAlertSound">
                <label for="useAlertSound" class="checkbox-label">S·ª≠ d·ª•ng</label>
            </div>
            
            <div class="control-group">
                <label for="intersectionSoundInput">Giao nhau:</label>
                <input type="file" id="intersectionSoundInput" accept=".mp3">
                <input type="checkbox" id="useIntersectionSound">
                <label for="useIntersectionSound" class="checkbox-label">S·ª≠ d·ª•ng</label>
            </div>
            
            <div class="control-group">
                <label for="suggestionSoundInput">G·ª£i √Ω:</label>
                <input type="file" id="suggestionSoundInput" accept=".mp3">
                <input type="checkbox" id="useSuggestionSound">
                <label for="useSuggestionSound" class="checkbox-label">S·ª≠ d·ª•ng</label>
            </div>
            
            <div class="control-group">
                <label for="priceStagnantSoundInput">Gi√° ƒë·ª©ng im:</label>
                <input type="file" id="priceStagnantSoundInput" accept=".mp3">
                <input type="checkbox" id="usePriceStagnantSound">
                <label for="usePriceStagnantSound" class="checkbox-label">S·ª≠ d·ª•ng</label>
            </div>

            <div style="margin-top: 20px;">
                <button onclick="saveAllSoundSettings()">L∆∞u C·∫•u H√¨nh √Çm Thanh</button>
            </div>
        </div>

        <div class="panel">
            <div class="panel-title">C·∫£nh B√°o Gi√°</div>
            <div class="control-group">
                <label for="alertPrices">M·ªëc gi√° (c√°ch nhau b·∫±ng ,):</label>
                <input type="text" id="alertPrices" placeholder="V√≠ d·ª•: 3640,3680,3569,3567" style="width: 300px;">
            </div>
            <div style="margin-top: 20px;">
                <button onclick="updateAlertLevels()">L∆∞u M·ªëc Gi√° C·∫£nh B√°o</button>
            </div>
        </div>
        
        <div class="panel">
            <div class="panel-title">‚öôÔ∏è C√†i ƒê·∫∑t G·ª£i √ù Giao D·ªãch</div>
            <div class="control-group">
                <label for="minSlope">ƒê·ªô d·ªëc t·ªëi thi·ªÉu (Slope):</label>
                <input type="number" id="minSlope" value="0.2" min="0.01" step="0.01">
            </div>
            <div class="control-group">
                <label for="minGapPct">Kho·∫£ng c√°ch t·ªëi thi·ªÉu (%):</label>
                <input type="number" id="minGapPct" value="0.3" min="0.05" step="0.05">
            </div>
            <div class="control-group">
                <label for="confirmDelay">ƒê·ªô tr·ªÖ x√°c nh·∫≠n (ƒëi·ªÉm):</label>
                <input type="number" id="confirmDelay" value="1" min="1" step="1">
            </div>
            <div class="control-group">
                <label for="suggestionMode">Ch·∫ø ƒë·ªô hi·ªÉn th·ªã:</label>
                <select id="suggestionMode">
                    <option value="all">T·∫•t c·∫£</option>
                    <option value="buy">Ch·ªâ MUA</option>
                    <option value="sell">Ch·ªâ B√ÅN</option>
                </select>
            </div>
            <div style="margin-top: 20px;">
                <button onclick="saveSuggestionSettings()">L∆∞u C·∫•u H√¨nh G·ª£i √ù</button>
                <button class="danger" onclick="resetSuggestionData()">Reset G·ª£i √ù</button>
            </div>
        </div>

        <div class="panel">
            <div class="panel-title">üìä G·ª£i √ù Giao D·ªãch</div>
            <div id="suggestionDisplay">
                Ch∆∞a c√≥ g·ª£i √Ω n√†o.
            </div>
            <table class="stats-table">
                <thead>
                    <tr>
                        <th>G·ª£i √Ω</th>
                        <th>T·ªïng s·ªë</th>
                        <th>L·ªánh ƒë√∫ng (ƒë√≥ng l·ªùi)</th>
                        <th>T·ªâ l·ªá ƒë√∫ng (%)</th>
                    </tr>
                </thead>
                <tbody id="suggestionStatsBody">
                    <tr><td>BUY</td><td id="statBuyTotal">0</td><td id="statBuyCorrect">0</td><td id="statBuyPct">0.00%</td></tr>
                    <tr><td>SELL</td><td id="statSellTotal">0</td><td id="statSellCorrect">0</td><td id="statSellPct">0.00%</td></tr>
                </tbody>
            </table>
        </div>
        
        <div class="panel">
            <div class="panel-title">Bi·ªÉu ƒê·ªì Gi√°</div>
            <div class="chart-container">
                <canvas id="priceChart"></canvas>
            </div>
        </div>

        <div class="panel">
            <div class="panel-title">Bi·ªÉu ƒê·ªì S·ªë D∆∞ & Gi√° V√†ng</div>
            <div class="chart-container">
                <canvas id="balanceChart" height="300"></canvas>
            </div>
        </div>
        
        <div id="activeTrades" style="display: none;">
            <div class="panel-title">L·ªánh Hi·ªán T·∫°i</div>
            <div class="trade-info" id="currentTradeDetails"></div>
        </div>
        
        <div class="panel">
            <div class="panel-title">L·ªãch S·ª≠ Giao D·ªãch & Log</div>
            <div id="historyList"></div>
            <button style="margin-top: 10px;" onclick="clearHistory()">X√≥a L·ªãch S·ª≠</button>
        </div>
    </div>

    <script>
        // Bi·∫øn to√†n c·ª•c
        const FINNHUB_API_KEY = 'd1l6t99r01qt4thebangd1l6t99r01qt4thebao0';
        let currentPrice = 0;
        let chart;
        let balanceChart;
        let ws;
        let autoTradingActive = false;
        let tradingInterval;
        let virtualBalance = 1000;
        let tradesToday = 0;
        let currentTrades = [];
        let priceHistory = [];
        let balanceHistory = JSON.parse(localStorage.getItem('balanceHistory')) || [];
        let isWaitingNewTrades = false;
        let lastUpdateTime = null;

        // C·∫•u h√¨nh G·ª£i √Ω m·ªõi
        let suggestionSettings = JSON.parse(localStorage.getItem('suggestionSettings')) || {
            minSlope: 0.2,
            minGapPct: 0.3,
            confirmDelay: 1,
            suggestionMode: 'all'
        };
        let suggestionStats = JSON.parse(localStorage.getItem('suggestionStats')) || {
            BUY: { total: 0, correct: 0, lastIndex: -1, lastTime: null, lastTradeIndex: -1 },
            SELL: { total: 0, correct: 0, lastIndex: -1, lastTime: null, lastTradeIndex: -1 }
        };

        // Bi·∫øn ƒëi·ªÅu khi·ªÉn √¢m thanh m·∫∑c ƒë·ªãnh
        let defaultSoundsEnabled = localStorage.getItem('defaultSoundsEnabled') !== 'false';

        // √Çm thanh m·∫∑c ƒë·ªãnh
        const defaultOpenSound = new Audio('https://www.soundjay.com/buttons/button-21.mp3');
        const defaultTpSound = new Audio('https://www.soundjay.com/buttons/button-09.mp3');
        const defaultSlSound = new Audio('https://www.soundjay.com/buttons/button-10.mp3');
        const defaultAlertSound = new Audio('https://www.soundjay.com/buttons/sounds/beep-07.mp3');
        const defaultGlobalNotifySound = new Audio('https://www.soundjay.com/buttons/sounds/beep-07.mp3');
        const defaultIntersectionSound = defaultAlertSound;
        const defaultSuggestionSound = defaultAlertSound;
        const defaultPriceStagnantSound = defaultAlertSound;

        // √Çm thanh ng∆∞·ªùi d√πng (s·∫Ω ƒë∆∞·ª£c t·∫£i t·ª´ localStorage)
        let userOpenSound = null;
        let userTpSound = null;
        let userSlSound = null;
        let userAlertSound = null;
        let userIntersectionSound = null;
        let userSuggestionSound = null;
        let userPriceStagnantSound = null;
        let userGlobalNotifySound = null;
        let soundConfig = JSON.parse(localStorage.getItem('soundConfig') || '{}');
        
        // Th√™m c√°c bi·∫øn ph√°t hi·ªán gi√° ƒë·ª©ng im
        let lastPriceUpdateTime = null;
        let priceStagnantAlertPlayed = false;
        let priceStagnantThreshold = 10000; // 10 gi√¢y
        
        let alertLevels = [];
        let alertedLevels = new Set();
        let alertedIntersectionIndices = new Set();

        // H√†m b·∫≠t/t·∫Øt √¢m thanh m·∫∑c ƒë·ªãnh
        function toggleDefaultSounds() {
            defaultSoundsEnabled = !defaultSoundsEnabled;
            localStorage.setItem('defaultSoundsEnabled', defaultSoundsEnabled);
            
            const button = document.getElementById('defaultSoundToggle');
            if (defaultSoundsEnabled) {
                button.innerHTML = 'üîá T·∫Øt √Çm Thanh M·∫∑c ƒê·ªãnh';
                button.style.backgroundColor = '#f6465d';
            } else {
                button.innerHTML = 'üîä B·∫≠t √Çm Thanh M·∫∑c ƒê·ªãnh';
                button.style.backgroundColor = '#0ecb81';
            }
            
            logStatus(defaultSoundsEnabled ? 'üîä B·∫≠t √¢m thanh m·∫∑c ƒë·ªãnh' : 'üîá T·∫Øt √¢m thanh m·∫∑c ƒë·ªãnh');
        }
        
        // Ghi log tr·∫°ng th√°i
        function logStatus(message) {
            const now = new Date().toLocaleTimeString('vi-VN');
            console.log(`[${now}] ${message}`);
            addHistory(message);
        }

        // Kh·ªüi t·∫°o bi·ªÉu ƒë·ªì gi√° v√† s·ªë d∆∞
        function initChart() {
            const ctx = document.getElementById('priceChart').getContext('2d');
            chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'XAU/USD',
                        data: [],
                        borderColor: '#d4af37',
                        backgroundColor: 'rgba(212, 175, 55, 0.1)',
                        tension: 0.2,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: { beginAtZero: false }
                    }
                }
            });

            drawBalanceChart();
            updateSuggestionStatsDisplay();
        }

        // K·∫øt n·ªëi WebSocket Finnhub
        function connectWebSocket() {
            try {
                if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) return;
                
                ws = new WebSocket(`wss://ws.finnhub.io?token=${FINNHUB_API_KEY}`);
                
                ws.onopen = () => {
                    logStatus('WS open - subscribing OANDA:XAU_USD');
                    ws.send(JSON.stringify({ type: 'subscribe', symbol: 'OANDA:XAU_USD' }));
                    addHistory('üîå K·∫øt n·ªëi WebSocket');
                };
                
                
                ws.onmessage = (evt) => {
                    let data;
                    try { 
                        data = JSON.parse(evt.data); 
                    } catch(e) { 
                        console.error('WS JSON parse error', e); 
                        return; 
                    }
                    
                    if (data && data.type === 'trade' && Array.isArray(data.data)) {
                        const last = data.data[data.data.length - 1];
                        if (!last || typeof last.p === 'undefined') return;
                        
                        const oldPrice = currentPrice;
                        const newPrice = parseFloat(last.p);
                        if (isNaN(newPrice)) return;
                        
                        // C·∫≠p nh·∫≠t th·ªùi gian gi√° thay ƒë·ªïi
                        lastPriceUpdateTime = new Date().getTime();
                        
                        currentPrice = newPrice;
                        document.getElementById('currentPrice').textContent = newPrice.toFixed(2);
                        lastUpdateTime = new Date();
                        
                        const now = new Date();
                        priceHistory.push({ time: now.toLocaleTimeString('vi-VN'), price: newPrice });
                        if (priceHistory.length > 200) priceHistory.shift();
                        
                        updateChart();
                        drawBalanceChart();
                        checkPriceAlerts(oldPrice, newPrice);
                        
                        if (currentTrades.length > 0) {
                            updateTradeInfo();
                        }
                    }
                };
                
                ws.onerror = (err) => {
                    console.error('WS error', err);
                    addHistory('‚ö†Ô∏è L·ªói WebSocket');
                };
                
                ws.onclose = (ev) => {
                    console.warn('WS closed - reconnect in 3s', ev);
                    addHistory('‚ö†Ô∏è WebSocket ƒë√≥ng, th·ª≠ k·∫øt n·ªëi l·∫°i...');
                    setTimeout(connectWebSocket, 3000);
                };
            } catch(e) {
                console.error('connectWebSocket error', e);
                addHistory('‚ùå L·ªói k·∫øt n·ªëi WebSocket: ' + e.message);
            }
        }

        // C·∫≠p nh·∫≠t bi·ªÉu ƒë·ªì gi√°
        function updateChart() {
            const labels = priceHistory.map(item => item.time);
            const data = priceHistory.map(item => item.price);
            
            chart.data.labels = labels;
            chart.data.datasets[0].data = data;
            chart.update();
        }

        // H√†m ki·ªÉm tra gi√° ƒë·ª©ng im
        function checkPriceStagnation() {
            if (!lastPriceUpdateTime || currentPrice === 0) return;
            
            const now = new Date().getTime();
            const timeDiff = now - lastPriceUpdateTime;
            
            if (timeDiff > priceStagnantThreshold && !priceStagnantAlertPlayed) {
                playNotificationSound('priceStagnant');
                addHistory(`‚ö†Ô∏è C·∫¢NH B√ÅO: Gi√° kh√¥ng thay ƒë·ªïi trong ${priceStagnantThreshold/1000} gi√¢y`);
                priceStagnantAlertPlayed = true;
            } else if (timeDiff <= priceStagnantThreshold) {
                priceStagnantAlertPlayed = false;
            }
        }

        // L∆∞u t·∫•t c·∫£ c·∫•u h√¨nh √¢m thanh
        function saveAllSoundSettings() {
            // Danh s√°ch c√°c lo·∫°i √¢m thanh v√† id t∆∞∆°ng ·ª©ng
            const soundTypes = [
                { id: 'globalNotifySoundInput', key: 'globalNotifySound', var: 'userGlobalNotifySound', useId: 'useGlobalSound', type: 'global' },
                { id: 'openSoundInput', key: 'openSound', var: 'userOpenSound', useId: 'useOpenSound', type: 'open' },
                { id: 'tpSoundInput', key: 'tpSound', var: 'userTpSound', useId: 'useTpSound', type: 'tp' },
                { id: 'slSoundInput', key: 'slSound', var: 'userSlSound', useId: 'useSlSound', type: 'sl' },
                { id: 'alertSoundInput', key: 'alertSound', var: 'userAlertSound', useId: 'useAlertSound', type: 'alert' },
                { id: 'intersectionSoundInput', key: 'intersectionSound', var: 'userIntersectionSound', useId: 'useIntersectionSound', type: 'intersection' },
                { id: 'suggestionSoundInput', key: 'suggestionSound', var: 'userSuggestionSound', useId: 'useSuggestionSound', type: 'suggestion' },
                { id: 'priceStagnantSoundInput', key: 'priceStagnantSound', var: 'userPriceStagnantSound', useId: 'usePriceStagnantSound', type: 'priceStagnant' },
            ];

            let newSoundConfig = soundConfig;

            soundTypes.forEach(s => {
                const f = document.getElementById(s.id)?.files[0];
                const use = document.getElementById(s.useId)?.checked || false;

                newSoundConfig[s.type] = newSoundConfig[s.type] || {};
                newSoundConfig[s.type].use = use;
                
                if (f) {
                    const u = URL.createObjectURL(f);
                    window[s.var] = new Audio(u); // C·∫≠p nh·∫≠t bi·∫øn to√†n c·ª•c
                    newSoundConfig[s.type].url = u;
                } else {
                    // C·∫≠p nh·∫≠t tr·∫°ng th√°i 'use' ngay c·∫£ khi kh√¥ng c√≥ file m·ªõi
                }
            });

            soundConfig = newSoundConfig;
            localStorage.setItem('soundConfig', JSON.stringify(soundConfig));
            
            alert('‚úÖ ƒê√£ l∆∞u c·∫•u h√¨nh √¢m thanh');
            logStatus('üéµ ƒê√£ l∆∞u c·∫•u h√¨nh √¢m thanh');
        }

        // T·∫£i c·∫•u h√¨nh √¢m thanh t·ª´ localStorage
        function loadSoundSettings() {
            const soundTypes = [
                { key: 'globalNotifySound', var: 'userGlobalNotifySound', useId: 'useGlobalSound', default: defaultGlobalNotifySound, type: 'global' },
                { key: 'openSound', var: 'userOpenSound', useId: 'useOpenSound', default: defaultOpenSound, type: 'open' },
                { key: 'tpSound', var: 'userTpSound', useId: 'useTpSound', default: defaultTpSound, type: 'tp' },
                { key: 'slSound', var: 'userSlSound', useId: 'useSlSound', default: defaultSlSound, type: 'sl' },
                { key: 'alertSound', var: 'userAlertSound', useId: 'useAlertSound', default: defaultAlertSound, type: 'alert' },
                { key: 'intersectionSound', var: 'userIntersectionSound', useId: 'useIntersectionSound', default: defaultIntersectionSound, type: 'intersection' },
                { key: 'suggestionSound', var: 'userSuggestionSound', useId: 'useSuggestionSound', default: defaultSuggestionSound, type: 'suggestion' },
                { key: 'priceStagnantSound', var: 'userPriceStagnantSound', useId: 'usePriceStagnantSound', default: defaultPriceStagnantSound, type: 'priceStagnant' },
            ];

            soundConfig = JSON.parse(localStorage.getItem('soundConfig') || '{}');

            soundTypes.forEach(s => {
                const config = soundConfig[s.type];
                
                if (config && config.url) {
                    window[s.var] = new Audio(config.url);
                } else {
                    window[s.var] = null; // Kh√¥ng c√≥ URL ng∆∞·ªùi d√πng
                }

                if (document.getElementById(s.useId)) {
                    document.getElementById(s.useId).checked = config?.use || false;
                }
            });
            
            // C·∫≠p nh·∫≠t tr·∫°ng th√°i n√∫t b·∫≠t/t·∫Øt √¢m m·∫∑c ƒë·ªãnh
            toggleDefaultSounds(); 
        }

        // H√†m l·∫•y √¢m thanh theo ∆∞u ti√™n
        function getSound(soundType) {
            const config = soundConfig[soundType];
            
            let userSoundVar, defaultSoundVar;
            
            switch(soundType) {
                case 'open': userSoundVar = userOpenSound; defaultSoundVar = defaultOpenSound; break;
                case 'tp': userSoundVar = userTpSound; defaultSoundVar = defaultTpSound; break;
                case 'sl': userSoundVar = userSlSound; defaultSoundVar = defaultSlSound; break;
                case 'alert': userSoundVar = userAlertSound; defaultSoundVar = defaultAlertSound; break;
                case 'intersection': userSoundVar = userIntersectionSound; defaultSoundVar = defaultIntersectionSound; break;
                case 'suggestion': userSoundVar = userSuggestionSound; defaultSoundVar = defaultSuggestionSound; break;
                case 'priceStagnant': userSoundVar = userPriceStagnantSound; defaultSoundVar = defaultPriceStagnantSound; break;
                default: userSoundVar = userGlobalNotifySound; defaultSoundVar = defaultGlobalNotifySound; break; // global
            }

            // ∆Øu ti√™n 1: √Çm thanh ng∆∞·ªùi d√πng n·∫øu ƒë∆∞·ª£c tick v√† c√≥
            if (config?.use && userSoundVar) {
                return userSoundVar;
            }
            
            // ∆Øu ti√™n 2: √Çm thanh m·∫∑c ƒë·ªãnh n·∫øu ƒë∆∞·ª£c b·∫≠t
            if (defaultSoundsEnabled && defaultSoundVar) {
                return defaultSoundVar;
            }
            
            // ∆Øu ti√™n 3: √Çm thanh chung c·ªßa ng∆∞·ªùi d√πng n·∫øu ƒë∆∞·ª£c tick v√† c√≥
            const globalConfig = soundConfig['global'];
            if (globalConfig?.use && userGlobalNotifySound && soundType !== 'global') {
                return userGlobalNotifySound;
            }
            
            // ∆Øu ti√™n 4: √Çm thanh chung m·∫∑c ƒë·ªãnh
            if (defaultSoundsEnabled && defaultGlobalNotifySound && soundType !== 'global') {
                return defaultGlobalNotifySound;
            }
            
            return null; // Kh√¥ng c√≥ √¢m thanh n√†o
        }

        // H√†m ph√°t √¢m thanh
        function playNotificationSound(soundType) {
            try {
                const soundToPlay = getSound(soundType);
                
                if (soundToPlay) {
                    soundToPlay.currentTime = 0;
                    // L·ªói ·ªü ƒë√¢y (l·ªói Promise) th∆∞·ªùng x·∫£y ra khi tr√¨nh duy·ªát ch·∫∑n autoplay.
                    // S·ª≠ d·ª•ng catch ƒë·ªÉ b·ªè qua l·ªói v√† kh√¥ng l√†m crash ·ª©ng d·ª•ng.
                    soundToPlay.play().catch(e => console.log(`L·ªói ph√°t √¢m thanh (${soundType}):`, e));
                }
                
            } catch (e) {
                console.error("L·ªói h·ªá th·ªëng √¢m thanh:", e);
            }
        }
        
        // L∆∞u c√†i ƒë·∫∑t G·ª£i √Ω m·ªõi
        function saveSuggestionSettings() {
            suggestionSettings.minSlope = parseFloat(document.getElementById('minSlope').value);
            suggestionSettings.minGapPct = parseFloat(document.getElementById('minGapPct').value);
            suggestionSettings.confirmDelay = parseInt(document.getElementById('confirmDelay').value);
            suggestionSettings.suggestionMode = document.getElementById('suggestionMode').value;
            
            localStorage.setItem('suggestionSettings', JSON.stringify(suggestionSettings));
            logStatus('üíæ ƒê√£ l∆∞u c·∫•u h√¨nh g·ª£i √Ω giao d·ªãch');
            alert('‚úÖ ƒê√£ l∆∞u c·∫•u h√¨nh g·ª£i √Ω!');
        }

        // T·∫£i c√†i ƒë·∫∑t G·ª£i √Ω
        function loadSuggestionSettings() {
            if (suggestionSettings) {
                document.getElementById('minSlope').value = suggestionSettings.minSlope;
                document.getElementById('minGapPct').value = suggestionSettings.minGapPct;
                document.getElementById('confirmDelay').value = suggestionSettings.confirmDelay;
                document.getElementById('suggestionMode').value = suggestionSettings.suggestionMode;
            }
        }
        
        // Reset d·ªØ li·ªáu G·ª£i √Ω v√† th·ªëng k√™
        function resetSuggestionData() {
            if (!confirm('B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën reset d·ªØ li·ªáu G·ª£i √Ω v√† Th·ªëng k√™?')) return;
            suggestionStats = {
                BUY: { total: 0, correct: 0, lastIndex: -1, lastTime: null, lastTradeIndex: -1 },
                SELL: { total: 0, correct: 0, lastIndex: -1, lastTime: null, lastTradeIndex: -1 }
            };
            localStorage.removeItem('suggestionStats');
            document.getElementById('suggestionDisplay').innerHTML = 'Ch∆∞a c√≥ g·ª£i √Ω n√†o.';
            updateSuggestionStatsDisplay();
            logStatus('üîÑ ƒê√£ reset d·ªØ li·ªáu g·ª£i √Ω v√† th·ªëng k√™');
        }

        // L∆∞u c√†i ƒë·∫∑t giao d·ªãch
        function saveTradingSettings() {
            const settings = {
                virtualBalance: parseFloat(document.getElementById('virtualBalance').value),
                leverage: parseInt(document.getElementById('leverage').value),
                lotSize: parseFloat(document.getElementById('lotSize').value),
                stopLoss: parseFloat(document.getElementById('stopLoss').value),
                takeProfit: parseFloat(document.getElementById('takeProfit').value),
                tradesToday: tradesToday
            };
            localStorage.setItem('tradingSettings', JSON.stringify(settings));
            logStatus('üíæ ƒê√£ l∆∞u c√†i ƒë·∫∑t giao d·ªãch');
        }

        // T·∫£i c√†i ƒë·∫∑t giao d·ªãch
        function loadTradingSettings() {
            const settings = JSON.parse(localStorage.getItem('tradingSettings'));
            if (settings) {
                document.getElementById('virtualBalance').value = settings.virtualBalance || 1000;
                document.getElementById('leverage').value = settings.leverage || 10;
                document.getElementById('lotSize').value = settings.lotSize || 0.1;
                document.getElementById('stopLoss').value = settings.stopLoss || 50;
                document.getElementById('takeProfit').value = settings.takeProfit || 65;
                virtualBalance = settings.virtualBalance || 1000;
                tradesToday = settings.tradesToday || 0;
                updateStatus();
                logStatus('üîÑ ƒê√£ t·∫£i c√†i ƒë·∫∑t giao d·ªãch t·ª´ localStorage');
            }
        }

        // Reset d·ªØ li·ªáu v·ªÅ tr·∫°ng th√°i ban ƒë·∫ßu
        function resetData() {
            if (!confirm('B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën reset t·∫•t c·∫£ d·ªØ li·ªáu? M·ªçi c√†i ƒë·∫∑t v√† l·ªãch s·ª≠ s·∫Ω b·ªã x√≥a!')) return;

            localStorage.clear(); // X√≥a to√†n b·ªô localStorage ƒë·ªÉ reset
            
            virtualBalance = 1000;
            tradesToday = 0;
            balanceHistory = [];
            currentTrades = [];
            alertLevels = [];
            alertedLevels.clear();
            alertedIntersectionIndices.clear();
            soundConfig = {};

            // Reset Settings
            document.getElementById('virtualBalance').value = 1000;
            document.getElementById('leverage').value = 10;
            document.getElementById('lotSize').value = 0.1;
            document.getElementById('stopLoss').value = 50;
            document.getElementById('takeProfit').value = 65;
            document.getElementById('alertPrices').value = '';
            
            // Reset UI cho Sound Settings
            const checkboxes = document.querySelectorAll('.panel input[type="checkbox"]');
            checkboxes.forEach(cb => cb.checked = false);
            document.getElementById('defaultSoundToggle').innerHTML = 'üîá T·∫Øt √Çm Thanh M·∫∑c ƒê·ªãnh';
            document.getElementById('defaultSoundToggle').style.backgroundColor = '#f6465d';

            document.getElementById('historyList').innerHTML = '';
            document.getElementById('activeTrades').style.display = 'none';
            document.getElementById('currentTradeDetails').innerHTML = '';
            
            // Reset Suggestion Settings/Stats
            resetSuggestionData();
            loadSuggestionSettings(); 
            
            // Reload sound objects (s·∫Ω ƒë∆∞·ª£c th·ª±c hi·ªán qua loadSoundSettings trong window.onload)
            loadSoundSettings(); // G·ªçi l·∫°i ƒë·ªÉ reset bi·∫øn global
            
            updateStatus();
            drawBalanceChart();
            logStatus('üîÑ ƒê√£ reset d·ªØ li·ªáu v·ªÅ tr·∫°ng th√°i ban ƒë·∫ßu');
        }

        // B·∫Øt ƒë·∫ßu giao d·ªãch t·ª± ƒë·ªông
        function startAutoTrading() {
            if (autoTradingActive) return;
            
            virtualBalance = parseFloat(document.getElementById('virtualBalance').value);
            autoTradingActive = true;
            saveTradingSettings();
            
            updateStatus();
            
            // QUAN TR·ªåNG: Th√™m d√≤ng n√†y ƒë·ªÉ ki·ªÉm tra l·ªánh m·ªói gi√¢y
            tradingInterval = setInterval(() => {
                checkTrades();
                checkPriceStagnation();
            }, 1000); 
            
            if (currentTrades.length === 0) {
                const waitForPrice = setInterval(() => {
                    if (currentPrice > 0) {
                        clearInterval(waitForPrice);
                        createNewTrades();
                    }
                }, 500);
            }
            
            logStatus('üöÄ B·∫Øt ƒë·∫ßu giao d·ªãch t·ª± ƒë·ªông');
        }

        function stopAutoTrading() {
            autoTradingActive = false;
            clearInterval(tradingInterval);
            saveTradingSettings();
            updateStatus();
            logStatus('üõë D·ª´ng giao d·ªãch t·ª± ƒë·ªông');
        }

        // T·∫°o l·ªánh m·ªõi
        function createNewTrades() {
             if (!autoTradingActive || currentPrice === 0 || virtualBalance < 100) {
                stopAutoTrading();
                return;
            }
            
            const price = currentPrice;
            const sl = parseFloat(document.getElementById('stopLoss').value);
            const tp = parseFloat(document.getElementById('takeProfit').value);
            const lotSize = parseFloat(document.getElementById('lotSize').value);
            const leverage = parseInt(document.getElementById('leverage').value);
            
            tradesToday++; // TƒÉng tradesToday ƒë·ªÉ c√≥ ch·ªâ s·ªë l·ªánh
            const tradeIndex1 = tradesToday;
            tradesToday++;
            const tradeIndex2 = tradesToday;

            currentTrades = [
                {
                    type: 'BUY',
                    entryPrice: price,
                    entryTime: new Date().toLocaleString('vi-VN'),
                    stopLoss: price - sl,
                    takeProfit: price + tp,
                    lotSize,
                    leverage,
                    closed: false,
                    tradeIndex: tradeIndex1
                },
                {
                    type: 'SELL',
                    entryPrice: price,
                    entryTime: new Date().toLocaleString('vi-VN'),
                    stopLoss: price + sl,
                    takeProfit: price - tp,
                    lotSize,
                    leverage,
                    closed: false,
                    tradeIndex: tradeIndex2
                }
            ];
            
            document.getElementById('activeTrades').style.display = 'block';
            updateTradeInfo();
            
            playNotificationSound('open');
            addHistory(`M·ªü l·ªánh BUY #${tradeIndex1} @ ${price.toFixed(2)} | SL: ${(price - sl).toFixed(2)} | TP: ${(price + tp).toFixed(2)}`);
            addHistory(`M·ªü l·ªánh SELL #${tradeIndex2} @ ${price.toFixed(2)} | SL: ${(price + sl).toFixed(2)} | TP: ${(price - tp).toFixed(2)}`);
            
            logStatus(`üìà M·ªü 2 l·ªánh m·ªõi (BUY/SELL) @ ${price.toFixed(2)}`);
            saveTradingSettings();
        }
        
        // **********************************************
        // TH√äM/S·ª¨A C√ÅC H√ÄM B·ªä THI·∫æU/QUAN TR·ªåNG T·ª™ ƒê√ÇY
        // **********************************************

        // H√†m ki·ªÉm tra l·ªánh (QUAN TR·ªåNG: Thi·∫øu trong b·∫£n g·ªëc)
        function checkTrades() {
            if (!autoTradingActive || currentTrades.length === 0 || isWaitingNewTrades) return;
            
            let allClosed = true;
            
            currentTrades.forEach(trade => {
                if (trade.closed) return;
                
                allClosed = false;
                let closeReason = '';
                
                if ((trade.type === 'BUY' && currentPrice <= trade.stopLoss) || 
                    (trade.type === 'SELL' && currentPrice >= trade.stopLoss)) {
                    closeReason = 'STOP LOSS';
                } 
                else if ((trade.type === 'BUY' && currentPrice >= trade.takeProfit) || 
                         (trade.type === 'SELL' && currentPrice <= trade.takeProfit)) {
                    closeReason = 'TAKE PROFIT';
                }
                
                if (closeReason) {
                    closeTrade(trade, currentPrice, closeReason);
                }
            });
            
            if (allClosed && autoTradingActive) {
                currentTrades = []; // X√≥a c√°c l·ªánh ƒë√£ ƒë√≥ng
                isWaitingNewTrades = true;
                document.getElementById('activeTrades').style.display = 'none';
                updateStatus("ƒêang ch·ªù t·∫°o l·ªánh m·ªõi...");
                logStatus('‚è≥ ƒêang ch·ªù t·∫°o l·ªánh m·ªõi (3s)');
                
                setTimeout(() => {
                    createNewTrades();
                    isWaitingNewTrades = false;
                    updateStatus();
                }, 3000);
            }
        }

        // H√†m c·∫≠p nh·∫≠t m·ªëc c·∫£nh b√°o (Thi·∫øu trong b·∫£n g·ªëc)
        function updateAlertLevels() {
            const input = document.getElementById('alertPrices').value;
            alertLevels = input.split(',')
                .map(p => parseFloat(p.trim()))
                .filter(p => !isNaN(p))
                .sort((a, b) => a - b); // S·∫Øp x·∫øp ƒë·ªÉ d·ªÖ ki·ªÉm tra
            alertedLevels.clear();
            logStatus('C·∫≠p nh·∫≠t m·ªëc c·∫£nh b√°o: ' + alertLevels.join(', '));
            alert('‚úÖ ƒê√£ l∆∞u m·ªëc gi√° c·∫£nh b√°o!');
        }

        // H√†m ki·ªÉm tra c·∫£nh b√°o gi√° (Thi·∫øu trong b·∫£n g·ªëc)
        function checkPriceAlerts(oldPrice, newPrice) {
            if (alertLevels.length === 0 || oldPrice === 0 || oldPrice === newPrice) return;

            alertLevels.forEach(level => {
                // Ki·ªÉm tra gi√° c·∫Øt qua m·ªëc
                if ((oldPrice < level && newPrice >= level) ||
                    (oldPrice > level && newPrice <= level)) {
                    
                    addHistory(`üì¢ Gi√° ƒë√£ c·∫Øt qua m·ªëc ${level.toFixed(2)} (hi·ªán t·∫°i: ${newPrice.toFixed(2)})`);
                    playNotificationSound('alert');
                }
            });
        }
        
        // H√†m x√≥a l·ªãch s·ª≠ (Thi·∫øu trong b·∫£n g·ªëc)
        function clearHistory() {
            document.getElementById('historyList').innerHTML = '';
            logStatus('üßπ ƒê√£ x√≥a l·ªãch s·ª≠ hi·ªÉn th·ªã');
        }

        // H√†m ph√¢n t√≠ch hi·ªáu su·∫•t (Thi·∫øu trong b·∫£n g·ªëc)
        function analyzeBalanceHistory() {
            if (!balanceHistory || balanceHistory.length === 0) {
                alert("Kh√¥ng c√≥ d·ªØ li·ªáu giao d·ªãch!");
                return;
            }

            let max = balanceHistory[0];
            let min = balanceHistory[0];
            let totalProfit = 0;
            let totalGoldPrice = 0;
            const closedTrades = balanceHistory;
            const tradesCount = closedTrades.length;

            if(tradesCount === 0) {
                 alert("Ch∆∞a c√≥ l·ªánh n√†o ƒë∆∞·ª£c ƒë√≥ng ƒë·ªÉ ph√¢n t√≠ch!");
                 return;
            }

            max = closedTrades[0];
            min = closedTrades[0];

            closedTrades.forEach(item => {
                if (item.balance > max.balance) max = item;
                if (item.balance < min.balance) min = item;
                totalProfit += item.profit;
                totalGoldPrice += item.goldPrice;
            });

            const maxIndex = closedTrades.findIndex(item => item === max) + 1;
            const minIndex = closedTrades.findIndex(item => item === min) + 1;
            
            const avgProfit = (totalProfit / tradesCount).toFixed(2);
            const avgGoldPrice = (totalGoldPrice / tradesCount).toFixed(2);
            const profitToGoldRatio = tradesCount > 0 ? ((totalProfit / tradesCount) / avgGoldPrice * 100).toFixed(2) : '0.00';

            alert(
                `üìà S·ªë d∆∞ cao nh·∫•t: ${max.balance.toFixed(2)} USD (L·ªánh #${max.tradeIndex}) (Gi√° V√†ng: ${max.goldPrice.toFixed(2)} USD)\n` +
                `üìâ S·ªë d∆∞ th·∫•p nh·∫•t: ${min.balance.toFixed(2)} USD (L·ªánh #${min.tradeIndex}) (Gi√° V√†ng: ${min.goldPrice.toFixed(2)} USD)\n\n` +
                `üí∞ L·ª£i nhu·∫≠n trung b√¨nh m·ªói l·ªánh: ${avgProfit} USD\n` +
                `üåü Gi√° V√†ng trung b√¨nh: ${avgGoldPrice} USD\n` +
                `üìä T·ª∑ l·ªá l·ª£i nhu·∫≠n so v·ªõi gi√° v√†ng (trung b√¨nh): ${profitToGoldRatio}%`
            );
        }

        // ƒê√≥ng l·ªánh 
        function closeTrade(trade, closePrice, reason) {
            const profit = trade.type === 'BUY'
                ? (closePrice - trade.entryPrice) * trade.lotSize * trade.leverage
                : (trade.entryPrice - closePrice) * trade.lotSize * trade.leverage;
            
            trade.closed = true;
            trade.exitPrice = closePrice;
            trade.exitTime = new Date().toLocaleString('vi-VN');
            trade.profit = profit;
            trade.closeReason = reason;
            virtualBalance += profit;
            // tradesToday ƒë√£ ƒë∆∞·ª£c tƒÉng trong createNewTrades, kh√¥ng c·∫ßn tƒÉng ·ªü ƒë√¢y n·ªØa.

            // C·∫≠p nh·∫≠t th·ªëng k√™ g·ª£i √Ω d·ª±a tr√™n tradeIndex
            updateSuggestionStats(trade, profit);
            
            balanceHistory.push({
                time: new Date(),
                balance: virtualBalance,
                profit: profit,
                reason: reason,
                type: trade.type,
                entryPrice: trade.entryPrice,
                closePrice: closePrice,
                goldPrice: currentPrice,
                lotSize: trade.lotSize,
                tradeIndex: trade.tradeIndex // Th√™m index ƒë·ªÉ tham chi·∫øu
            });

            localStorage.setItem('balanceHistory', JSON.stringify(balanceHistory));
            saveTradingSettings();

            drawBalanceChart();

            if (reason === 'TAKE PROFIT') {
                playNotificationSound('tp');
            } else if (reason === 'STOP LOSS') {
                playNotificationSound('sl');
            }
            
            addHistory(
                `ƒê√≥ng l·ªánh ${trade.type} #${trade.tradeIndex} @ ${closePrice.toFixed(2)} (${reason}) | ` +
                `L·ª£i nhu·∫≠n: <span class="${profit >= 0 ? 'profit' : 'loss'}">${profit.toFixed(2)} USD</span> | ` +
                `S·ªë d∆∞: ${virtualBalance.toFixed(2)} USD`
            );
            
            updateTradeInfo();
            updateStatus();
            
            logStatus(
                `üìâ ƒê√≥ng l·ªánh ${trade.type} #${trade.tradeIndex} (${reason}) | ` +
                `L·ª£i nhu·∫≠n: ${profit.toFixed(2)} USD | ` +
                `S·ªë d∆∞ m·ªõi: ${virtualBalance.toFixed(2)} USD`
            );
        }

        // **********************************************
        // END C√ÅC H√ÄM B·ªä THI·∫æU/QUAN TR·ªåNG
        // **********************************************


        // C·∫≠p nh·∫≠t th·ªëng k√™ g·ª£i √Ω 
        function updateSuggestionStats(trade, profit) {
            const currentTradeIndex = trade.tradeIndex;
            const type = trade.type; 

            // Ki·ªÉm tra ch·ªâ khi tradeIndex l·ªõn h∆°n lastTradeIndex c·ªßa g·ª£i √Ω c√πng lo·∫°i
            // Ho·∫∑c l√† trade ƒë·∫ßu ti√™n (lastTradeIndex = -1)
            if (suggestionStats[type].lastTradeIndex === -1 || currentTradeIndex > suggestionStats[type].lastTradeIndex) {
                 // N·∫øu ƒë√¢y l√† trade ƒë·∫ßu ti√™n sau khi c√≥ g·ª£i √Ω (ho·∫∑c trade ƒë·∫ßu ti√™n sau reset)
                 if (currentTradeIndex > suggestionStats[type].lastTradeIndex) {
                     suggestionStats[type].total++;
                     if (profit > 0) {
                         suggestionStats[type].correct++;
                     }
                 }
                suggestionStats[type].lastTradeIndex = currentTradeIndex;
            } 
            
            localStorage.setItem('suggestionStats', JSON.stringify(suggestionStats));
            updateSuggestionStatsDisplay();
        }

        // C·∫≠p nh·∫≠t hi·ªÉn th·ªã th·ªëng k√™ g·ª£i √Ω 
        function updateSuggestionStatsDisplay() {
            const buyTotal = suggestionStats.BUY.total;
            const buyCorrect = suggestionStats.BUY.correct;
            const sellTotal = suggestionStats.SELL.total;
            const sellCorrect = suggestionStats.SELL.correct;

            const buyPct = buyTotal > 0 ? ((buyCorrect / buyTotal) * 100).toFixed(2) : '0.00';
            const sellPct = sellTotal > 0 ? ((sellCorrect / sellTotal) * 100).toFixed(2) : '0.00';

            document.getElementById('statBuyTotal').textContent = buyTotal;
            document.getElementById('statBuyCorrect').textContent = buyCorrect;
            document.getElementById('statBuyPct').textContent = buyPct + '%';

            document.getElementById('statSellTotal').textContent = sellTotal;
            document.getElementById('statSellCorrect').textContent = sellCorrect;
            document.getElementById('statSellPct').textContent = sellPct + '%';
        }

        // V·∫Ω bi·ªÉu ƒë·ªì s·ªë d∆∞ v√† gi√° v√†ng 
        function drawBalanceChart() {
            if (!balanceHistory || balanceHistory.length === 0) {
                if (balanceChart) balanceChart.destroy();
                return;
            }
            const ctx = document.getElementById('balanceChart').getContext('2d');
            const labels = balanceHistory.map(item => new Date(item.time).toLocaleTimeString('vi-VN'));
            const balances = balanceHistory.map(item => item.balance);
            const goldPrices = balanceHistory.map(item => item.goldPrice);

            if (balanceChart) balanceChart.destroy();

            balanceChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'S·ªë D∆∞ (USD)',
                            data: balances,
                            borderColor: '#0ecb81',
                            backgroundColor: 'rgba(14, 203, 129, 0.1)',
                            tension: 0.2,
                            fill: true,
                            yAxisID: 'y'
                        },
                        {
                            label: 'Gi√° V√†ng (XAU/USD)',
                            data: goldPrices,
                            borderColor: '#d4af37',
                            backgroundColor: 'rgba(212, 175, 55, 0.1)',
                            tension: 0.2,
                            fill: false,
                            yAxisID: 'y1'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            title: {
                                display: true,
                                text: 'S·ªë D∆∞ (USD)'
                            }
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            title: {
                                display: true,
                                text: 'Gi√° V√†ng (USD)'
                            },
                            grid: {
                                drawOnChartArea: false
                            }
                        }
                    }
                }
            });

            setTimeout(() => {
                detectBalanceGoldIntersections();
                checkSuggestion(); // K√≠ch ho·∫°t ki·ªÉm tra g·ª£i √Ω sau khi v·∫Ω bi·ªÉu ƒë·ªì
            }, 100);
        }

        // Logic G·ª£i √Ω giao d·ªãch 
        function checkSuggestion() {
            if (!balanceChart) return;

            const dsBalance = balanceChart.data.datasets[0].data;
            const dsGold = balanceChart.data.datasets[1].data;
            const len = Math.min(dsBalance.length, dsGold.length);
            const { minSlope, minGapPct, confirmDelay, suggestionMode } = suggestionSettings;

            if (len < confirmDelay + 1) return;

            // L·∫•y d·ªØ li·ªáu g·∫ßn nh·∫•t (ch√∫ √Ω: ƒë√¢y l√† d·ªØ li·ªáu t·ª´ Balance History, kh√¥ng ph·∫£i real-time)
            const i = len - 1;
            const balanceNow = dsBalance[i];
            const goldNow = dsGold[i];
            const balancePrev = dsBalance[i - confirmDelay];
            const goldPrev = dsGold[i - confirmDelay];
            
            const timeLabel = balanceChart.data.labels[i];
            
            let suggestion = null;
            let reason = '';
            
            // T√≠nh to√°n ƒë·ªô d·ªëc (Slope) trung b√¨nh trong kho·∫£ng confirmDelay
            const balanceSlope = (balanceNow - balancePrev) / confirmDelay;
            const goldSlope = (goldNow - goldPrev) / confirmDelay;

            // T√≠nh kho·∫£ng c√°ch ph·∫ßn trƒÉm (Gap Percentage)
            const gapPct = ((balanceNow - goldNow) / goldNow) * 100;
            const prevGapPct = ((balancePrev - goldPrev) / goldPrev) * 100;

            const isCrossoverUp = (prevGapPct < 0 && gapPct >= 0); // V√†ng c·∫Øt l√™n S·ªë d∆∞
            const isCrossoverDown = (prevGapPct > 0 && gapPct <= 0); // V√†ng c·∫Øt xu·ªëng S·ªë d∆∞

            // 1. Logic C·∫Øt L√™n/Xu·ªëng & Xu h∆∞·ªõng (G·ª£i √Ω MUA/B√ÅN)
            if (isCrossoverUp) {
                if (goldSlope > minSlope) {
                    suggestion = 'BUY';
                    reason = 'Gi√° V√†ng c·∫Øt l√™n S·ªë D∆∞ v√† tƒÉng m·∫°nh.';
                } else if (goldSlope > 0) {
                    suggestion = 'BUY';
                    reason = 'Gi√° V√†ng c·∫Øt l√™n S·ªë D∆∞ (xu h∆∞·ªõng tƒÉng).';
                }
            } else if (isCrossoverDown) {
                if (goldSlope < -minSlope) {
                    suggestion = 'SELL';
                    reason = 'Gi√° V√†ng c·∫Øt xu·ªëng S·ªë D∆∞ v√† gi·∫£m m·∫°nh.';
                } else if (goldSlope < 0) {
                    suggestion = 'SELL';
                    reason = 'Gi√° V√†ng c·∫Øt xu·ªëng S·ªë D∆∞ (xu h∆∞·ªõng gi·∫£m).';
                }
            }
            
            // 2. Logic ƒê·∫£o Chi·ªÅu (G·ª£i √Ω MUA/B√ÅN M·∫°nh)
            if (!suggestion) {
                // ƒê·∫£o chi·ªÅu MUA: V√†ng ƒë√£ n·∫±m d∆∞·ªõi S·ªë d∆∞, nh∆∞ng ƒëang tƒÉng m·∫°nh
                if (gapPct < -minGapPct && goldSlope > minSlope * 2) { 
                    suggestion = 'STRONG BUY';
                    reason = 'Gi√° V√†ng gi·∫£m s√¢u d∆∞·ªõi S·ªë D∆∞, kh·∫£ nƒÉng b·∫≠t tƒÉng m·∫°nh.';
                }
                // ƒê·∫£o chi·ªÅu B√ÅN: V√†ng ƒë√£ n·∫±m tr√™n S·ªë d∆∞, nh∆∞ng ƒëang gi·∫£m m·∫°nh
                else if (gapPct > minGapPct && goldSlope < -minSlope * 2) {
                    suggestion = 'STRONG SELL';
                    reason = 'Gi√° V√†ng tƒÉng cao tr√™n S·ªë D∆∞, kh·∫£ nƒÉng ƒë·∫£o chi·ªÅu gi·∫£m m·∫°nh.';
                }
            }

            // L·ªçc theo Ch·∫ø ƒë·ªô hi·ªÉn th·ªã
            if (suggestionMode !== 'all') {
                if (suggestion && !suggestion.includes(suggestionMode.toUpperCase())) {
                    suggestion = null;
                }
            }

            // C·∫≠p nh·∫≠t m√†n h√¨nh & Th·ªëng k√™
            if (suggestion && suggestionStats[suggestion.replace('STRONG ', '')].lastIndex !== i) {
                const type = suggestion.includes('BUY') ? 'BUY' : 'SELL';
                
                // C·∫≠p nh·∫≠t th·ªëng k√™ v√† ƒë√°nh d·∫•u ƒë√£ g·ª£i √Ω t·∫°i ƒëi·ªÉm n√†y
                suggestionStats[type].lastIndex = i;
                suggestionStats[type].lastTime = timeLabel;
                
                localStorage.setItem('suggestionStats', JSON.stringify(suggestionStats));
                
                // Hi·ªÉn th·ªã
                const display = document.getElementById('suggestionDisplay');
                const className = suggestion.includes('BUY') ? 'suggest-buy' : 'suggest-sell';
                display.innerHTML = `<div class="${className}">${timeLabel} | **${suggestion}** | L√Ω do: ${reason}</div>`;
                
                logStatus(`üì¢ ${suggestion} G·ª£i √Ω | L√Ω do: ${reason}`);
                playNotificationSound('suggestion');
                
                // C·∫≠p nh·∫≠t ch·ªâ s·ªë l·ªánh g·∫ßn nh·∫•t
                // ƒêi·ªÅu n√†y gi√∫p h√†m updateSuggestionStats bi·∫øt l·ªánh n√†o l√† l·ªánh ti·∫øp theo sau g·ª£i √Ω
                suggestionStats[type].lastTradeIndex = tradesToday; 
            } else if (suggestion === null) {
                 document.getElementById('suggestionDisplay').innerHTML = 'Ch∆∞a c√≥ g·ª£i √Ω n√†o.';
            }
        }

        // Ph√°t hi·ªán giao nhau gi·ªØa s·ªë d∆∞ v√† gi√° v√†ng 
        function detectBalanceGoldIntersections() {
            if (!balanceChart) return;
            
            const dsBalance = balanceChart.data.datasets[0].data;
            const dsGold = balanceChart.data.datasets[1].data;
            const scaleL = balanceChart.scales['y'];
            const scaleR = balanceChart.scales['y1'];
            
            if (!scaleL || !scaleR) return;
            
            const len = Math.min(dsBalance.length, dsGold.length);
            
            for (let i = 1; i < len; i++) {
                try {
                    const prevDiff = dsBalance[i-1] - dsGold[i-1];
                    const curDiff = dsBalance[i] - dsGold[i];
                    
                    if ((prevDiff <= 0 && curDiff > 0) || // S·ªë d∆∞ c·∫Øt l√™n V√†ng (prevDiff √¢m, curDiff d∆∞∆°ng)
                        (prevDiff >= 0 && curDiff < 0)) { // S·ªë d∆∞ c·∫Øt xu·ªëng V√†ng (prevDiff d∆∞∆°ng, curDiff √¢m)
                        
                        if (!alertedIntersectionIndices.has(i)) {
                            alertedIntersectionIndices.add(i);
                            addHistory(`üîî Giao nhau S·ªë D∆∞ & Gi√° V√†ng t·∫°i ${balanceChart.data.labels[i] || ''}`);
                            playNotificationSound('intersection');
                        }
                    }
                } catch(e) {
                    console.error("L·ªói khi ph√°t hi·ªán giao nhau:", e);
                }
            }
        }

        // C·∫≠p nh·∫≠t th√¥ng tin l·ªánh 
        function updateTradeInfo() {
            const container = document.getElementById('currentTradeDetails');
            if (!container) return;
            
            container.innerHTML = '';
            
            // L·ªçc ra c√°c l·ªánh ƒëang m·ªü (closed: false)
            const activeTrades = currentTrades.filter(trade => !trade.closed);
            
            // Ch·ªâ hi·ªÉn th·ªã c√°c l·ªánh ƒëang m·ªü
            const tradesToDisplay = activeTrades;

            if (tradesToDisplay.length === 0) {
                 document.getElementById('activeTrades').style.display = 'none';
                 return;
            }

             document.getElementById('activeTrades').style.display = 'block';
            
            tradesToDisplay.forEach(trade => {
                const price = currentPrice; // ƒê·∫£m b·∫£o d√πng currentPrice m·ªõi nh·∫•t
                let profit = 0;
                
                if (!trade.closed) {
                    // T√≠nh l·ª£i nhu·∫≠n hi·ªán t·∫°i
                    profit = trade.type === 'BUY'
                        ? (price - trade.entryPrice) * trade.lotSize * trade.leverage
                        : (trade.entryPrice - price) * trade.lotSize * trade.leverage;
                } else {
                    profit = trade.profit || 0;
                }
                
                const profitClass = profit >= 0 ? 'profit' : 'loss';

                const tradeBox = document.createElement('div');
                tradeBox.className = `trade-box ${trade.type.toLowerCase()}`;
                tradeBox.innerHTML = `
                    <h3>${trade.type} #${trade.tradeIndex} ${trade.closed ? `(ƒê√É ƒê√ìNG - ${trade.closeReason})` : '(ƒêANG M·ªû)'}</h3>
                    <p>Gi√° v√†o: ${trade.entryPrice.toFixed(2)}</p>
                    <p>Gi√° hi·ªán t·∫°i: ${trade.closed ? trade.exitPrice.toFixed(2) : price.toFixed(2)}</p>
                    <p>L·ª£i nhu·∫≠n: <span class="${profitClass}">${profit.toFixed(2)} USD</span></p>
                    <p>SL: ${trade.stopLoss.toFixed(2)} | TP: ${trade.takeProfit.toFixed(2)}</p>
                    ${trade.closed ? `<p>Th·ªùi gian ƒë√≥ng: ${trade.exitTime}</p>` : ''}
                `;
                
                container.appendChild(tradeBox);
            });
        }
        
        // C·∫≠p nh·∫≠t tr·∫°ng th√°i 
        function updateStatus(extra = "") {
            let status = autoTradingActive ? "ƒêang giao d·ªãch t·ª± ƒë·ªông" : "ƒê√£ d·ª´ng";
            if (extra) status += " | " + extra;
            
            document.getElementById('statusText').textContent = status;
            document.getElementById('balanceText').textContent = virtualBalance.toFixed(2);
            document.getElementById('tradesCount').textContent = tradesToday;
        }

        // Th√™m v√†o l·ªãch s·ª≠ 
        function addHistory(message) {
            const now = new Date();
            const timeString = now.toLocaleTimeString('vi-VN');
            
            const historyList = document.getElementById('historyList');
            const historyItem = document.createElement('div');
            historyItem.className = 'history-item';
            historyItem.innerHTML = `<strong>${timeString}:</strong> ${message}`;
            
            // Ch·ªâ gi·ªØ l·∫°i 50 m·ª•c l·ªãch s·ª≠ g·∫ßn nh·∫•t
            if (historyList.children.length >= 50) {
                 historyList.removeChild(historyList.lastChild);
            }
            historyList.insertBefore(historyItem, historyList.firstChild);
        }

        // Kh·ªüi ƒë·ªông ·ª©ng d·ª•ng
        window.onload = function() {
            loadTradingSettings();
            loadSoundSettings();
            loadSuggestionSettings();
            
            // C√†i ƒë·∫∑t √¢m thanh m·∫∑c ƒë·ªãnh/b·∫≠t/t·∫Øt ƒë√£ ƒë∆∞·ª£c t·∫£i trong loadSoundSettings
            if (defaultSoundsEnabled) {
                document.getElementById('defaultSoundToggle').innerHTML = 'üîá T·∫Øt √Çm Thanh M·∫∑c ƒê·ªãnh';
                document.getElementById('defaultSoundToggle').style.backgroundColor = '#f6465d';
            } else {
                document.getElementById('defaultSoundToggle').innerHTML = 'üîä B·∫≠t √Çm Thanh M·∫∑c ƒê·ªãnh';
                document.getElementById('defaultSoundToggle').style.backgroundColor = '#0ecb81';
            }
            
            initChart();
            connectWebSocket();
            updateAlertLevels(); // G·ªåI H√ÄM C·∫¨P NH·∫¨T M·ªêC C·∫¢NH B√ÅO
            updateStatus();
            addHistory('üîÑ ·ª®ng d·ª•ng kh·ªüi ƒë·ªông');
            
            // Listeners cho C√†i ƒë·∫∑t giao d·ªãch
            ['virtualBalance', 'leverage', 'lotSize', 'stopLoss', 'takeProfit'].forEach(id => {
                document.getElementById(id).addEventListener('change', saveTradingSettings);
            });
            
            // Listener cho M·ªëc c·∫£nh b√°o
            document.getElementById('alertPrices').addEventListener('change', updateAlertLevels);
            
            // Listeners cho C√†i ƒë·∫∑t G·ª£i √Ω
            ['minSlope', 'minGapPct', 'confirmDelay', 'suggestionMode'].forEach(id => {
                document.getElementById(id).addEventListener('change', saveSuggestionSettings);
            });
        };
    </script>
</body>
</html>
